
2025-05-24T14:54:57.6013303Z ##[group]Run wget https://www.samba.org/ftp/talloc/talloc-2.4.2.tar.gz -O talloc-2.4.2.tar.gz
2025-05-24T14:54:57.6013944Z [36;1mwget https://www.samba.org/ftp/talloc/talloc-2.4.2.tar.gz -O talloc-2.4.2.tar.gz[0m
2025-05-24T14:54:57.6014349Z [36;1mtar -xf talloc-2.4.2.tar.gz[0m
2025-05-24T14:54:57.6059063Z shell: /usr/bin/bash -e {0}
2025-05-24T14:54:57.6059281Z env:
2025-05-24T14:54:57.6059471Z   ANDROID_NDK_HOME: /home/runner/android-ndk
2025-05-24T14:54:57.6060686Z   PATH: /home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
2025-05-24T14:54:57.6061914Z ##[endgroup]
2025-05-24T14:54:57.6151199Z --2025-05-24 14:54:57--  https://www.samba.org/ftp/talloc/talloc-2.4.2.tar.gz
2025-05-24T14:54:57.6350721Z Resolving www.samba.org (www.samba.org)... 144.76.82.148, 2a01:4f8:192:486::2:3
2025-05-24T14:54:57.7302543Z Connecting to www.samba.org (www.samba.org)|144.76.82.148|:443... connected.
2025-05-24T14:54:58.1196339Z HTTP request sent, awaiting response... 200 OK
2025-05-24T14:54:58.1197053Z Length: 679750 (664K) [application/gzip]
2025-05-24T14:54:58.1197962Z Saving to: ‚Äòtalloc-2.4.2.tar.gz‚Äô
2025-05-24T14:54:58.1198301Z 
2025-05-24T14:54:58.2165753Z      0K .......... .......... .......... .......... ..........  7%  516K 1s
2025-05-24T14:54:58.3099120Z     50K .......... .......... .......... .......... .......... 15%  535K 1s
2025-05-24T14:54:58.3120229Z    100K .......... .......... .......... .......... .......... 22% 23.2M 1s
2025-05-24T14:54:58.3125945Z    150K .......... .......... .......... .......... .......... 30% 83.0M 0s
2025-05-24T14:54:58.4062863Z    200K .......... .......... .......... .......... .......... 37%  538K 0s
2025-05-24T14:54:58.4067908Z    250K .......... .......... .......... .......... .......... 45% 41.1M 0s
2025-05-24T14:54:58.4072333Z    300K .......... .......... .......... .......... .......... 52%  117M 0s
2025-05-24T14:54:58.4076924Z    350K .......... .......... .......... .......... .......... 60%  104M 0s
2025-05-24T14:54:58.5008388Z    400K .......... .......... .......... .......... .......... 67%  537K 0s
2025-05-24T14:54:58.5013227Z    450K .......... .......... .......... .......... .......... 75% 96.5M 0s
2025-05-24T14:54:58.5017380Z    500K .......... .......... .......... .......... .......... 82%  107M 0s
2025-05-24T14:54:58.5021787Z    550K .......... .......... .......... .......... .......... 90%  121M 0s
2025-05-24T14:54:58.5026640Z    600K .......... .......... .......... .......... .......... 97%  117M 0s
2025-05-24T14:54:58.5027374Z    650K .......... ...                                        100%  115M=0.4s
2025-05-24T14:54:58.5027605Z 
2025-05-24T14:54:58.5027949Z 2025-05-24 14:54:58 (1.69 MB/s) - ‚Äòtalloc-2.4.2.tar.gz‚Äô saved [679750/679750]
2025-05-24T14:54:58.5028485Z 
2025-05-24T14:54:58.5265771Z ##[group]Run set -xe
2025-05-24T14:54:58.5266102Z [36;1mset -xe[0m
2025-05-24T14:54:58.5266292Z [36;1mcd talloc-2.4.2[0m
2025-05-24T14:54:58.5266483Z [36;1m[0m
2025-05-24T14:54:58.5266687Z [36;1m# –°–æ–∑–¥–∞—ë–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π config.h –¥–ª—è lib/replace[0m
2025-05-24T14:54:58.5269353Z [36;1mecho -e "#ifndef TALLOC_DUMMY_CONFIG_H\n#define TALLOC_DUMMY_CONFIG_H\n\n#define HAVE_STDINT_H 1\n#define HAVE_STDDEF_H 1\n#define HAVE_ALLOCA_H 1\n#define HAVE_INTTYPES_H 1\n#define HAVE_SYS_TYPES_H 1\n#define HAVE_SYS_STAT_H 1\n#define HAVE_SYS_TIME_H 1\n#define HAVE_TIME_H 1\n#define HAVE_UNISTD_H 1\n#define HAVE_STRING_H 1\n#define HAVE_MEMORY_H 1\n#define HAVE_LIMITS_H 1\n#define HAVE_ASSERT_H 1\n#define HAVE_STDLIB_H 1\n#define HAVE_STDARG_H 1\n#define HAVE_SYS_MMAN_H 1\n#define HAVE_SYS_RESOURCE_H 1\n#define HAVE_SYS_WAIT_H 1\n#define HAVE_SYSLOG_H 1\n#define HAVE_SETENV 1\n#define HAVE_UNSETENV 1\n#define HAVE_SNPRINTF 1\n#define HAVE_VSNPRINTF 1\n#define HAVE_ASPRINTF 1\n#define HAVE_VASPRINTF 1\n#define HAVE_GETPAGESIZE 1\n#define HAVE_MMAP 1\n#define HAVE_SYS_SOCKET_H 1\n\n#define HAVE_BOOL 1\n#define HAVE__BOOL 1\n#define HAVE_STDBOOL_H 1\n\n#define _GNU_SOURCE 1\n#define _POSIX_SOURCE 1\n#define _POSIX_C_SOURCE 200809L\n\n#define __STDC_WANT_LIB_EXT1__ 1\n\n#endif" > config.h[0m
2025-05-24T14:54:58.5271963Z [36;1m[0m
2025-05-24T14:54:58.5272142Z [36;1m# –ö–æ–ø–∏—Ä—É–µ–º config.h –≤ lib/replace[0m
2025-05-24T14:54:58.5272387Z [36;1mcp config.h lib/replace/[0m
2025-05-24T14:54:58.5272593Z [36;1m[0m
2025-05-24T14:54:58.5272775Z [36;1m# –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏ –≤—ã–≤–æ–¥ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Ñ–∞–π–ª–æ–≤[0m
2025-05-24T14:54:58.5273046Z [36;1mecho "=== Original replace.h ==="[0m
2025-05-24T14:54:58.5273297Z [36;1mcat lib/replace/replace.h[0m
2025-05-24T14:54:58.5273521Z [36;1mecho "=== End of replace.h ==="[0m
2025-05-24T14:54:58.5273789Z [36;1mecho "=== Original .c files in lib/replace ==="[0m
2025-05-24T14:54:58.5274058Z [36;1mfor file in lib/replace/*.c; do[0m
2025-05-24T14:54:58.5274300Z [36;1m  echo "Content of $file:"[0m
2025-05-24T14:54:58.5274511Z [36;1m  cat "$file"[0m
2025-05-24T14:54:58.5274812Z [36;1m  echo "-------------------"[0m
2025-05-24T14:54:58.5275022Z [36;1mdone[0m
2025-05-24T14:54:58.5275170Z [36;1m[0m
2025-05-24T14:54:58.5275498Z [36;1m# –ê–Ω–∞–ª–∏–∑ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –ø–∞—Ç—á–∞[0m
2025-05-24T14:54:58.5275827Z [36;1mecho "Analyzing replace.h for typedef conflicts..."[0m
2025-05-24T14:54:58.5276123Z [36;1mPATTERNS=()[0m
2025-05-24T14:54:58.5276376Z [36;1mif grep -q "typedef.*intptr_t" lib/replace/replace.h; then[0m
2025-05-24T14:54:58.5276692Z [36;1m  PATTERNS+=("typedef.*intptr_t")[0m
2025-05-24T14:54:58.5276907Z [36;1mfi[0m
2025-05-24T14:54:58.5277144Z [36;1mif grep -q "typedef.*uintptr_t" lib/replace/replace.h; then[0m
2025-05-24T14:54:58.5277453Z [36;1m  PATTERNS+=("typedef.*uintptr_t")[0m
2025-05-24T14:54:58.5277670Z [36;1mfi[0m
2025-05-24T14:54:58.5277893Z [36;1mif grep -q "typedef.*ptrdiff_t" lib/replace/replace.h; then[0m
2025-05-24T14:54:58.5278209Z [36;1m  PATTERNS+=("typedef.*ptrdiff_t")[0m
2025-05-24T14:54:58.5278429Z [36;1mfi[0m
2025-05-24T14:54:58.5278658Z [36;1mif grep -q "typedef.*useconds_t" lib/replace/replace.h; then[0m
2025-05-24T14:54:58.5278975Z [36;1m  PATTERNS+=("typedef.*useconds_t")[0m
2025-05-24T14:54:58.5279198Z [36;1mfi[0m
2025-05-24T14:54:58.5279357Z [36;1mRTLD_NEEDED=false[0m
2025-05-24T14:54:58.5279572Z [36;1mfor file in lib/replace/*.c; do[0m
2025-05-24T14:54:58.5279821Z [36;1m  if grep -q "RTLD_DEFAULT" "$file"; then[0m
2025-05-24T14:54:58.5280072Z [36;1m    RTLD_NEEDED=true[0m
2025-05-24T14:54:58.5280259Z [36;1m    break[0m
2025-05-24T14:54:58.5280421Z [36;1m  fi[0m
2025-05-24T14:54:58.5280661Z [36;1mdone[0m
2025-05-24T14:54:58.5280813Z [36;1m[0m
2025-05-24T14:54:58.5280973Z [36;1m# –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ç—á–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞[0m
2025-05-24T14:54:58.5281218Z [36;1mif [ ${#PATTERNS[@]} -gt 0 ]; then[0m
2025-05-24T14:54:58.5281717Z [36;1m  echo "Patching replace.h to remove conflicting typedefs: ${PATTERNS[*]}"[0m
2025-05-24T14:54:58.5282093Z [36;1m  for pattern in "${PATTERNS[@]}"; do[0m
2025-05-24T14:54:58.5282392Z [36;1m    sed -i "/$pattern/d" lib/replace/replace.h[0m
2025-05-24T14:54:58.5282641Z [36;1m  done[0m
2025-05-24T14:54:58.5282797Z [36;1mfi[0m
2025-05-24T14:54:58.5282962Z [36;1mif [ "$RTLD_NEEDED" = true ]; then[0m
2025-05-24T14:54:58.5283248Z [36;1m  echo "Adding RTLD_DEFAULT definition to replace.h"[0m
2025-05-24T14:54:58.5283585Z [36;1m  echo "#ifndef RTLD_DEFAULT" >> lib/replace/replace.h[0m
2025-05-24T14:54:58.5283934Z [36;1m  echo "#define RTLD_DEFAULT ((void *)0)" >> lib/replace/replace.h[0m
2025-05-24T14:54:58.5284263Z [36;1m  echo "#endif" >> lib/replace/replace.h[0m
2025-05-24T14:54:58.5284497Z [36;1mfi[0m
2025-05-24T14:54:58.5284643Z [36;1m[0m
2025-05-24T14:54:58.5284799Z [36;1m# –í—ã–≤–æ–¥ –ø–∞—Çched replace.h[0m
2025-05-24T14:54:58.5285026Z [36;1mecho "=== Patched replace.h ==="[0m
2025-05-24T14:54:58.5285262Z [36;1mcat lib/replace/replace.h[0m
2025-05-24T14:54:58.5285709Z [36;1mecho "=== End of patched replace.h ==="[0m
2025-05-24T14:54:58.5285947Z [36;1m[0m
2025-05-24T14:54:58.5286105Z [36;1mexport ANDROID_API=21[0m
2025-05-24T14:54:58.5286336Z [36;1mexport NDK_HOME="$HOME/android-ndk"[0m
2025-05-24T14:54:58.5286678Z [36;1mexport TOOLCHAIN="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin"[0m
2025-05-24T14:54:58.5287128Z [36;1mexport SYSROOT="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/sysroot"[0m
2025-05-24T14:54:58.5287569Z [36;1mexport CC="$TOOLCHAIN/aarch64-linux-android$ANDROID_API-clang"[0m
2025-05-24T14:54:58.5287893Z [36;1mexport AR="$TOOLCHAIN/llvm-ar"[0m
2025-05-24T14:54:58.5288155Z [36;1mexport RANLIB="$TOOLCHAIN/llvm-ranlib"[0m
2025-05-24T14:54:58.5288707Z [36;1mexport CFLAGS="--target=aarch64-linux-android$ANDROID_API --sysroot=$SYSROOT -fPIC -DANDROID -I$PWD -I$PWD/lib/replace -std=c99"[0m
2025-05-24T14:54:58.5289391Z [36;1mexport LDFLAGS="--target=aarch64-linux-android$ANDROID_API --sysroot=$SYSROOT -fPIC"[0m
2025-05-24T14:54:58.5289773Z [36;1m[0m
2025-05-24T14:54:58.5289951Z [36;1mmkdir -p install/include install/lib[0m
2025-05-24T14:54:58.5290271Z [36;1m[0m
2025-05-24T14:54:58.5290433Z [36;1m# –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã –∏–∑ lib/replace[0m
2025-05-24T14:54:58.5290663Z [36;1mcd lib/replace[0m
2025-05-24T14:54:58.5290852Z [36;1mfor src in *.c; do[0m
2025-05-24T14:54:58.5291073Z [36;1m  $CC $CFLAGS -c "$src" -o "${src%.c}.o"[0m
2025-05-24T14:54:58.5291302Z [36;1mdone[0m
2025-05-24T14:54:58.5291476Z [36;1m$AR rcs libreplacestub.a *.o[0m
2025-05-24T14:54:58.5291692Z [36;1mcd ../..[0m
2025-05-24T14:54:58.5291850Z [36;1m[0m
2025-05-24T14:54:58.5292002Z [36;1m# –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º talloc.c[0m
2025-05-24T14:54:58.5292227Z [36;1m$CC $CFLAGS -c talloc.c -o talloc.o[0m
2025-05-24T14:54:58.5292452Z [36;1m[0m
2025-05-24T14:54:58.5292641Z [36;1m# –°–æ–∑–¥–∞—ë–º libtalloc.a, –≤–∫–ª—é—á–∞—è –æ–±—ä–µ–∫—Ç—ã –∏–∑ lib/replace[0m
2025-05-24T14:54:58.5292941Z [36;1m$AR rcs libtalloc.a talloc.o lib/replace/*.o[0m
2025-05-24T14:54:58.5293177Z [36;1m[0m
2025-05-24T14:54:58.5293354Z [36;1m# –ö–æ–ø–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã –∏ –±–∏–±–ª–∏–æ—Ç–µ–∫—É[0m
2025-05-24T14:54:58.5293599Z [36;1mcp talloc.h install/include/[0m
2025-05-24T14:54:58.5293858Z [36;1mcp lib/replace/replace.h install/include/[0m
2025-05-24T14:54:58.5294120Z [36;1mcp config.h install/include/[0m
2025-05-24T14:54:58.5294343Z [36;1mcp libtalloc.a install/lib/[0m
2025-05-24T14:54:58.5294553Z [36;1m[0m
2025-05-24T14:54:58.5294703Z [36;1mls -al install/include[0m
2025-05-24T14:54:58.5294914Z [36;1mls -al install/lib[0m
2025-05-24T14:54:58.5339302Z shell: /usr/bin/bash -e {0}
2025-05-24T14:54:58.5339519Z env:
2025-05-24T14:54:58.5339701Z   ANDROID_NDK_HOME: /home/runner/android-ndk
2025-05-24T14:54:58.5341127Z   PATH: /home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
2025-05-24T14:54:58.5342298Z ##[endgroup]
2025-05-24T14:54:58.5399756Z + cd talloc-2.4.2
2025-05-24T14:54:58.5404835Z + echo -e '#ifndef TALLOC_DUMMY_CONFIG_H\n#define TALLOC_DUMMY_CONFIG_H\n\n#define HAVE_STDINT_H 1\n#define HAVE_STDDEF_H 1\n#define HAVE_ALLOCA_H 1\n#define HAVE_INTTYPES_H 1\n#define HAVE_SYS_TYPES_H 1\n#define HAVE_SYS_STAT_H 1\n#define HAVE_SYS_TIME_H 1\n#define HAVE_TIME_H 1\n#define HAVE_UNISTD_H 1\n#define HAVE_STRING_H 1\n#define HAVE_MEMORY_H 1\n#define HAVE_LIMITS_H 1\n#define HAVE_ASSERT_H 1\n#define HAVE_STDLIB_H 1\n#define HAVE_STDARG_H 1\n#define HAVE_SYS_MMAN_H 1\n#define HAVE_SYS_RESOURCE_H 1\n#define HAVE_SYS_WAIT_H 1\n#define HAVE_SYSLOG_H 1\n#define HAVE_SETENV 1\n#define HAVE_UNSETENV 1\n#define HAVE_SNPRINTF 1\n#define HAVE_VSNPRINTF 1\n#define HAVE_ASPRINTF 1\n#define HAVE_VASPRINTF 1\n#define HAVE_GETPAGESIZE 1\n#define HAVE_MMAP 1\n#define HAVE_SYS_SOCKET_H 1\n\n#define HAVE_BOOL 1\n#define HAVE__BOOL 1\n#define HAVE_STDBOOL_H 1\n\n#define _GNU_SOURCE 1\n#define _POSIX_SOURCE 1\n#define _POSIX_C_SOURCE 200809L\n\n#define __STDC_WANT_LIB_EXT1__ 1\n\n#endif'
2025-05-24T14:54:58.5407749Z + cp config.h lib/replace/
2025-05-24T14:54:58.5418254Z + echo '=== Original replace.h ==='
2025-05-24T14:54:58.5418653Z === Original replace.h ===
2025-05-24T14:54:58.5418996Z + cat lib/replace/replace.h
2025-05-24T14:54:58.5427863Z /*
2025-05-24T14:54:58.5428244Z    Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5428586Z 
2025-05-24T14:54:58.5428836Z    macros to go along with the lib/replace/ portability layer code
2025-05-24T14:54:58.5429249Z 
2025-05-24T14:54:58.5429397Z    Copyright (C) Andrew Tridgell 2005
2025-05-24T14:54:58.5429827Z    Copyright (C) Jelmer Vernooij 2006-2008
2025-05-24T14:54:58.5430254Z    Copyright (C) Jeremy Allison 2007.
2025-05-24T14:54:58.5430534Z 
2025-05-24T14:54:58.5430741Z      ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5431435Z      ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5431908Z      ** under the LGPL
2025-05-24T14:54:58.5432104Z 
2025-05-24T14:54:58.5432478Z    This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5433086Z    modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5433684Z    License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5434307Z    version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5434675Z 
2025-05-24T14:54:58.5434925Z    This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5435888Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5436587Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5437200Z    Lesser General Public License for more details.
2025-05-24T14:54:58.5437524Z 
2025-05-24T14:54:58.5437791Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5438527Z    License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5439090Z */
2025-05-24T14:54:58.5439239Z 
2025-05-24T14:54:58.5439374Z #ifndef _LIBREPLACE_REPLACE_H
2025-05-24T14:54:58.5439739Z #define _LIBREPLACE_REPLACE_H
2025-05-24T14:54:58.5439966Z 
2025-05-24T14:54:58.5440073Z #ifndef NO_CONFIG_H
2025-05-24T14:54:58.5440320Z #include "config.h"
2025-05-24T14:54:58.5440488Z #endif
2025-05-24T14:54:58.5440575Z 
2025-05-24T14:54:58.5440647Z #ifdef HAVE_STANDARDS_H
2025-05-24T14:54:58.5440836Z #include <standards.h>
2025-05-24T14:54:58.5441002Z #endif
2025-05-24T14:54:58.5441085Z 
2025-05-24T14:54:58.5441150Z /*
2025-05-24T14:54:58.5441490Z  * Needs to be defined before std*.h and string*.h are included
2025-05-24T14:54:58.5441832Z  * As it's also needed when Python.h is the first header we
2025-05-24T14:54:58.5442121Z  * require a global -D__STDC_WANT_LIB_EXT1__=1
2025-05-24T14:54:58.5442353Z  */
2025-05-24T14:54:58.5442505Z #if __STDC_WANT_LIB_EXT1__ != 1
2025-05-24T14:54:58.5442847Z #error -D__STDC_WANT_LIB_EXT1__=1 required
2025-05-24T14:54:58.5443072Z #endif
2025-05-24T14:54:58.5443156Z 
2025-05-24T14:54:58.5443222Z #include <stdio.h>
2025-05-24T14:54:58.5443390Z #include <stdlib.h>
2025-05-24T14:54:58.5443551Z #include <stdarg.h>
2025-05-24T14:54:58.5443813Z #include <errno.h>
2025-05-24T14:54:58.5443985Z 
2025-05-24T14:54:58.5444087Z #ifndef HAVE_DECL_EWOULDBLOCK
2025-05-24T14:54:58.5444305Z #define EWOULDBLOCK EAGAIN
2025-05-24T14:54:58.5444483Z #endif
2025-05-24T14:54:58.5444568Z 
2025-05-24T14:54:58.5444661Z #if defined(_MSC_VER) || defined(__MINGW32__)
2025-05-24T14:54:58.5444900Z #include "win32_replace.h"
2025-05-24T14:54:58.5445182Z #endif
2025-05-24T14:54:58.5445325Z 
2025-05-24T14:54:58.5445330Z 
2025-05-24T14:54:58.5445623Z #ifdef HAVE_INTTYPES_H
2025-05-24T14:54:58.5445959Z #define __STDC_FORMAT_MACROS
2025-05-24T14:54:58.5446321Z #include <inttypes.h>
2025-05-24T14:54:58.5446649Z #elif defined(HAVE_STDINT_H)
2025-05-24T14:54:58.5446999Z #include <stdint.h>
2025-05-24T14:54:58.5447452Z /* force off HAVE_INTTYPES_H so that roken doesn't try to include both,
2025-05-24T14:54:58.5448054Z    which causes a warning storm on irix */
2025-05-24T14:54:58.5448340Z #undef HAVE_INTTYPES_H
2025-05-24T14:54:58.5448511Z #endif
2025-05-24T14:54:58.5448599Z 
2025-05-24T14:54:58.5448672Z #ifdef HAVE_MALLOC_H
2025-05-24T14:54:58.5448845Z #include <malloc.h>
2025-05-24T14:54:58.5449003Z #endif
2025-05-24T14:54:58.5449083Z 
2025-05-24T14:54:58.5449152Z #ifndef __PRI64_PREFIX
2025-05-24T14:54:58.5449361Z # if __WORDSIZE == 64 && ! defined __APPLE__
2025-05-24T14:54:58.5449606Z #  define __PRI64_PREFIX	"l"
2025-05-24T14:54:58.5449797Z # else
2025-05-24T14:54:58.5449953Z #  define __PRI64_PREFIX	"ll"
2025-05-24T14:54:58.5450145Z # endif
2025-05-24T14:54:58.5450286Z #endif
2025-05-24T14:54:58.5450367Z 
2025-05-24T14:54:58.5450439Z /* Decimal notation.  */
2025-05-24T14:54:58.5450630Z #ifndef PRId8
2025-05-24T14:54:58.5450790Z # define PRId8		"d"
2025-05-24T14:54:58.5450953Z #endif
2025-05-24T14:54:58.5451095Z #ifndef PRId16
2025-05-24T14:54:58.5451260Z # define PRId16		"d"
2025-05-24T14:54:58.5451542Z #endif
2025-05-24T14:54:58.5451685Z #ifndef PRId32
2025-05-24T14:54:58.5451841Z # define PRId32		"d"
2025-05-24T14:54:58.5452010Z #endif
2025-05-24T14:54:58.5452147Z #ifndef PRId64
2025-05-24T14:54:58.5452322Z # define PRId64		__PRI64_PREFIX "d"
2025-05-24T14:54:58.5452533Z #endif
2025-05-24T14:54:58.5452617Z 
2025-05-24T14:54:58.5452679Z #ifndef PRIi8
2025-05-24T14:54:58.5452841Z # define PRIi8		"i"
2025-05-24T14:54:58.5453001Z #endif
2025-05-24T14:54:58.5453147Z #ifndef PRIi16
2025-05-24T14:54:58.5453304Z # define PRIi16		"i"
2025-05-24T14:54:58.5453469Z #endif
2025-05-24T14:54:58.5453624Z #ifndef PRIi32
2025-05-24T14:54:58.5453785Z # define PRIi32		"i"
2025-05-24T14:54:58.5453940Z #endif
2025-05-24T14:54:58.5454080Z #ifndef PRIi64
2025-05-24T14:54:58.5454245Z # define PRIi64		__PRI64_PREFIX "i"
2025-05-24T14:54:58.5454450Z #endif
2025-05-24T14:54:58.5454529Z 
2025-05-24T14:54:58.5454596Z #ifndef PRIu8
2025-05-24T14:54:58.5454755Z # define PRIu8		"u"
2025-05-24T14:54:58.5454907Z #endif
2025-05-24T14:54:58.5455051Z #ifndef PRIu16
2025-05-24T14:54:58.5455205Z # define PRIu16		"u"
2025-05-24T14:54:58.5455552Z #endif
2025-05-24T14:54:58.5455783Z #ifndef PRIu32
2025-05-24T14:54:58.5455942Z # define PRIu32		"u"
2025-05-24T14:54:58.5456105Z #endif
2025-05-24T14:54:58.5456360Z #ifndef PRIu64
2025-05-24T14:54:58.5456656Z # define PRIu64		__PRI64_PREFIX "u"
2025-05-24T14:54:58.5456996Z #endif
2025-05-24T14:54:58.5457129Z 
2025-05-24T14:54:58.5457235Z #ifndef SCNd8
2025-05-24T14:54:58.5457496Z # define SCNd8		"hhd"
2025-05-24T14:54:58.5457796Z #endif
2025-05-24T14:54:58.5458207Z #ifndef SCNd16
2025-05-24T14:54:58.5458505Z # define SCNd16		"hd"
2025-05-24T14:54:58.5458797Z #endif
2025-05-24T14:54:58.5459040Z #ifndef SCNd32
2025-05-24T14:54:58.5459310Z # define SCNd32		"d"
2025-05-24T14:54:58.5459604Z #endif
2025-05-24T14:54:58.5459852Z #ifndef SCNd64
2025-05-24T14:54:58.5460201Z # define SCNd64		__PRI64_PREFIX "d"
2025-05-24T14:54:58.5460417Z #endif
2025-05-24T14:54:58.5460497Z 
2025-05-24T14:54:58.5460558Z #ifndef SCNi8
2025-05-24T14:54:58.5460721Z # define SCNi8		"hhi"
2025-05-24T14:54:58.5460883Z #endif
2025-05-24T14:54:58.5461025Z #ifndef SCNi16
2025-05-24T14:54:58.5461176Z # define SCNi16		"hi"
2025-05-24T14:54:58.5461339Z #endif
2025-05-24T14:54:58.5461477Z #ifndef SCNi32
2025-05-24T14:54:58.5461636Z # define SCNi32		"i"
2025-05-24T14:54:58.5461798Z #endif
2025-05-24T14:54:58.5461979Z #ifndef SCNi64
2025-05-24T14:54:58.5462151Z # define SCNi64		__PRI64_PREFIX "i"
2025-05-24T14:54:58.5462345Z #endif
2025-05-24T14:54:58.5462423Z 
2025-05-24T14:54:58.5462490Z #ifndef SCNu8
2025-05-24T14:54:58.5462648Z # define SCNu8		"hhu"
2025-05-24T14:54:58.5462808Z #endif
2025-05-24T14:54:58.5462942Z #ifndef SCNu16
2025-05-24T14:54:58.5463096Z # define SCNu16		"hu"
2025-05-24T14:54:58.5463253Z #endif
2025-05-24T14:54:58.5463395Z #ifndef SCNu32
2025-05-24T14:54:58.5463547Z # define SCNu32		"u"
2025-05-24T14:54:58.5463716Z #endif
2025-05-24T14:54:58.5463854Z #ifndef SCNu64
2025-05-24T14:54:58.5464024Z # define SCNu64		__PRI64_PREFIX "u"
2025-05-24T14:54:58.5464224Z #endif
2025-05-24T14:54:58.5464302Z 
2025-05-24T14:54:58.5464376Z #ifdef HAVE_BSD_STRING_H
2025-05-24T14:54:58.5464566Z #include <bsd/string.h>
2025-05-24T14:54:58.5464737Z #endif
2025-05-24T14:54:58.5464815Z 
2025-05-24T14:54:58.5464889Z #ifdef HAVE_BSD_UNISTD_H
2025-05-24T14:54:58.5465069Z #include <bsd/unistd.h>
2025-05-24T14:54:58.5465236Z #endif
2025-05-24T14:54:58.5465316Z 
2025-05-24T14:54:58.5465575Z #ifdef HAVE_UNISTD_H
2025-05-24T14:54:58.5465754Z #include <unistd.h>
2025-05-24T14:54:58.5465910Z #endif
2025-05-24T14:54:58.5465996Z 
2025-05-24T14:54:58.5466061Z #ifdef HAVE_STRING_H
2025-05-24T14:54:58.5466231Z #include <string.h>
2025-05-24T14:54:58.5466383Z #endif
2025-05-24T14:54:58.5466461Z 
2025-05-24T14:54:58.5466533Z #ifdef HAVE_STRINGS_H
2025-05-24T14:54:58.5466703Z #include <strings.h>
2025-05-24T14:54:58.5466862Z #endif
2025-05-24T14:54:58.5466943Z 
2025-05-24T14:54:58.5467012Z #ifdef HAVE_SYS_TYPES_H
2025-05-24T14:54:58.5467193Z #include <sys/types.h>
2025-05-24T14:54:58.5467442Z #endif
2025-05-24T14:54:58.5467525Z 
2025-05-24T14:54:58.5467600Z #ifdef HAVE_SYS_SYSMACROS_H
2025-05-24T14:54:58.5467923Z #include <sys/sysmacros.h>
2025-05-24T14:54:58.5468229Z #endif
2025-05-24T14:54:58.5468364Z 
2025-05-24T14:54:58.5468498Z #ifdef HAVE_SETPROCTITLE_H
2025-05-24T14:54:58.5468825Z #include <setproctitle.h>
2025-05-24T14:54:58.5469127Z #endif
2025-05-24T14:54:58.5469258Z 
2025-05-24T14:54:58.5469364Z #if STDC_HEADERS
2025-05-24T14:54:58.5469658Z #include <stdlib.h>
2025-05-24T14:54:58.5469951Z #include <stddef.h>
2025-05-24T14:54:58.5470216Z #endif
2025-05-24T14:54:58.5470348Z 
2025-05-24T14:54:58.5470462Z #ifdef HAVE_LINUX_TYPES_H
2025-05-24T14:54:58.5470760Z /*
2025-05-24T14:54:58.5471057Z  * This is needed as some broken header files require this to be included early
2025-05-24T14:54:58.5471379Z  */
2025-05-24T14:54:58.5471534Z #include <linux/types.h>
2025-05-24T14:54:58.5471713Z #endif
2025-05-24T14:54:58.5471795Z 
2025-05-24T14:54:58.5471866Z #ifndef HAVE_STRERROR
2025-05-24T14:54:58.5472065Z extern const char *const sys_errlist[];
2025-05-24T14:54:58.5472310Z #define strerror(i) sys_errlist[i]
2025-05-24T14:54:58.5472512Z #endif
2025-05-24T14:54:58.5472599Z 
2025-05-24T14:54:58.5472668Z #ifndef HAVE_ERRNO_DECL
2025-05-24T14:54:58.5472847Z extern int errno;
2025-05-24T14:54:58.5473002Z #endif
2025-05-24T14:54:58.5473081Z 
2025-05-24T14:54:58.5473150Z #ifndef HAVE_STRDUP
2025-05-24T14:54:58.5473322Z #define strdup rep_strdup
2025-05-24T14:54:58.5473526Z char *rep_strdup(const char *s);
2025-05-24T14:54:58.5473721Z #endif
2025-05-24T14:54:58.5473904Z 
2025-05-24T14:54:58.5473971Z #ifndef HAVE_MEMMOVE
2025-05-24T14:54:58.5474151Z #define memmove rep_memmove
2025-05-24T14:54:58.5474400Z void *rep_memmove(void *dest,const void *src,int size);
2025-05-24T14:54:58.5474656Z #endif
2025-05-24T14:54:58.5474744Z 
2025-05-24T14:54:58.5474807Z #ifndef HAVE_MEMMEM
2025-05-24T14:54:58.5475092Z #define memmem rep_memmem
2025-05-24T14:54:58.5475508Z void *rep_memmem(const void *haystack, size_t haystacklen,
2025-05-24T14:54:58.5475851Z 		 const void *needle, size_t needlelen);
2025-05-24T14:54:58.5476068Z #endif
2025-05-24T14:54:58.5476156Z 
2025-05-24T14:54:58.5476224Z #ifndef HAVE_MEMALIGN
2025-05-24T14:54:58.5476408Z #define memalign rep_memalign
2025-05-24T14:54:58.5476642Z void *rep_memalign(size_t boundary, size_t size);
2025-05-24T14:54:58.5476877Z #endif
2025-05-24T14:54:58.5476961Z 
2025-05-24T14:54:58.5477025Z #ifndef HAVE_MKTIME
2025-05-24T14:54:58.5477197Z #define mktime rep_mktime
2025-05-24T14:54:58.5477396Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.5477613Z #endif
2025-05-24T14:54:58.5477691Z 
2025-05-24T14:54:58.5477754Z #ifndef HAVE_TIMEGM
2025-05-24T14:54:58.5477923Z #define timegm rep_timegm
2025-05-24T14:54:58.5478115Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.5478322Z #endif
2025-05-24T14:54:58.5478400Z 
2025-05-24T14:54:58.5478469Z #ifndef HAVE_UTIME
2025-05-24T14:54:58.5478642Z #define utime rep_utime
2025-05-24T14:54:58.5478955Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.5479327Z #endif
2025-05-24T14:54:58.5479458Z 
2025-05-24T14:54:58.5479573Z #ifndef HAVE_UTIMES
2025-05-24T14:54:58.5479781Z #define utimes rep_utimes
2025-05-24T14:54:58.5479983Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.5480309Z #endif
2025-05-24T14:54:58.5480463Z 
2025-05-24T14:54:58.5480578Z #ifndef HAVE_STRLCPY
2025-05-24T14:54:58.5480892Z #define strlcpy rep_strlcpy
2025-05-24T14:54:58.5481352Z size_t rep_strlcpy(char *d, const char *s, size_t bufsize);
2025-05-24T14:54:58.5481815Z #endif
2025-05-24T14:54:58.5481972Z 
2025-05-24T14:54:58.5482087Z #ifndef HAVE_STRLCAT
2025-05-24T14:54:58.5482406Z #define strlcat rep_strlcat
2025-05-24T14:54:58.5482855Z size_t rep_strlcat(char *d, const char *s, size_t bufsize);
2025-05-24T14:54:58.5483316Z #endif
2025-05-24T14:54:58.5483454Z 
2025-05-24T14:54:58.5483572Z #ifndef HAVE_CLOSEFROM
2025-05-24T14:54:58.5483880Z #define closefrom rep_closefrom
2025-05-24T14:54:58.5484095Z int rep_closefrom(int lower);
2025-05-24T14:54:58.5484426Z #endif
2025-05-24T14:54:58.5484508Z 
2025-05-24T14:54:58.5484511Z 
2025-05-24T14:54:58.5484624Z #if (defined(BROKEN_STRNDUP) || !defined(HAVE_STRNDUP))
2025-05-24T14:54:58.5484888Z #undef HAVE_STRNDUP
2025-05-24T14:54:58.5485067Z #define strndup rep_strndup
2025-05-24T14:54:58.5485280Z char *rep_strndup(const char *s, size_t n);
2025-05-24T14:54:58.5485804Z #endif
2025-05-24T14:54:58.5485888Z 
2025-05-24T14:54:58.5485997Z #if (defined(BROKEN_STRNLEN) || !defined(HAVE_STRNLEN))
2025-05-24T14:54:58.5486248Z #undef HAVE_STRNLEN
2025-05-24T14:54:58.5486430Z #define strnlen rep_strnlen
2025-05-24T14:54:58.5486648Z size_t rep_strnlen(const char *s, size_t n);
2025-05-24T14:54:58.5486871Z #endif
2025-05-24T14:54:58.5486956Z 
2025-05-24T14:54:58.5487031Z #if !defined(HAVE_DECL_ENVIRON)
2025-05-24T14:54:58.5487231Z # ifdef __APPLE__
2025-05-24T14:54:58.5487401Z #   include <crt_externs.h>
2025-05-24T14:54:58.5487607Z #   define environ (*_NSGetEnviron())
2025-05-24T14:54:58.5487827Z # else /* __APPLE__ */
2025-05-24T14:54:58.5488009Z extern char **environ;
2025-05-24T14:54:58.5488179Z # endif /* __APPLE */
2025-05-24T14:54:58.5488374Z #endif /* !defined(HAVE_DECL_ENVIRON) */
2025-05-24T14:54:58.5488535Z 
2025-05-24T14:54:58.5488600Z #ifndef HAVE_SETENV
2025-05-24T14:54:58.5488773Z #define setenv rep_setenv
2025-05-24T14:54:58.5489038Z int rep_setenv(const char *name, const char *value, int overwrite);
2025-05-24T14:54:58.5489332Z #else
2025-05-24T14:54:58.5489484Z #ifndef HAVE_SETENV_DECL
2025-05-24T14:54:58.5489747Z int setenv(const char *name, const char *value, int overwrite);
2025-05-24T14:54:58.5490213Z #endif
2025-05-24T14:54:58.5490450Z #endif
2025-05-24T14:54:58.5490597Z 
2025-05-24T14:54:58.5490711Z #ifndef HAVE_UNSETENV
2025-05-24T14:54:58.5491020Z #define unsetenv rep_unsetenv
2025-05-24T14:54:58.5491380Z int rep_unsetenv(const char *name);
2025-05-24T14:54:58.5491950Z #endif
2025-05-24T14:54:58.5492129Z 
2025-05-24T14:54:58.5492256Z #ifndef HAVE_SETEUID
2025-05-24T14:54:58.5492595Z #define seteuid rep_seteuid
2025-05-24T14:54:58.5492934Z int rep_seteuid(uid_t);
2025-05-24T14:54:58.5493231Z #endif
2025-05-24T14:54:58.5493378Z 
2025-05-24T14:54:58.5493490Z #ifndef HAVE_SETEGID
2025-05-24T14:54:58.5493805Z #define setegid rep_setegid
2025-05-24T14:54:58.5494045Z int rep_setegid(gid_t);
2025-05-24T14:54:58.5494222Z #endif
2025-05-24T14:54:58.5494304Z 
2025-05-24T14:54:58.5494435Z #if (defined(USE_SETRESUID) && !defined(HAVE_SETRESUID_DECL))
2025-05-24T14:54:58.5494718Z /* stupid glibc */
2025-05-24T14:54:58.5494928Z int setresuid(uid_t ruid, uid_t euid, uid_t suid);
2025-05-24T14:54:58.5495184Z #endif
2025-05-24T14:54:58.5495595Z #if (defined(USE_SETRESUID) && !defined(HAVE_SETRESGID_DECL))
2025-05-24T14:54:58.5495930Z int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
2025-05-24T14:54:58.5496173Z #endif
2025-05-24T14:54:58.5496254Z 
2025-05-24T14:54:58.5496324Z #ifndef HAVE_CHOWN
2025-05-24T14:54:58.5496495Z #define chown rep_chown
2025-05-24T14:54:58.5496721Z int rep_chown(const char *path, uid_t uid, gid_t gid);
2025-05-24T14:54:58.5496977Z #endif
2025-05-24T14:54:58.5497055Z 
2025-05-24T14:54:58.5497120Z #ifndef HAVE_CHROOT
2025-05-24T14:54:58.5497299Z #define chroot rep_chroot
2025-05-24T14:54:58.5497502Z int rep_chroot(const char *dirname);
2025-05-24T14:54:58.5497715Z #endif
2025-05-24T14:54:58.5497793Z 
2025-05-24T14:54:58.5497860Z #ifndef HAVE_LINK
2025-05-24T14:54:58.5498027Z #define link rep_link
2025-05-24T14:54:58.5498252Z int rep_link(const char *oldpath, const char *newpath);
2025-05-24T14:54:58.5498502Z #endif
2025-05-24T14:54:58.5498589Z 
2025-05-24T14:54:58.5498656Z #ifndef HAVE_READLINK
2025-05-24T14:54:58.5498840Z #define readlink rep_readlink
2025-05-24T14:54:58.5499124Z ssize_t rep_readlink(const char *path, char *buf, size_t bufsize);
2025-05-24T14:54:58.5499410Z #endif
2025-05-24T14:54:58.5499489Z 
2025-05-24T14:54:58.5499554Z #ifndef HAVE_SYMLINK
2025-05-24T14:54:58.5499739Z #define symlink rep_symlink
2025-05-24T14:54:58.5499984Z int rep_symlink(const char *oldpath, const char *newpath);
2025-05-24T14:54:58.5500356Z #endif
2025-05-24T14:54:58.5500437Z 
2025-05-24T14:54:58.5500503Z #ifndef HAVE_REALPATH
2025-05-24T14:54:58.5500687Z #define realpath rep_realpath
2025-05-24T14:54:58.5500937Z char *rep_realpath(const char *path, char *resolved_path);
2025-05-24T14:54:58.5501200Z #endif
2025-05-24T14:54:58.5501282Z 
2025-05-24T14:54:58.5501351Z #ifndef HAVE_LCHOWN
2025-05-24T14:54:58.5501521Z #define lchown rep_lchown
2025-05-24T14:54:58.5501752Z int rep_lchown(const char *fname,uid_t uid,gid_t gid);
2025-05-24T14:54:58.5502000Z #endif
2025-05-24T14:54:58.5502081Z 
2025-05-24T14:54:58.5502151Z #ifdef HAVE_UNIX_H
2025-05-24T14:54:58.5502310Z #include <unix.h>
2025-05-24T14:54:58.5502472Z #endif
2025-05-24T14:54:58.5502551Z 
2025-05-24T14:54:58.5502621Z #ifndef HAVE_SETLINEBUF
2025-05-24T14:54:58.5502817Z #define setlinebuf rep_setlinebuf
2025-05-24T14:54:58.5503080Z void rep_setlinebuf(FILE *);
2025-05-24T14:54:58.5503421Z #endif
2025-05-24T14:54:58.5503568Z 
2025-05-24T14:54:58.5503697Z #ifndef HAVE_STRCASESTR
2025-05-24T14:54:58.5504040Z #define strcasestr rep_strcasestr
2025-05-24T14:54:58.5504539Z char *rep_strcasestr(const char *haystack, const char *needle);
2025-05-24T14:54:58.5505031Z #endif
2025-05-24T14:54:58.5505180Z 
2025-05-24T14:54:58.5505293Z #ifndef HAVE_STRSEP
2025-05-24T14:54:58.5505705Z #define strsep rep_strsep
2025-05-24T14:54:58.5505931Z char *rep_strsep(char **pps, const char *delim);
2025-05-24T14:54:58.5506163Z #endif
2025-05-24T14:54:58.5506249Z 
2025-05-24T14:54:58.5506315Z #ifndef HAVE_STRTOK_R
2025-05-24T14:54:58.5506611Z #define strtok_r rep_strtok_r
2025-05-24T14:54:58.5506873Z char *rep_strtok_r(char *s, const char *delim, char **save_ptr);
2025-05-24T14:54:58.5507149Z #endif
2025-05-24T14:54:58.5507230Z 
2025-05-24T14:54:58.5507234Z 
2025-05-24T14:54:58.5507237Z 
2025-05-24T14:54:58.5507304Z #ifndef HAVE_STRTOLL
2025-05-24T14:54:58.5507603Z #define strtoll rep_strtoll
2025-05-24T14:54:58.5507877Z long long int rep_strtoll(const char *str, char **endptr, int base);
2025-05-24T14:54:58.5508173Z #else
2025-05-24T14:54:58.5508320Z #ifdef HAVE_BSD_STRTOLL
2025-05-24T14:54:58.5508513Z #define strtoll rep_strtoll
2025-05-24T14:54:58.5508779Z long long int rep_strtoll(const char *str, char **endptr, int base);
2025-05-24T14:54:58.5509061Z #endif
2025-05-24T14:54:58.5509198Z #endif
2025-05-24T14:54:58.5509275Z 
2025-05-24T14:54:58.5509341Z #ifndef HAVE_STRTOULL
2025-05-24T14:54:58.5509524Z #define strtoull rep_strtoull
2025-05-24T14:54:58.5509830Z unsigned long long int rep_strtoull(const char *str, char **endptr, int base);
2025-05-24T14:54:58.5510155Z #else
2025-05-24T14:54:58.5510360Z #ifdef HAVE_BSD_STRTOLL /* yes, it's not HAVE_BSD_STRTOULL */
2025-05-24T14:54:58.5510649Z #define strtoull rep_strtoull
2025-05-24T14:54:58.5510954Z unsigned long long int rep_strtoull(const char *str, char **endptr, int base);
2025-05-24T14:54:58.5511269Z #endif
2025-05-24T14:54:58.5511404Z #endif
2025-05-24T14:54:58.5511482Z 
2025-05-24T14:54:58.5511550Z #ifndef HAVE_FTRUNCATE
2025-05-24T14:54:58.5511746Z #define ftruncate rep_ftruncate
2025-05-24T14:54:58.5511954Z int rep_ftruncate(int,off_t);
2025-05-24T14:54:58.5512145Z #endif
2025-05-24T14:54:58.5512227Z 
2025-05-24T14:54:58.5512297Z #ifndef HAVE_INITGROUPS
2025-05-24T14:54:58.5512495Z #define initgroups rep_initgroups
2025-05-24T14:54:58.5512735Z int rep_initgroups(char *name, gid_t id);
2025-05-24T14:54:58.5512951Z #endif
2025-05-24T14:54:58.5513043Z 
2025-05-24T14:54:58.5513217Z #if !defined(HAVE_BZERO) && defined(HAVE_MEMSET)
2025-05-24T14:54:58.5513654Z #define bzero(a,b) memset((a),'\0',(b))
2025-05-24T14:54:58.5514015Z #endif
2025-05-24T14:54:58.5514145Z 
2025-05-24T14:54:58.5514254Z #ifndef HAVE_DLERROR
2025-05-24T14:54:58.5514577Z #define dlerror rep_dlerror
2025-05-24T14:54:58.5514937Z char *rep_dlerror(void);
2025-05-24T14:54:58.5515253Z #endif
2025-05-24T14:54:58.5515540Z 
2025-05-24T14:54:58.5515673Z #ifndef HAVE_DLOPEN
2025-05-24T14:54:58.5515978Z #define dlopen rep_dlopen
2025-05-24T14:54:58.5516471Z #ifdef DLOPEN_TAKES_UNSIGNED_FLAGS
2025-05-24T14:54:58.5516939Z void *rep_dlopen(const char *name, unsigned int flags);
2025-05-24T14:54:58.5517373Z #else
2025-05-24T14:54:58.5517660Z void *rep_dlopen(const char *name, int flags);
2025-05-24T14:54:58.5517947Z #endif
2025-05-24T14:54:58.5518080Z #endif
2025-05-24T14:54:58.5518164Z 
2025-05-24T14:54:58.5518232Z #ifndef HAVE_DLSYM
2025-05-24T14:54:58.5518402Z #define dlsym rep_dlsym
2025-05-24T14:54:58.5518617Z void *rep_dlsym(void *handle, const char *symbol);
2025-05-24T14:54:58.5518857Z #endif
2025-05-24T14:54:58.5518939Z 
2025-05-24T14:54:58.5519005Z #ifndef HAVE_DLCLOSE
2025-05-24T14:54:58.5519188Z #define dlclose rep_dlclose
2025-05-24T14:54:58.5519386Z int rep_dlclose(void *handle);
2025-05-24T14:54:58.5519577Z #endif
2025-05-24T14:54:58.5519655Z 
2025-05-24T14:54:58.5519725Z #ifndef HAVE_SOCKETPAIR
2025-05-24T14:54:58.5519923Z #define socketpair rep_socketpair
2025-05-24T14:54:58.5520149Z /* prototype is in system/network.h */
2025-05-24T14:54:58.5520374Z #endif
2025-05-24T14:54:58.5520452Z 
2025-05-24T14:54:58.5520633Z /* for old gcc releases that don't have the feature test macro __has_attribute */
2025-05-24T14:54:58.5520967Z #ifndef __has_attribute
2025-05-24T14:54:58.5521158Z #define __has_attribute(x) 0
2025-05-24T14:54:58.5521343Z #endif
2025-05-24T14:54:58.5521423Z 
2025-05-24T14:54:58.5521499Z #ifndef PRINTF_ATTRIBUTE
2025-05-24T14:54:58.5521705Z #if __has_attribute(format) || (__GNUC__ >= 3)
2025-05-24T14:54:58.5522025Z /** Use gcc attribute to check printf fns.  a1 is the 1-based index of
2025-05-24T14:54:58.5522509Z  * the parameter containing the format, and a2 the index of the first
2025-05-24T14:54:58.5522885Z  * argument. Note that some gcc 2.x versions don't handle this
2025-05-24T14:54:58.5523165Z  * properly **/
2025-05-24T14:54:58.5523436Z #define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))
2025-05-24T14:54:58.5523863Z #else
2025-05-24T14:54:58.5524112Z #define PRINTF_ATTRIBUTE(a1, a2)
2025-05-24T14:54:58.5524461Z #endif
2025-05-24T14:54:58.5524678Z #endif
2025-05-24T14:54:58.5524813Z 
2025-05-24T14:54:58.5524922Z #ifndef _DEPRECATED_
2025-05-24T14:54:58.5525259Z #if __has_attribute(deprecated) || (__GNUC__ >= 3)
2025-05-24T14:54:58.5525803Z #define _DEPRECATED_ __attribute__ ((deprecated))
2025-05-24T14:54:58.5526168Z #else
2025-05-24T14:54:58.5526414Z #define _DEPRECATED_
2025-05-24T14:54:58.5526583Z #endif
2025-05-24T14:54:58.5526715Z #endif
2025-05-24T14:54:58.5526794Z 
2025-05-24T14:54:58.5526926Z #if !defined(HAVE_VDPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5527215Z #define vdprintf rep_vdprintf
2025-05-24T14:54:58.5527723Z int rep_vdprintf(int fd, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);
2025-05-24T14:54:58.5528293Z #endif
2025-05-24T14:54:58.5528450Z 
2025-05-24T14:54:58.5528660Z #if !defined(HAVE_DPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5529143Z #define dprintf rep_dprintf
2025-05-24T14:54:58.5529436Z int rep_dprintf(int fd, const char *format, ...) PRINTF_ATTRIBUTE(2,3);
2025-05-24T14:54:58.5529731Z #endif
2025-05-24T14:54:58.5529812Z 
2025-05-24T14:54:58.5529934Z #if !defined(HAVE_VASPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5530218Z #define vasprintf rep_vasprintf
2025-05-24T14:54:58.5530540Z int rep_vasprintf(char **ptr, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);
2025-05-24T14:54:58.5530873Z #endif
2025-05-24T14:54:58.5530953Z 
2025-05-24T14:54:58.5531072Z #if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5531350Z #define snprintf rep_snprintf
2025-05-24T14:54:58.5531646Z int rep_snprintf(char *,size_t ,const char *, ...) PRINTF_ATTRIBUTE(3,4);
2025-05-24T14:54:58.5531942Z #endif
2025-05-24T14:54:58.5532022Z 
2025-05-24T14:54:58.5532147Z #if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5532422Z #define vsnprintf rep_vsnprintf
2025-05-24T14:54:58.5532742Z int rep_vsnprintf(char *,size_t ,const char *, va_list ap) PRINTF_ATTRIBUTE(3,0);
2025-05-24T14:54:58.5533055Z #endif
2025-05-24T14:54:58.5533248Z 
2025-05-24T14:54:58.5533368Z #if !defined(HAVE_ASPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5533644Z #define asprintf rep_asprintf
2025-05-24T14:54:58.5533913Z int rep_asprintf(char **,const char *, ...) PRINTF_ATTRIBUTE(2,3);
2025-05-24T14:54:58.5534195Z #endif
2025-05-24T14:54:58.5534275Z 
2025-05-24T14:54:58.5534350Z #if !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5534564Z #ifdef REPLACE_BROKEN_PRINTF
2025-05-24T14:54:58.5534747Z /*
2025-05-24T14:54:58.5534910Z  * We do not redefine printf by default
2025-05-24T14:54:58.5535155Z  * as it breaks the build if system headers
2025-05-24T14:54:58.5535703Z  * use __attribute__((format(printf, 3, 0)))
2025-05-24T14:54:58.5536180Z  * instead of __attribute__((format(__printf__, 3, 0)))
2025-05-24T14:54:58.5536599Z  */
2025-05-24T14:54:58.5536851Z #define printf rep_printf
2025-05-24T14:54:58.5537066Z #endif
2025-05-24T14:54:58.5537268Z int rep_printf(const char *, ...) PRINTF_ATTRIBUTE(1,2);
2025-05-24T14:54:58.5537717Z #endif
2025-05-24T14:54:58.5537855Z 
2025-05-24T14:54:58.5537945Z #if !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5538158Z #define fprintf rep_fprintf
2025-05-24T14:54:58.5538439Z int rep_fprintf(FILE *stream, const char *, ...) PRINTF_ATTRIBUTE(2,3);
2025-05-24T14:54:58.5538781Z #endif
2025-05-24T14:54:58.5538932Z 
2025-05-24T14:54:58.5539044Z #ifndef HAVE_VSYSLOG
2025-05-24T14:54:58.5539338Z #ifdef HAVE_SYSLOG
2025-05-24T14:54:58.5539634Z #define vsyslog rep_vsyslog
2025-05-24T14:54:58.5540298Z void rep_vsyslog (int facility_priority, const char *format, va_list arglist) PRINTF_ATTRIBUTE(2,0);
2025-05-24T14:54:58.5541148Z #endif
2025-05-24T14:54:58.5541379Z #endif
2025-05-24T14:54:58.5541522Z 
2025-05-24T14:54:58.5541752Z /* we used to use these fns, but now we have good replacements
2025-05-24T14:54:58.5542268Z    for snprintf and vsnprintf */
2025-05-24T14:54:58.5542957Z #define slprintf snprintf
2025-05-24T14:54:58.5543200Z 
2025-05-24T14:54:58.5543206Z 
2025-05-24T14:54:58.5543326Z #ifndef HAVE_VA_COPY
2025-05-24T14:54:58.5543639Z #undef va_copy
2025-05-24T14:54:58.5543923Z #ifdef HAVE___VA_COPY
2025-05-24T14:54:58.5544298Z #define va_copy(dest, src) __va_copy(dest, src)
2025-05-24T14:54:58.5544713Z #else
2025-05-24T14:54:58.5545007Z #define va_copy(dest, src) (dest) = (src)
2025-05-24T14:54:58.5545575Z #endif
2025-05-24T14:54:58.5545830Z #endif
2025-05-24T14:54:58.5545975Z 
2025-05-24T14:54:58.5546095Z #ifndef HAVE_VOLATILE
2025-05-24T14:54:58.5546407Z #define volatile
2025-05-24T14:54:58.5546675Z #endif
2025-05-24T14:54:58.5546825Z 
2025-05-24T14:54:58.5546962Z #ifndef HAVE_COMPARISON_FN_T
2025-05-24T14:54:58.5547425Z typedef int (*comparison_fn_t)(const void *, const void *);
2025-05-24T14:54:58.5547902Z #endif
2025-05-24T14:54:58.5548043Z 
2025-05-24T14:54:58.5548181Z #ifndef HAVE_WORKING_STRPTIME
2025-05-24T14:54:58.5548553Z #define strptime rep_strptime
2025-05-24T14:54:58.5549341Z + echo '=== End of replace.h ==='
2025-05-24T14:54:58.5549774Z + echo '=== Original .c files in lib/replace ==='
2025-05-24T14:54:58.5550224Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5550629Z + echo 'Content of lib/replace/closefrom.c:'
2025-05-24T14:54:58.5551043Z + cat lib/replace/closefrom.c
2025-05-24T14:54:58.5551398Z + echo -------------------
2025-05-24T14:54:58.5551725Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5552088Z + echo 'Content of lib/replace/dlfcn.c:'
2025-05-24T14:54:58.5552476Z + cat lib/replace/dlfcn.c
2025-05-24T14:54:58.5552796Z + echo -------------------
2025-05-24T14:54:58.5553115Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5553506Z + echo 'Content of lib/replace/getaddrinfo.c:'
2025-05-24T14:54:58.5553937Z + cat lib/replace/getaddrinfo.c
2025-05-24T14:54:58.5554276Z + echo -------------------
2025-05-24T14:54:58.5554606Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5554962Z + echo 'Content of lib/replace/getifaddrs.c:'
2025-05-24T14:54:58.5555218Z + cat lib/replace/getifaddrs.c
2025-05-24T14:54:58.5555633Z + echo -------------------
2025-05-24T14:54:58.5555958Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5556175Z + echo 'Content of lib/replace/inet_aton.c:'
2025-05-24T14:54:58.5556414Z + cat lib/replace/inet_aton.c
2025-05-24T14:54:58.5556610Z + echo -------------------
2025-05-24T14:54:58.5556800Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5569485Z + echo 'Content of lib/replace/inet_ntoa.c:'
2025-05-24T14:54:58.5569952Z + cat lib/replace/inet_ntoa.c
2025-05-24T14:54:58.5570322Z + echo -------------------
2025-05-24T14:54:58.5570670Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5571049Z + echo 'Content of lib/replace/inet_ntop.c:'
2025-05-24T14:54:58.5571479Z + cat lib/replace/inet_ntop.c
2025-05-24T14:54:58.5571820Z + echo -------------------
2025-05-24T14:54:58.5572155Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5572523Z + echo 'Content of lib/replace/inet_pton.c:'
2025-05-24T14:54:58.5572945Z + cat lib/replace/inet_pton.c
2025-05-24T14:54:58.5573282Z + echo -------------------
2025-05-24T14:54:58.5573595Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5573963Z + echo 'Content of lib/replace/poll.c:'
2025-05-24T14:54:58.5574351Z + cat lib/replace/poll.c
2025-05-24T14:54:58.5574672Z + echo -------------------
2025-05-24T14:54:58.5574987Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5575522Z + echo 'Content of lib/replace/replace.c:'
2025-05-24T14:54:58.5575942Z + cat lib/replace/replace.c
2025-05-24T14:54:58.5576274Z struct tm;
2025-05-24T14:54:58.5576692Z char *rep_strptime(const char *buf, const char *format, struct tm *tm);
2025-05-24T14:54:58.5577218Z #endif
2025-05-24T14:54:58.5577496Z 
2025-05-24T14:54:58.5577615Z #ifndef HAVE_DUP2
2025-05-24T14:54:58.5577897Z #define dup2 rep_dup2
2025-05-24T14:54:58.5578222Z int rep_dup2(int oldfd, int newfd);
2025-05-24T14:54:58.5578567Z #endif
2025-05-24T14:54:58.5578712Z 
2025-05-24T14:54:58.5578881Z /* Load header file for dynamic linking stuff */
2025-05-24T14:54:58.5579304Z #ifdef HAVE_DLFCN_H
2025-05-24T14:54:58.5579492Z #include <dlfcn.h>
2025-05-24T14:54:58.5579653Z #endif
2025-05-24T14:54:58.5579746Z 
2025-05-24T14:54:58.5579809Z #ifndef RTLD_LAZY
2025-05-24T14:54:58.5579981Z #define RTLD_LAZY 0
2025-05-24T14:54:58.5580136Z #endif
2025-05-24T14:54:58.5580286Z #ifndef RTLD_NOW
2025-05-24T14:54:58.5580453Z #define RTLD_NOW 0
2025-05-24T14:54:58.5580612Z #endif
2025-05-24T14:54:58.5580752Z #ifndef RTLD_GLOBAL
2025-05-24T14:54:58.5580922Z #define RTLD_GLOBAL 0
2025-05-24T14:54:58.5581089Z #endif
2025-05-24T14:54:58.5581174Z 
2025-05-24T14:54:58.5581253Z #ifndef HAVE_SECURE_MKSTEMP
2025-05-24T14:54:58.5581471Z #define mkstemp(path) rep_mkstemp(path)
2025-05-24T14:54:58.5581719Z int rep_mkstemp(char *temp);
2025-05-24T14:54:58.5581907Z #endif
2025-05-24T14:54:58.5581992Z 
2025-05-24T14:54:58.5582058Z #ifndef HAVE_MKDTEMP
2025-05-24T14:54:58.5582247Z #define mkdtemp rep_mkdtemp
2025-05-24T14:54:58.5582454Z char *rep_mkdtemp(char *template);
2025-05-24T14:54:58.5582661Z #endif
2025-05-24T14:54:58.5582747Z 
2025-05-24T14:54:58.5582814Z #ifndef HAVE_PREAD
2025-05-24T14:54:58.5582988Z #define pread rep_pread
2025-05-24T14:54:58.5583262Z ssize_t rep_pread(int __fd, void *__buf, size_t __nbytes, off_t __offset);
2025-05-24T14:54:58.5583594Z #define LIBREPLACE_PREAD_REPLACED 1
2025-05-24T14:54:58.5583801Z #else
2025-05-24T14:54:58.5583970Z #define LIBREPLACE_PREAD_NOT_REPLACED 1
2025-05-24T14:54:58.5584239Z #endif
2025-05-24T14:54:58.5584384Z 
2025-05-24T14:54:58.5584496Z #ifndef HAVE_PWRITE
2025-05-24T14:54:58.5584797Z #define pwrite rep_pwrite
2025-05-24T14:54:58.5585305Z ssize_t rep_pwrite(int __fd, const void *__buf, size_t __nbytes, off_t __offset);
2025-05-24T14:54:58.5585854Z #define LIBREPLACE_PWRITE_REPLACED 1
2025-05-24T14:54:58.5586205Z #else
2025-05-24T14:54:58.5586487Z #define LIBREPLACE_PWRITE_NOT_REPLACED 1
2025-05-24T14:54:58.5586856Z #endif
2025-05-24T14:54:58.5586997Z 
2025-05-24T14:54:58.5587201Z #if !defined(HAVE_INET_NTOA) || defined(REPLACE_INET_NTOA)
2025-05-24T14:54:58.5587688Z #define inet_ntoa rep_inet_ntoa
2025-05-24T14:54:58.5588059Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5588548Z #endif
2025-05-24T14:54:58.5588681Z 
2025-05-24T14:54:58.5588794Z #ifndef HAVE_INET_PTON
2025-05-24T14:54:58.5589109Z #define inet_pton rep_inet_pton
2025-05-24T14:54:58.5589478Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5589731Z #endif
2025-05-24T14:54:58.5589812Z 
2025-05-24T14:54:58.5589880Z #ifndef HAVE_INET_NTOP
2025-05-24T14:54:58.5590063Z #define inet_ntop rep_inet_ntop
2025-05-24T14:54:58.5590268Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5590479Z #endif
2025-05-24T14:54:58.5590558Z 
2025-05-24T14:54:58.5590633Z #ifndef HAVE_INET_ATON
2025-05-24T14:54:58.5590813Z #define inet_aton rep_inet_aton
2025-05-24T14:54:58.5591023Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5591232Z #endif
2025-05-24T14:54:58.5591316Z 
2025-05-24T14:54:58.5591380Z #ifndef HAVE_CONNECT
2025-05-24T14:54:58.5591561Z #define connect rep_connect
2025-05-24T14:54:58.5591765Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5591967Z #endif
2025-05-24T14:54:58.5592053Z 
2025-05-24T14:54:58.5592130Z #ifndef HAVE_GETHOSTBYNAME
2025-05-24T14:54:58.5592339Z #define gethostbyname rep_gethostbyname
2025-05-24T14:54:58.5592581Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5592790Z #endif
2025-05-24T14:54:58.5592877Z 
2025-05-24T14:54:58.5592946Z #ifndef HAVE_GETIFADDRS
2025-05-24T14:54:58.5593142Z #define getifaddrs rep_getifaddrs
2025-05-24T14:54:58.5593363Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5593581Z #endif
2025-05-24T14:54:58.5593661Z 
2025-05-24T14:54:58.5593812Z #ifndef HAVE_FREEIFADDRS
2025-05-24T14:54:58.5594015Z #define freeifaddrs rep_freeifaddrs
2025-05-24T14:54:58.5594244Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5594458Z #endif
2025-05-24T14:54:58.5594540Z 
2025-05-24T14:54:58.5594616Z #ifndef HAVE_GET_CURRENT_DIR_NAME
2025-05-24T14:54:58.5595139Z #define get_current_dir_name rep_get_current_dir_name
2025-05-24T14:54:58.5595784Z char *rep_get_current_dir_name(void);
2025-05-24T14:54:58.5596156Z #endif
2025-05-24T14:54:58.5596293Z 
2025-05-24T14:54:58.5596543Z #if (!defined(HAVE_STRERROR_R) || !defined(STRERROR_R_XSI_NOT_GNU))
2025-05-24T14:54:58.5597061Z #define strerror_r rep_strerror_r
2025-05-24T14:54:58.5597515Z int rep_strerror_r(int errnum, char *buf, size_t buflen);
2025-05-24T14:54:58.5597958Z #endif
2025-05-24T14:54:58.5598102Z 
2025-05-24T14:54:58.5598227Z #if !defined(HAVE_CLOCK_GETTIME)
2025-05-24T14:54:58.5598595Z #define clock_gettime rep_clock_gettime
2025-05-24T14:54:58.5598962Z #endif
2025-05-24T14:54:58.5599094Z 
2025-05-24T14:54:58.5599213Z #ifdef HAVE_LIMITS_H
2025-05-24T14:54:58.5599498Z #include <limits.h>
2025-05-24T14:54:58.5599764Z #endif
2025-05-24T14:54:58.5599896Z 
2025-05-24T14:54:58.5600009Z #ifdef HAVE_SYS_PARAM_H
2025-05-24T14:54:58.5600323Z #include <sys/param.h>
2025-05-24T14:54:58.5600512Z #endif
2025-05-24T14:54:58.5600596Z 
2025-05-24T14:54:58.5600720Z /* The extra casts work around common compiler bugs.  */
2025-05-24T14:54:58.5601007Z #define _TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
2025-05-24T14:54:58.5601318Z /* The outer cast is needed to work around a bug in Cray C 5.0.3.0.
2025-05-24T14:54:58.5601648Z    It is necessary at least when t == time_t.  */
2025-05-24T14:54:58.5601924Z #define _TYPE_MINIMUM(t) ((t) (_TYPE_SIGNED (t) \
2025-05-24T14:54:58.5602206Z   			      ? ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1) : (t) 0))
2025-05-24T14:54:58.5602508Z #define _TYPE_MAXIMUM(t) ((t) (~ (t) 0 - _TYPE_MINIMUM (t)))
2025-05-24T14:54:58.5602719Z 
2025-05-24T14:54:58.5602785Z #ifndef UINT16_MAX
2025-05-24T14:54:58.5602958Z #define UINT16_MAX 65535
2025-05-24T14:54:58.5603136Z #endif
2025-05-24T14:54:58.5603217Z 
2025-05-24T14:54:58.5603283Z #ifndef UINT32_MAX
2025-05-24T14:54:58.5603459Z #define UINT32_MAX (4294967295U)
2025-05-24T14:54:58.5603656Z #endif
2025-05-24T14:54:58.5603734Z 
2025-05-24T14:54:58.5603798Z #ifndef UINT64_MAX
2025-05-24T14:54:58.5603978Z #define UINT64_MAX ((uint64_t)-1)
2025-05-24T14:54:58.5604173Z #endif
2025-05-24T14:54:58.5604343Z 
2025-05-24T14:54:58.5604411Z #ifndef INT64_MAX
2025-05-24T14:54:58.5604580Z #define INT64_MAX 9223372036854775807LL
2025-05-24T14:54:58.5604786Z #endif
2025-05-24T14:54:58.5604864Z 
2025-05-24T14:54:58.5604929Z #ifndef CHAR_BIT
2025-05-24T14:54:58.5605095Z #define CHAR_BIT 8
2025-05-24T14:54:58.5605246Z #endif
2025-05-24T14:54:58.5605329Z 
2025-05-24T14:54:58.5605606Z #ifndef INT32_MAX
2025-05-24T14:54:58.5605878Z #define INT32_MAX _TYPE_MAXIMUM(int32_t)
2025-05-24T14:54:58.5606148Z #endif
2025-05-24T14:54:58.5606289Z 
2025-05-24T14:54:58.5606406Z #ifdef HAVE_STDBOOL_H
2025-05-24T14:54:58.5606701Z #include <stdbool.h>
2025-05-24T14:54:58.5606970Z #endif
2025-05-24T14:54:58.5607101Z 
2025-05-24T14:54:58.5607212Z #ifndef HAVE_BOOL
2025-05-24T14:54:58.5607408Z #error Need a real boolean type
2025-05-24T14:54:58.5607599Z #endif
2025-05-24T14:54:58.5607747Z 
2025-05-24T14:54:58.5607886Z #if !defined(HAVE_INTPTR_T)
2025-05-24T14:54:58.5608232Z typedef long long intptr_t ;
2025-05-24T14:54:58.5608572Z #define __intptr_t_defined
2025-05-24T14:54:58.5608881Z #endif
2025-05-24T14:54:58.5609015Z 
2025-05-24T14:54:58.5609136Z #if !defined(HAVE_UINTPTR_T)
2025-05-24T14:54:58.5609496Z typedef unsigned long long uintptr_t ;
2025-05-24T14:54:58.5609881Z #define __uintptr_t_defined
2025-05-24T14:54:58.5610188Z #endif
2025-05-24T14:54:58.5610321Z 
2025-05-24T14:54:58.5610442Z #if !defined(HAVE_PTRDIFF_T)
2025-05-24T14:54:58.5610805Z typedef unsigned long long ptrdiff_t ;
2025-05-24T14:54:58.5611147Z #endif
2025-05-24T14:54:58.5611233Z 
2025-05-24T14:54:58.5611292Z /*
2025-05-24T14:54:58.5611615Z  * to prevent <rpcsvc/yp_prot.h> from doing a redefine of 'bool'
2025-05-24T14:54:58.5611885Z  *
2025-05-24T14:54:58.5612064Z  * IRIX, HPUX, MacOS 10 and Solaris need BOOL_DEFINED
2025-05-24T14:54:58.5612318Z  * Tru64 needs _BOOL_EXISTS
2025-05-24T14:54:58.5612519Z  * AIX needs _BOOL,_TRUE,_FALSE
2025-05-24T14:54:58.5612815Z  */
2025-05-24T14:54:58.5612963Z #ifndef BOOL_DEFINED
2025-05-24T14:54:58.5613132Z #define BOOL_DEFINED
2025-05-24T14:54:58.5613299Z #endif
2025-05-24T14:54:58.5613439Z #ifndef _BOOL_EXISTS
2025-05-24T14:54:58.5613605Z #define _BOOL_EXISTS
2025-05-24T14:54:58.5613762Z #endif
2025-05-24T14:54:58.5613897Z #ifndef _BOOL
2025-05-24T14:54:58.5614051Z #define _BOOL
2025-05-24T14:54:58.5614195Z #endif
2025-05-24T14:54:58.5614273Z 
2025-05-24T14:54:58.5614359Z #ifndef __bool_true_false_are_defined
2025-05-24T14:54:58.5614590Z #define __bool_true_false_are_defined
2025-05-24T14:54:58.5614797Z #endif
2025-05-24T14:54:58.5614875Z 
2025-05-24T14:54:58.5614934Z #ifndef true
2025-05-24T14:54:58.5615089Z #define true (1)
2025-05-24T14:54:58.5615240Z #endif
2025-05-24T14:54:58.5615591Z #ifndef false
2025-05-24T14:54:58.5615812Z #define false (0)
2025-05-24T14:54:58.5615968Z #endif
2025-05-24T14:54:58.5616049Z 
2025-05-24T14:54:58.5616110Z #ifndef _TRUE
2025-05-24T14:54:58.5616260Z #define _TRUE true
2025-05-24T14:54:58.5616423Z #endif
2025-05-24T14:54:58.5616562Z #ifndef _FALSE
2025-05-24T14:54:58.5616838Z #define _FALSE false
2025-05-24T14:54:58.5617119Z #endif
2025-05-24T14:54:58.5617260Z 
2025-05-24T14:54:58.5617384Z #ifndef HAVE_FUNCTION_MACRO
2025-05-24T14:54:58.5617704Z #ifdef HAVE_func_MACRO
2025-05-24T14:54:58.5618019Z #define __FUNCTION__ __func__
2025-05-24T14:54:58.5618341Z #else
2025-05-24T14:54:58.5618581Z #define __FUNCTION__ ("")
2025-05-24T14:54:58.5618880Z #endif
2025-05-24T14:54:58.5619100Z #endif
2025-05-24T14:54:58.5619232Z 
2025-05-24T14:54:58.5619237Z 
2025-05-24T14:54:58.5619338Z #ifndef MIN
2025-05-24T14:54:58.5619601Z #define MIN(a,b) ((a)<(b)?(a):(b))
2025-05-24T14:54:58.5619939Z #endif
2025-05-24T14:54:58.5620070Z 
2025-05-24T14:54:58.5620168Z #ifndef MAX
2025-05-24T14:54:58.5620431Z #define MAX(a,b) ((a)>(b)?(a):(b))
2025-05-24T14:54:58.5620758Z #endif
2025-05-24T14:54:58.5620897Z 
2025-05-24T14:54:58.5621016Z #if !defined(HAVE_VOLATILE)
2025-05-24T14:54:58.5621335Z #define volatile
2025-05-24T14:54:58.5621594Z #endif
2025-05-24T14:54:58.5621728Z 
2025-05-24T14:54:58.5621827Z /**
2025-05-24T14:54:58.5622202Z   this is a warning hack. The idea is to use this everywhere that we
2025-05-24T14:54:58.5622963Z   get the "discarding const" warning from gcc. That doesn't actually
2025-05-24T14:54:58.5623582Z   fix the problem of course, but it means that when we do get to
2025-05-24T14:54:58.5624171Z   cleaning them up we can do it by searching the code for
2025-05-24T14:54:58.5624452Z   discard_const.
2025-05-24T14:54:58.5624558Z 
2025-05-24T14:54:58.5624704Z   It also means that other error types aren't as swamped by the noise
2025-05-24T14:54:58.5625096Z   of hundreds of const warnings, so we are more likely to notice when
2025-05-24T14:54:58.5625592Z   we get new errors.
2025-05-24T14:54:58.5625707Z 
2025-05-24T14:54:58.5625837Z   Please only add more uses of this macro when you find it
2025-05-24T14:54:58.5626178Z   _really_ hard to fix const warnings. Our aim is to eventually use
2025-05-24T14:54:58.5626502Z   this function in only a very few places.
2025-05-24T14:54:58.5626670Z 
2025-05-24T14:54:58.5626838Z   Also, please call this via the discard_const_p() macro interface, as that
2025-05-24T14:54:58.5627161Z   makes the return type safe.
2025-05-24T14:54:58.5627349Z */
2025-05-24T14:54:58.5627538Z #define discard_const(ptr) ((void *)((uintptr_t)(ptr)))
2025-05-24T14:54:58.5627738Z 
2025-05-24T14:54:58.5627828Z /** Type-safe version of discard_const */
2025-05-24T14:54:58.5628136Z #define discard_const_p(type, ptr) ((type *)discard_const(ptr))
2025-05-24T14:54:58.5628363Z 
2025-05-24T14:54:58.5628427Z #ifndef __STRING
2025-05-24T14:54:58.5628592Z #define __STRING(x)    #x
2025-05-24T14:54:58.5628861Z #endif
2025-05-24T14:54:58.5628943Z 
2025-05-24T14:54:58.5629016Z #ifndef __STRINGSTRING
2025-05-24T14:54:58.5629211Z #define __STRINGSTRING(x) __STRING(x)
2025-05-24T14:54:58.5629420Z #endif
2025-05-24T14:54:58.5629500Z 
2025-05-24T14:54:58.5629563Z #ifndef __LINESTR__
2025-05-24T14:54:58.5629888Z #define __LINESTR__ __STRINGSTRING(__LINE__)
2025-05-24T14:54:58.5630116Z #endif
2025-05-24T14:54:58.5630203Z 
2025-05-24T14:54:58.5630271Z #ifndef __location__
2025-05-24T14:54:58.5630463Z #define __location__ __FILE__ ":" __LINESTR__
2025-05-24T14:54:58.5630685Z #endif
2025-05-24T14:54:58.5630765Z 
2025-05-24T14:54:58.5630825Z /**
2025-05-24T14:54:58.5630964Z  * Zero a structure.
2025-05-24T14:54:58.5631128Z  */
2025-05-24T14:54:58.5631355Z #define ZERO_STRUCT(x) memset_s((char *)&(x), sizeof(x), 0, sizeof(x))
2025-05-24T14:54:58.5631594Z 
2025-05-24T14:54:58.5631648Z /**
2025-05-24T14:54:58.5631827Z  * Zero a structure given a pointer to the structure.
2025-05-24T14:54:58.5632069Z  */
2025-05-24T14:54:58.5632224Z #define ZERO_STRUCTP(x) do { \
2025-05-24T14:54:58.5632420Z 	if ((x) != NULL) { \
2025-05-24T14:54:58.5632637Z 		memset_s((char *)(x), sizeof(*(x)), 0, sizeof(*(x))); \
2025-05-24T14:54:58.5632880Z 	} \
2025-05-24T14:54:58.5633019Z } while(0)
2025-05-24T14:54:58.5633103Z 
2025-05-24T14:54:58.5633159Z /**
2025-05-24T14:54:58.5633391Z  * Zero a structure given a pointer to the structure - no zero check
2025-05-24T14:54:58.5633874Z  */
2025-05-24T14:54:58.5634288Z #define ZERO_STRUCTPN(x) memset_s((char *)(x), sizeof(*(x)), 0, sizeof(*(x)))
2025-05-24T14:54:58.5634732Z 
2025-05-24T14:54:58.5634827Z /**
2025-05-24T14:54:58.5635214Z  * Zero an array - note that sizeof(array) must work - ie. it must not be a
2025-05-24T14:54:58.5635874Z  * pointer
2025-05-24T14:54:58.5636106Z  */
2025-05-24T14:54:58.5636476Z #define ZERO_ARRAY(x) memset_s((char *)(x), sizeof(x), 0, sizeof(x))
2025-05-24T14:54:58.5636873Z 
2025-05-24T14:54:58.5636964Z /**
2025-05-24T14:54:58.5637215Z  * Zero a given len of an array
2025-05-24T14:54:58.5637461Z  */
2025-05-24T14:54:58.5637661Z #define ZERO_ARRAY_LEN(x, l) memset_s((char *)(x), (l), 0, (l))
2025-05-24T14:54:58.5637868Z 
2025-05-24T14:54:58.5637928Z /**
2025-05-24T14:54:58.5638172Z  * Explicitly zero data from memory. This is guaranteed to be not optimized
2025-05-24T14:54:58.5638487Z  * away.
2025-05-24T14:54:58.5638621Z  */
2025-05-24T14:54:58.5638829Z #define BURN_DATA(x) memset_s((char *)&(x), sizeof(x), 0, sizeof(x))
2025-05-24T14:54:58.5639140Z 
2025-05-24T14:54:58.5639197Z /**
2025-05-24T14:54:58.5639433Z  * Explicitly zero data from memory. This is guaranteed to be not optimized
2025-05-24T14:54:58.5639734Z  * away.
2025-05-24T14:54:58.5639862Z  */
2025-05-24T14:54:58.5640063Z #define BURN_DATA_SIZE(x, s) memset_s((char *)&(x), (s), 0, (s))
2025-05-24T14:54:58.5640272Z 
2025-05-24T14:54:58.5640327Z /**
2025-05-24T14:54:58.5640562Z  * Explicitly zero data from memory. This is guaranteed to be not optimized
2025-05-24T14:54:58.5640858Z  * away.
2025-05-24T14:54:58.5640996Z  */
2025-05-24T14:54:58.5641176Z #define BURN_PTR_SIZE(x, s) memset_s((x), (s), 0, (s))
2025-05-24T14:54:58.5641377Z 
2025-05-24T14:54:58.5641432Z /**
2025-05-24T14:54:58.5641665Z  * Explicitly zero data in string. This is guaranteed to be not optimized
2025-05-24T14:54:58.5641967Z  * away.
2025-05-24T14:54:58.5642110Z  */
2025-05-24T14:54:58.5642254Z #define BURN_STR(x)	do { \
2025-05-24T14:54:58.5642445Z 				if ((x) != NULL) { \
2025-05-24T14:54:58.5642632Z 					size_t s = strlen(x); \
2025-05-24T14:54:58.5642832Z 					memset_s((x), s, 0, s); \
2025-05-24T14:54:58.5643012Z 				} \
2025-05-24T14:54:58.5643153Z 			} while(0)
2025-05-24T14:54:58.5643246Z 
2025-05-24T14:54:58.5643301Z /**
2025-05-24T14:54:58.5643497Z  * Work out how many elements there are in a static array.
2025-05-24T14:54:58.5643747Z  */
2025-05-24T14:54:58.5643893Z #ifdef ARRAY_SIZE
2025-05-24T14:54:58.5644057Z #undef ARRAY_SIZE
2025-05-24T14:54:58.5644208Z #endif
2025-05-24T14:54:58.5644390Z #define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
2025-05-24T14:54:58.5644637Z 
2025-05-24T14:54:58.5644695Z /**
2025-05-24T14:54:58.5644879Z  * Remove an array element by moving the rest one down
2025-05-24T14:54:58.5645118Z  */
2025-05-24T14:54:58.5645271Z #define ARRAY_DEL_ELEMENT(a,i,n) \
2025-05-24T14:54:58.5645888Z if((i)<((n)-1)){memmove(&((a)[(i)]),&((a)[(i)+1]),(sizeof(*(a))*((n)-(i)-1)));}
2025-05-24T14:54:58.5646118Z 
2025-05-24T14:54:58.5646175Z /**
2025-05-24T14:54:58.5646355Z  * Insert an array element by moving the rest one up
2025-05-24T14:54:58.5646600Z  *
2025-05-24T14:54:58.5646734Z  */
2025-05-24T14:54:58.5646987Z #define ARRAY_INSERT_ELEMENT(__array,__old_last_idx,__new_elem,__new_idx) do { \
2025-05-24T14:54:58.5647340Z 	if ((__new_idx) < (__old_last_idx)) { \
2025-05-24T14:54:58.5647602Z 		const void *__src = &((__array)[(__new_idx)]); \
2025-05-24T14:54:58.5647910Z 		void *__dst = &((__array)[(__new_idx)+1]); \
2025-05-24T14:54:58.5648355Z 		size_t __num = (__old_last_idx)-(__new_idx); \
2025-05-24T14:54:58.5648787Z 		size_t __len = sizeof(*(__array)) * __num; \
2025-05-24T14:54:58.5649135Z 		memmove(__dst, __src, __len); \
2025-05-24T14:54:58.5649336Z 	} \
2025-05-24T14:54:58.5649495Z 	(__array)[(__new_idx)] = (__new_elem); \
2025-05-24T14:54:58.5649706Z } while(0)
2025-05-24T14:54:58.5649792Z 
2025-05-24T14:54:58.5649853Z /**
2025-05-24T14:54:58.5650008Z  * Pointer difference macro
2025-05-24T14:54:58.5650194Z  */
2025-05-24T14:54:58.5650439Z #define PTR_DIFF(p1,p2) ((ptrdiff_t)(((const char *)(p1)) - (const char *)(p2)))
2025-05-24T14:54:58.5650695Z 
2025-05-24T14:54:58.5650762Z #ifdef __COMPAR_FN_T
2025-05-24T14:54:58.5650949Z #define QSORT_CAST (__compar_fn_t)
2025-05-24T14:54:58.5651153Z #endif
2025-05-24T14:54:58.5651235Z 
2025-05-24T14:54:58.5651304Z #ifndef QSORT_CAST
2025-05-24T14:54:58.5651520Z #define QSORT_CAST (int (*)(const void *, const void *))
2025-05-24T14:54:58.5651774Z #endif
2025-05-24T14:54:58.5651852Z 
2025-05-24T14:54:58.5651916Z #ifndef PATH_MAX
2025-05-24T14:54:58.5652085Z #define PATH_MAX 1024
2025-05-24T14:54:58.5652255Z #endif
2025-05-24T14:54:58.5652339Z 
2025-05-24T14:54:58.5652411Z #ifndef MAX_DNS_NAME_LENGTH
2025-05-24T14:54:58.5652702Z #define MAX_DNS_NAME_LENGTH 256 /* Actually 255 but +1 for terminating null. */
2025-05-24T14:54:58.5653023Z #endif
2025-05-24T14:54:58.5653103Z 
2025-05-24T14:54:58.5653178Z #ifdef HAVE_CRYPT_H
2025-05-24T14:54:58.5653346Z #include <crypt.h>
2025-05-24T14:54:58.5653509Z #endif
2025-05-24T14:54:58.5653676Z 
2025-05-24T14:54:58.5653797Z /* these macros gain us a few percent of speed on gcc */
2025-05-24T14:54:58.5654061Z #if (__GNUC__ >= 3)
2025-05-24T14:54:58.5654309Z /* the strange !! is to ensure that __builtin_expect() takes either 0 or 1
2025-05-24T14:54:58.5654617Z    as its first argument */
2025-05-24T14:54:58.5654800Z #ifndef likely
2025-05-24T14:54:58.5654986Z #define likely(x)   __builtin_expect(!!(x), 1)
2025-05-24T14:54:58.5655208Z #endif
2025-05-24T14:54:58.5655477Z #ifndef unlikely
2025-05-24T14:54:58.5655674Z #define unlikely(x) __builtin_expect(!!(x), 0)
2025-05-24T14:54:58.5655901Z #endif
2025-05-24T14:54:58.5656036Z #else
2025-05-24T14:54:58.5656176Z #ifndef likely
2025-05-24T14:54:58.5656340Z #define likely(x) (x)
2025-05-24T14:54:58.5656502Z #endif
2025-05-24T14:54:58.5656644Z #ifndef unlikely
2025-05-24T14:54:58.5656810Z #define unlikely(x) (x)
2025-05-24T14:54:58.5656981Z #endif
2025-05-24T14:54:58.5657119Z #endif
2025-05-24T14:54:58.5657197Z 
2025-05-24T14:54:58.5657264Z #ifndef HAVE_FDATASYNC
2025-05-24T14:54:58.5657452Z #define fdatasync(fd) fsync(fd)
2025-05-24T14:54:58.5657662Z #elif !defined(HAVE_DECL_FDATASYNC)
2025-05-24T14:54:58.5657877Z int fdatasync(int );
2025-05-24T14:54:58.5658036Z #endif
2025-05-24T14:54:58.5658118Z 
2025-05-24T14:54:58.5658247Z /* these are used to mark symbols as local to a shared lib, or
2025-05-24T14:54:58.5658552Z  * publicly available via the shared lib API */
2025-05-24T14:54:58.5658794Z #ifndef _PUBLIC_
2025-05-24T14:54:58.5658964Z #ifdef HAVE_VISIBILITY_ATTR
2025-05-24T14:54:58.5659201Z #define _PUBLIC_ __attribute__((visibility("default")))
2025-05-24T14:54:58.5659537Z #else
2025-05-24T14:54:58.5659680Z #define _PUBLIC_
2025-05-24T14:54:58.5659832Z #endif
2025-05-24T14:54:58.5659963Z #endif
2025-05-24T14:54:58.5660040Z 
2025-05-24T14:54:58.5660103Z #ifndef _PRIVATE_
2025-05-24T14:54:58.5660275Z #ifdef HAVE_VISIBILITY_ATTR
2025-05-24T14:54:58.5660627Z #  define _PRIVATE_ __attribute__((visibility("hidden")))
2025-05-24T14:54:58.5660970Z #else
2025-05-24T14:54:58.5661224Z #  define _PRIVATE_
2025-05-24T14:54:58.5661496Z #endif
2025-05-24T14:54:58.5661714Z #endif
2025-05-24T14:54:58.5661846Z 
2025-05-24T14:54:58.5662003Z #ifndef HAVE_POLL
2025-05-24T14:54:58.5662285Z #define poll rep_poll
2025-05-24T14:54:58.5662621Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.5662990Z #endif
2025-05-24T14:54:58.5663127Z 
2025-05-24T14:54:58.5663241Z #ifndef HAVE_GETPEEREID
2025-05-24T14:54:58.5663560Z #define getpeereid rep_getpeereid
2025-05-24T14:54:58.5663983Z int rep_getpeereid(int s, uid_t *uid, gid_t *gid);
2025-05-24T14:54:58.5664402Z #endif
2025-05-24T14:54:58.5664501Z 
2025-05-24T14:54:58.5664568Z #ifndef HAVE_USLEEP
2025-05-24T14:54:58.5664745Z #define usleep rep_usleep
2025-05-24T14:54:58.5664937Z typedef long useconds_t;
2025-05-24T14:54:58.5665127Z int usleep(useconds_t);
2025-05-24T14:54:58.5665289Z #endif
2025-05-24T14:54:58.5665484Z 
2025-05-24T14:54:58.5665560Z #ifndef HAVE_SETPROCTITLE
2025-05-24T14:54:58.5665760Z #define setproctitle rep_setproctitle
2025-05-24T14:54:58.5666083Z void rep_setproctitle(const char *fmt, ...) PRINTF_ATTRIBUTE(1, 2);
2025-05-24T14:54:58.5666379Z #endif
2025-05-24T14:54:58.5666468Z 
2025-05-24T14:54:58.5666545Z #ifndef HAVE_SETPROCTITLE_INIT
2025-05-24T14:54:58.5666780Z #define setproctitle_init rep_setproctitle_init
2025-05-24T14:54:58.5667097Z void rep_setproctitle_init(int argc, char *argv[], char *envp[]);
2025-05-24T14:54:58.5667378Z #endif
2025-05-24T14:54:58.5667455Z 
2025-05-24T14:54:58.5667519Z #ifndef HAVE_MEMSET_S
2025-05-24T14:54:58.5667702Z #define memset_s rep_memset_s
2025-05-24T14:54:58.5667967Z int rep_memset_s(void *dest, size_t destsz, int ch, size_t count);
2025-05-24T14:54:58.5668246Z #endif
2025-05-24T14:54:58.5668325Z 
2025-05-24T14:54:58.5668395Z #ifndef HAVE_GETPROGNAME
2025-05-24T14:54:58.5668596Z #define getprogname rep_getprogname
2025-05-24T14:54:58.5668828Z const char *rep_getprogname(void);
2025-05-24T14:54:58.5669022Z #endif
2025-05-24T14:54:58.5669099Z 
2025-05-24T14:54:58.5669269Z #ifndef HAVE_COPY_FILE_RANGE
2025-05-24T14:54:58.5669485Z #define copy_file_range rep_copy_file_range
2025-05-24T14:54:58.5669727Z ssize_t rep_copy_file_range(int fd_in,
2025-05-24T14:54:58.5669942Z 			    loff_t *off_in,
2025-05-24T14:54:58.5670110Z 			    int fd_out,
2025-05-24T14:54:58.5670268Z 			    loff_t *off_out,
2025-05-24T14:54:58.5670436Z 			    size_t len,
2025-05-24T14:54:58.5670596Z 			    unsigned int flags);
2025-05-24T14:54:58.5670797Z #endif /* HAVE_COPY_FILE_RANGE */
2025-05-24T14:54:58.5670936Z 
2025-05-24T14:54:58.5671004Z #ifndef FALL_THROUGH
2025-05-24T14:54:58.5671187Z # ifdef HAVE_FALLTHROUGH_ATTRIBUTE
2025-05-24T14:54:58.5671433Z #  define FALL_THROUGH __attribute__ ((fallthrough))
2025-05-24T14:54:58.5671701Z # else /* HAVE_FALLTHROUGH_ATTRIBUTE */
2025-05-24T14:54:58.5671927Z #  define FALL_THROUGH ((void)0)
2025-05-24T14:54:58.5672147Z # endif /* HAVE_FALLTHROUGH_ATTRIBUTE */
2025-05-24T14:54:58.5672376Z #endif /* FALL_THROUGH */
2025-05-24T14:54:58.5672495Z 
2025-05-24T14:54:58.5672576Z struct __rep_cwrap_enabled_state {
2025-05-24T14:54:58.5672782Z 	const char *fnname;
2025-05-24T14:54:58.5672944Z 	bool cached;
2025-05-24T14:54:58.5673095Z 	bool retval;
2025-05-24T14:54:58.5673240Z };
2025-05-24T14:54:58.5673317Z 
2025-05-24T14:54:58.5673504Z static inline bool __rep_cwrap_enabled_fn(struct __rep_cwrap_enabled_state *state)
2025-05-24T14:54:58.5673833Z {
2025-05-24T14:54:58.5673992Z 	bool (*__wrapper_enabled_fn)(void) = NULL;
2025-05-24T14:54:58.5674159Z 
2025-05-24T14:54:58.5674226Z 	if (state->cached) {
2025-05-24T14:54:58.5674469Z 		return state->retval;
2025-05-24T14:54:58.5674713Z 	}
2025-05-24T14:54:58.5674965Z 	state->retval = false;
2025-05-24T14:54:58.5675261Z 	state->cached = true;
2025-05-24T14:54:58.5675575Z 
2025-05-24T14:54:58.5675860Z 	__wrapper_enabled_fn = (bool (*)(void))dlsym(RTLD_DEFAULT, state->fnname);
2025-05-24T14:54:58.5676603Z 	if (__wrapper_enabled_fn == NULL) {
2025-05-24T14:54:58.5676845Z 		return state->retval;
2025-05-24T14:54:58.5677009Z 	}
2025-05-24T14:54:58.5677093Z 
2025-05-24T14:54:58.5677177Z 	state->retval = __wrapper_enabled_fn();
2025-05-24T14:54:58.5677401Z 	return state->retval;
2025-05-24T14:54:58.5677569Z }
2025-05-24T14:54:58.5677573Z 
2025-05-24T14:54:58.5677669Z static inline bool nss_wrapper_enabled(void)
2025-05-24T14:54:58.5677732Z {
2025-05-24T14:54:58.5677820Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.5677897Z 		.fnname = "nss_wrapper_enabled",
2025-05-24T14:54:58.5677953Z 	};
2025-05-24T14:54:58.5678039Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.5678097Z }
2025-05-24T14:54:58.5678206Z static inline bool nss_wrapper_hosts_enabled(void)
2025-05-24T14:54:58.5678264Z {
2025-05-24T14:54:58.5678351Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.5678432Z 		.fnname = "nss_wrapper_hosts_enabled",
2025-05-24T14:54:58.5678486Z 	};
2025-05-24T14:54:58.5678573Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.5678626Z }
2025-05-24T14:54:58.5678726Z static inline bool socket_wrapper_enabled(void)
2025-05-24T14:54:58.5678788Z {
2025-05-24T14:54:58.5678873Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.5678952Z 		.fnname = "socket_wrapper_enabled",
2025-05-24T14:54:58.5679007Z 	};
2025-05-24T14:54:58.5679089Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.5679143Z }
2025-05-24T14:54:58.5679236Z static inline bool uid_wrapper_enabled(void)
2025-05-24T14:54:58.5679295Z {
2025-05-24T14:54:58.5679378Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.5679452Z 		.fnname = "uid_wrapper_enabled",
2025-05-24T14:54:58.5679509Z 	};
2025-05-24T14:54:58.5679590Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.5679644Z }
2025-05-24T14:54:58.5679648Z 
2025-05-24T14:54:58.5679759Z static inline bool _hexcharval(char c, uint8_t *val)
2025-05-24T14:54:58.5679823Z {
2025-05-24T14:54:58.5679930Z 	if ((c >= '0') && (c <= '9')) { *val = c - '0';      return true; }
2025-05-24T14:54:58.5680024Z 	if ((c >= 'a') && (c <= 'f')) {	*val = c - 'a' + 10; return true; }
2025-05-24T14:54:58.5680182Z 	if ((c >= 'A') && (c <= 'F')) { *val = c - 'A' + 10; return true; }
2025-05-24T14:54:58.5680246Z 	return false;
2025-05-24T14:54:58.5680299Z }
2025-05-24T14:54:58.5680303Z 
2025-05-24T14:54:58.5680427Z static inline bool hex_byte(const char *in, uint8_t *out)
2025-05-24T14:54:58.5680488Z {
2025-05-24T14:54:58.5680552Z 	uint8_t hi=0, lo=0;
2025-05-24T14:54:58.5680677Z 	bool ok = _hexcharval(in[0], &hi) && _hexcharval(in[1], &lo);
2025-05-24T14:54:58.5680742Z 	*out = (hi<<4)+lo;
2025-05-24T14:54:58.5680806Z 	return ok;
2025-05-24T14:54:58.5680864Z }
2025-05-24T14:54:58.5680868Z 
2025-05-24T14:54:58.5680973Z /* Needed for Solaris atomic_add_XX functions. */
2025-05-24T14:54:58.5681054Z #if defined(HAVE_SYS_ATOMIC_H)
2025-05-24T14:54:58.5681122Z #include <sys/atomic.h>
2025-05-24T14:54:58.5681178Z #endif
2025-05-24T14:54:58.5681182Z 
2025-05-24T14:54:58.5681243Z /*
2025-05-24T14:54:58.5681412Z  * This handles the case of missing pthread support and ensures code can use
2025-05-24T14:54:58.5681601Z  * __thread unconditionally, such that when built on a platform without pthread
2025-05-24T14:54:58.5681710Z  * support, the __thread qualifier is an empty define.
2025-05-24T14:54:58.5681769Z  */
2025-05-24T14:54:58.5681835Z #ifndef HAVE___THREAD
2025-05-24T14:54:58.5681899Z # ifdef HAVE_PTHREAD
2025-05-24T14:54:58.5682075Z # error Configure failed to detect pthread library with missing TLS support
2025-05-24T14:54:58.5682134Z # endif
2025-05-24T14:54:58.5682201Z #define HAVE___THREAD
2025-05-24T14:54:58.5682257Z #endif
2025-05-24T14:54:58.5682325Z 
2025-05-24T14:54:58.5682410Z #endif /* _LIBREPLACE_REPLACE_H */
2025-05-24T14:54:58.5682480Z === End of replace.h ===
2025-05-24T14:54:58.5682561Z === Original .c files in lib/replace ===
2025-05-24T14:54:58.5682647Z Content of lib/replace/closefrom.c:
2025-05-24T14:54:58.5682703Z /*
2025-05-24T14:54:58.5682877Z  * Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5682949Z  * Samba utility functions
2025-05-24T14:54:58.5683035Z  * Copyright (C) Volker Lendecke 2016
2025-05-24T14:54:58.5683091Z  *
2025-05-24T14:54:58.5683216Z  *   ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5683351Z  *   ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5683414Z  *   ** under the LGPL
2025-05-24T14:54:58.5683469Z  *
2025-05-24T14:54:58.5683603Z  * This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5683738Z  * modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5683871Z  * License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5684015Z  * version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5684075Z  *
2025-05-24T14:54:58.5684216Z  * This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5684359Z  * but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5684521Z  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5684627Z  * Library General Public License for more details.
2025-05-24T14:54:58.5684682Z  *
2025-05-24T14:54:58.5684825Z  * You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5685013Z  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5685068Z  */
2025-05-24T14:54:58.5685072Z 
2025-05-24T14:54:58.5685141Z #include "replace.h"
2025-05-24T14:54:58.5685210Z #include <dirent.h>
2025-05-24T14:54:58.5685272Z #include <unistd.h>
2025-05-24T14:54:58.5685333Z #include <limits.h>
2025-05-24T14:54:58.5685512Z 
2025-05-24T14:54:58.5685649Z static int closefrom_sysconf(int lower)
2025-05-24T14:54:58.5685707Z {
2025-05-24T14:54:58.5685775Z 	long max_files, fd;
2025-05-24T14:54:58.5685779Z 
2025-05-24T14:54:58.5685857Z 	max_files = sysconf(_SC_OPEN_MAX);
2025-05-24T14:54:58.5685934Z 	if (max_files == -1) {
2025-05-24T14:54:58.5685996Z 		max_files = 65536;
2025-05-24T14:54:58.5686052Z 	}
2025-05-24T14:54:58.5686134Z 
2025-05-24T14:54:58.5686220Z 	for (fd=lower; fd<max_files; fd++) {
2025-05-24T14:54:58.5686281Z 		close(fd);
2025-05-24T14:54:58.5686336Z 	}
2025-05-24T14:54:58.5686340Z 
2025-05-24T14:54:58.5686398Z 	return 0;
2025-05-24T14:54:58.5686458Z }
2025-05-24T14:54:58.5686461Z 
2025-05-24T14:54:58.5686545Z static int closefrom_procfs(int lower)
2025-05-24T14:54:58.5686602Z {
2025-05-24T14:54:58.5686666Z 	DIR *dirp;
2025-05-24T14:54:58.5686723Z 	int dir_fd;
2025-05-24T14:54:58.5686788Z 	struct dirent *dp;
2025-05-24T14:54:58.5686848Z 	int *fds = NULL;
2025-05-24T14:54:58.5686917Z 	size_t num_fds = 0;
2025-05-24T14:54:58.5686988Z 	size_t fd_array_size = 0;
2025-05-24T14:54:58.5687049Z 	size_t i;
2025-05-24T14:54:58.5687116Z 	int ret = ENOMEM;
2025-05-24T14:54:58.5687120Z 
2025-05-24T14:54:58.5687203Z 	dirp = opendir("/proc/self/fd");
2025-05-24T14:54:58.5687267Z 	if (dirp == NULL) {
2025-05-24T14:54:58.5687331Z 		return errno;
2025-05-24T14:54:58.5687388Z 	}
2025-05-24T14:54:58.5687392Z 
2025-05-24T14:54:58.5687460Z 	dir_fd = dirfd(dirp);
2025-05-24T14:54:58.5687524Z 	if (dir_fd == -1) {
2025-05-24T14:54:58.5687587Z 		ret = errno;
2025-05-24T14:54:58.5687646Z 		goto fail;
2025-05-24T14:54:58.5687703Z 	}
2025-05-24T14:54:58.5687707Z 
2025-05-24T14:54:58.5687791Z 	while ((dp = readdir(dirp)) != NULL) {
2025-05-24T14:54:58.5687850Z 		char *endptr;
2025-05-24T14:54:58.5687920Z 		unsigned long long fd;
2025-05-24T14:54:58.5687923Z 
2025-05-24T14:54:58.5687981Z 		errno = 0;
2025-05-24T14:54:58.5687984Z 
2025-05-24T14:54:58.5688076Z 		fd = strtoull(dp->d_name, &endptr, 10);
2025-05-24T14:54:58.5688216Z 		if ((fd == 0) && (errno == EINVAL)) {
2025-05-24T14:54:58.5688273Z 			continue;
2025-05-24T14:54:58.5688332Z 		}
2025-05-24T14:54:58.5688422Z 		if ((fd == ULLONG_MAX) && (errno == ERANGE)) {
2025-05-24T14:54:58.5688480Z 			continue;
2025-05-24T14:54:58.5688536Z 		}
2025-05-24T14:54:58.5688783Z 		if (*endptr != '\0') {
2025-05-24T14:54:58.5688900Z 			continue;
2025-05-24T14:54:58.5688993Z 		}
2025-05-24T14:54:58.5689103Z 		if (fd == dir_fd) {
2025-05-24T14:54:58.5689202Z 			continue;
2025-05-24T14:54:58.5689294Z 		}
2025-05-24T14:54:58.5689397Z 		if (fd > INT_MAX) {
2025-05-24T14:54:58.5689498Z 			continue;
2025-05-24T14:54:58.5689588Z 		}
2025-05-24T14:54:58.5689689Z 		if (fd < lower) {
2025-05-24T14:54:58.5689793Z 			continue;
2025-05-24T14:54:58.5689857Z 		}
2025-05-24T14:54:58.5689861Z 
2025-05-24T14:54:58.5689962Z 		if (num_fds >= (fd_array_size / sizeof(int))) {
2025-05-24T14:54:58.5690022Z 			void *tmp;
2025-05-24T14:54:58.5690026Z 
2025-05-24T14:54:58.5690103Z 			if (fd_array_size == 0) {
2025-05-24T14:54:58.5690183Z 				fd_array_size = 16 * sizeof(int);
2025-05-24T14:54:58.5690240Z 			} else {
2025-05-24T14:54:58.5690320Z 				if (fd_array_size + fd_array_size <
2025-05-24T14:54:58.5690385Z 				    fd_array_size) {
2025-05-24T14:54:58.5690449Z 					/* overflow */
2025-05-24T14:54:58.5690508Z 					goto fail;
2025-05-24T14:54:58.5690571Z 				}
2025-05-24T14:54:58.5690666Z 				fd_array_size = fd_array_size + fd_array_size;
2025-05-24T14:54:58.5690727Z 			}
2025-05-24T14:54:58.5690731Z 
2025-05-24T14:54:58.5690813Z 			tmp = realloc(fds, fd_array_size);
2025-05-24T14:54:58.5690877Z 			if (tmp == NULL) {
2025-05-24T14:54:58.5690935Z 				goto fail;
2025-05-24T14:54:58.5690989Z 			}
2025-05-24T14:54:58.5691052Z 			fds = tmp;
2025-05-24T14:54:58.5691108Z 		}
2025-05-24T14:54:58.5691111Z 
2025-05-24T14:54:58.5691178Z 		fds[num_fds++] = fd;
2025-05-24T14:54:58.5691237Z 	}
2025-05-24T14:54:58.5691240Z 
2025-05-24T14:54:58.5691310Z 	for (i=0; i<num_fds; i++) {
2025-05-24T14:54:58.5691370Z 		close(fds[i]);
2025-05-24T14:54:58.5691426Z 	}
2025-05-24T14:54:58.5691434Z 
2025-05-24T14:54:58.5691493Z 	ret = 0;
2025-05-24T14:54:58.5691548Z fail:
2025-05-24T14:54:58.5691611Z 	closedir(dirp);
2025-05-24T14:54:58.5691672Z 	free(fds);
2025-05-24T14:54:58.5691731Z 	return ret;
2025-05-24T14:54:58.5691786Z }
2025-05-24T14:54:58.5691790Z 
2025-05-24T14:54:58.5691868Z int rep_closefrom(int lower)
2025-05-24T14:54:58.5691929Z {
2025-05-24T14:54:58.5692043Z 	int ret;
2025-05-24T14:54:58.5692047Z 
2025-05-24T14:54:58.5692120Z 	ret = closefrom_procfs(lower);
2025-05-24T14:54:58.5692186Z 	if (ret == 0) {
2025-05-24T14:54:58.5692243Z 		return 0;
2025-05-24T14:54:58.5692296Z 	}
2025-05-24T14:54:58.5692300Z 
2025-05-24T14:54:58.5692380Z 	return closefrom_sysconf(lower);
2025-05-24T14:54:58.5692436Z }
2025-05-24T14:54:58.5692498Z -------------------
2025-05-24T14:54:58.5692573Z Content of lib/replace/dlfcn.c:
2025-05-24T14:54:58.5692633Z /* 
2025-05-24T14:54:58.5692711Z    Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5692782Z    Samba system utilities
2025-05-24T14:54:58.5692872Z    Copyright (C) Andrew Tridgell 1992-1998
2025-05-24T14:54:58.5692958Z    Copyright (C) Jeremy Allison 1998-2002
2025-05-24T14:54:58.5693034Z    Copyright (C) Jelmer Vernooij 2006
2025-05-24T14:54:58.5693037Z 
2025-05-24T14:54:58.5693170Z      ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5693307Z      ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5693373Z      ** under the LGPL
2025-05-24T14:54:58.5693427Z    
2025-05-24T14:54:58.5693567Z    This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5693696Z    modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5693829Z    License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5693966Z    version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5693972Z 
2025-05-24T14:54:58.5694112Z    This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5694298Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5694458Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5694561Z    Lesser General Public License for more details.
2025-05-24T14:54:58.5694564Z 
2025-05-24T14:54:58.5694783Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5694969Z    License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5695026Z */
2025-05-24T14:54:58.5695029Z 
2025-05-24T14:54:58.5695098Z #include "replace.h"
2025-05-24T14:54:58.5695159Z #ifdef HAVE_DL_H
2025-05-24T14:54:58.5695222Z #include <dl.h>
2025-05-24T14:54:58.5695278Z #endif
2025-05-24T14:54:58.5695281Z 
2025-05-24T14:54:58.5695470Z #ifndef HAVE_DLOPEN
2025-05-24T14:54:58.5695554Z #ifdef DLOPEN_TAKES_UNSIGNED_FLAGS
2025-05-24T14:54:58.5695676Z void *rep_dlopen(const char *name, unsigned int flags)
2025-05-24T14:54:58.5695733Z #else
2025-05-24T14:54:58.5695828Z void *rep_dlopen(const char *name, int flags)
2025-05-24T14:54:58.5695888Z #endif
2025-05-24T14:54:58.5695943Z {
2025-05-24T14:54:58.5696008Z #ifdef HAVE_SHL_LOAD
2025-05-24T14:54:58.5696078Z 	if (name == NULL)
2025-05-24T14:54:58.5696153Z 		return PROG_HANDLE;
2025-05-24T14:54:58.5696242Z 	return (void *)shl_load(name, flags, 0);
2025-05-24T14:54:58.5696298Z #else
2025-05-24T14:54:58.5696362Z 	return NULL;
2025-05-24T14:54:58.5696421Z #endif
2025-05-24T14:54:58.5696475Z }
2025-05-24T14:54:58.5696530Z #endif
2025-05-24T14:54:58.5696534Z 
2025-05-24T14:54:58.5696602Z #ifndef HAVE_DLSYM
2025-05-24T14:54:58.5696701Z void *rep_dlsym(void *handle, const char *symbol)
2025-05-24T14:54:58.5696758Z {
2025-05-24T14:54:58.5696828Z #ifdef HAVE_SHL_FINDSYM
2025-05-24T14:54:58.5696889Z 	void *sym_addr;
2025-05-24T14:54:58.5697044Z 	if (!shl_findsym((shl_t *)&handle, symbol, TYPE_UNDEFINED, &sym_addr))
2025-05-24T14:54:58.5697108Z 		return sym_addr;
2025-05-24T14:54:58.5697168Z #endif
2025-05-24T14:54:58.5697231Z     return NULL;
2025-05-24T14:54:58.5697286Z }
2025-05-24T14:54:58.5697347Z #endif
2025-05-24T14:54:58.5697351Z 
2025-05-24T14:54:58.5697417Z #ifndef HAVE_DLERROR
2025-05-24T14:54:58.5697496Z char *rep_dlerror(void)
2025-05-24T14:54:58.5697565Z {
2025-05-24T14:54:58.5697731Z 	return "dynamic loading of objects not supported on this platform";
2025-05-24T14:54:58.5697786Z }
2025-05-24T14:54:58.5697842Z #endif
2025-05-24T14:54:58.5697920Z 
2025-05-24T14:54:58.5697995Z #ifndef HAVE_DLCLOSE
2025-05-24T14:54:58.5698075Z int rep_dlclose(void *handle)
2025-05-24T14:54:58.5698131Z {
2025-05-24T14:54:58.5698196Z #ifdef HAVE_SHL_CLOSE
2025-05-24T14:54:58.5698279Z 	return shl_unload((shl_t)handle);
2025-05-24T14:54:58.5698335Z #else
2025-05-24T14:54:58.5698393Z 	return 0;
2025-05-24T14:54:58.5698452Z #endif
2025-05-24T14:54:58.5698508Z }
2025-05-24T14:54:58.5698563Z #endif
2025-05-24T14:54:58.5698625Z -------------------
2025-05-24T14:54:58.5698717Z Content of lib/replace/getaddrinfo.c:
2025-05-24T14:54:58.5698776Z /*
2025-05-24T14:54:58.5698862Z PostgreSQL Database Management System
2025-05-24T14:54:58.5698975Z (formerly known as Postgres, then as Postgres95)
2025-05-24T14:54:58.5698978Z 
2025-05-24T14:54:58.5699159Z Portions Copyright (c) 1996-2005, The PostgreSQL Global Development Group
2025-05-24T14:54:58.5699167Z 
2025-05-24T14:54:58.5699331Z Portions Copyright (c) 1994, The Regents of the University of California
2025-05-24T14:54:58.5699337Z 
2025-05-24T14:54:58.5699498Z Permission to use, copy, modify, and distribute this software and its
2025-05-24T14:54:58.5699680Z documentation for any purpose, without fee, and without a written agreement
2025-05-24T14:54:58.5699866Z is hereby granted, provided that the above copyright notice and this paragraph
2025-05-24T14:54:58.5699989Z and the following two paragraphs appear in all copies.
2025-05-24T14:54:58.5699997Z 
2025-05-24T14:54:58.5700156Z IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
2025-05-24T14:54:58.5700400Z DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
2025-05-24T14:54:58.5700572Z LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
2025-05-24T14:54:58.5700746Z EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
2025-05-24T14:54:58.5700806Z SUCH DAMAGE.
2025-05-24T14:54:58.5700913Z 
2025-05-24T14:54:58.5701071Z THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
2025-05-24T14:54:58.5701242Z INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
2025-05-24T14:54:58.5701470Z AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS
2025-05-24T14:54:58.5701715Z ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS
2025-05-24T14:54:58.5702022Z TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
2025-05-24T14:54:58.5702028Z 
2025-05-24T14:54:58.5702119Z */
2025-05-24T14:54:58.5702124Z 
2025-05-24T14:54:58.5702323Z /*-------------------------------------------------------------------------
2025-05-24T14:54:58.5702424Z  *
2025-05-24T14:54:58.5702531Z  * getaddrinfo.c
2025-05-24T14:54:58.5702659Z  *	  Support getaddrinfo() on platforms that don't have it.
2025-05-24T14:54:58.5702715Z  *
2025-05-24T14:54:58.5702886Z  * We also supply getnameinfo() here, assuming that the platform will have
2025-05-24T14:54:58.5703025Z  * it if and only if it has getaddrinfo().	If this proves false on some
2025-05-24T14:54:58.5703182Z  * platform, we'll need to split this file and provide a separate configure
2025-05-24T14:54:58.5703260Z  * test for getnameinfo().
2025-05-24T14:54:58.5703317Z  *
2025-05-24T14:54:58.5703454Z  * Copyright (c) 2003-2007, PostgreSQL Global Development Group
2025-05-24T14:54:58.5703509Z  *
2025-05-24T14:54:58.5703592Z  * Copyright (C) 2007 Jeremy Allison.
2025-05-24T14:54:58.5703709Z  * Modified to return multiple IPv4 addresses for Samba.
2025-05-24T14:54:58.5703766Z  *
2025-05-24T14:54:58.5703884Z  *-------------------------------------------------------------------------
2025-05-24T14:54:58.5703941Z  */
2025-05-24T14:54:58.5703945Z 
2025-05-24T14:54:58.5704012Z #include "replace.h"
2025-05-24T14:54:58.5704091Z #include "system/network.h"
2025-05-24T14:54:58.5704095Z 
2025-05-24T14:54:58.5704160Z #ifndef SMB_MALLOC
2025-05-24T14:54:58.5704241Z #define SMB_MALLOC(s) malloc(s)
2025-05-24T14:54:58.5704298Z #endif
2025-05-24T14:54:58.5704301Z 
2025-05-24T14:54:58.5704370Z #ifndef SMB_STRDUP
2025-05-24T14:54:58.5704509Z #define SMB_STRDUP(s) strdup(s)
2025-05-24T14:54:58.5704565Z #endif
2025-05-24T14:54:58.5704569Z 
2025-05-24T14:54:58.5704678Z static int check_hostent_err(struct hostent *hp)
2025-05-24T14:54:58.5704734Z {
2025-05-24T14:54:58.5704796Z 	if (!hp) {
2025-05-24T14:54:58.5704860Z 		switch (h_errno) {
2025-05-24T14:54:58.5704934Z 			case HOST_NOT_FOUND:
2025-05-24T14:54:58.5704995Z 			case NO_DATA:
2025-05-24T14:54:58.5705059Z 				return EAI_NONAME;
2025-05-24T14:54:58.5705126Z 			case TRY_AGAIN:
2025-05-24T14:54:58.5705191Z 				return EAI_AGAIN;
2025-05-24T14:54:58.5705260Z 			case NO_RECOVERY:
2025-05-24T14:54:58.5705320Z 			default:
2025-05-24T14:54:58.5705498Z 				return EAI_FAIL;
2025-05-24T14:54:58.5705556Z 		}
2025-05-24T14:54:58.5705609Z 	}
2025-05-24T14:54:58.5705709Z 	if (!hp->h_name || hp->h_addrtype != AF_INET) {
2025-05-24T14:54:58.5705775Z 		return EAI_FAIL;
2025-05-24T14:54:58.5705829Z 	}
2025-05-24T14:54:58.5705888Z 	return 0;
2025-05-24T14:54:58.5705949Z }
2025-05-24T14:54:58.5705955Z 
2025-05-24T14:54:58.5706083Z static char *canon_name_from_hostent(struct hostent *hp,
2025-05-24T14:54:58.5706151Z 				int *perr)
2025-05-24T14:54:58.5706212Z {
2025-05-24T14:54:58.5706276Z 	char *ret = NULL;
2025-05-24T14:54:58.5706279Z 
2025-05-24T14:54:58.5706355Z 	*perr = check_hostent_err(hp);
2025-05-24T14:54:58.5706420Z 	if (*perr) {
2025-05-24T14:54:58.5706485Z 		return NULL;
2025-05-24T14:54:58.5706540Z 	}
2025-05-24T14:54:58.5706616Z 	ret = SMB_STRDUP(hp->h_name);
2025-05-24T14:54:58.5706678Z 	if (!ret) {
2025-05-24T14:54:58.5706844Z 		*perr = EAI_MEMORY;
2025-05-24T14:54:58.5706900Z 	}
2025-05-24T14:54:58.5706960Z 	return ret;
2025-05-24T14:54:58.5707021Z }
2025-05-24T14:54:58.5707025Z 
2025-05-24T14:54:58.5707116Z static char *get_my_canon_name(int *perr)
2025-05-24T14:54:58.5707171Z {
2025-05-24T14:54:58.5707251Z 	char name[HOST_NAME_MAX+1];
2025-05-24T14:54:58.5707367Z 
2025-05-24T14:54:58.5707501Z 	if (gethostname(name, HOST_NAME_MAX) == -1) {
2025-05-24T14:54:58.5707568Z 		*perr = EAI_FAIL;
2025-05-24T14:54:58.5707631Z 		return NULL;
2025-05-24T14:54:58.5707694Z 	}
2025-05-24T14:54:58.5707769Z 	/* Ensure null termination. */
2025-05-24T14:54:58.5707841Z 	name[HOST_NAME_MAX] = '\0';
2025-05-24T14:54:58.5707979Z 	return canon_name_from_hostent(gethostbyname(name), perr);
2025-05-24T14:54:58.5708035Z }
2025-05-24T14:54:58.5708039Z 
2025-05-24T14:54:58.5708157Z static char *get_canon_name_from_addr(struct in_addr ip,
2025-05-24T14:54:58.5708222Z 				int *perr)
2025-05-24T14:54:58.5708283Z {
2025-05-24T14:54:58.5708357Z 	return canon_name_from_hostent(
2025-05-24T14:54:58.5708450Z 			gethostbyaddr(&ip, sizeof(ip), AF_INET),
2025-05-24T14:54:58.5708513Z 			perr);
2025-05-24T14:54:58.5708569Z }
2025-05-24T14:54:58.5708572Z 
2025-05-24T14:54:58.5708722Z static struct addrinfo *alloc_entry(const struct addrinfo *hints,
2025-05-24T14:54:58.5708792Z 				struct in_addr ip,
2025-05-24T14:54:58.5708865Z 				unsigned short port)
2025-05-24T14:54:58.5708921Z {
2025-05-24T14:54:58.5709003Z 	struct sockaddr_in *psin = NULL;
2025-05-24T14:54:58.5709110Z 	struct addrinfo *ai = SMB_MALLOC(sizeof(*ai));
2025-05-24T14:54:58.5709114Z 
2025-05-24T14:54:58.5709172Z 	if (!ai) {
2025-05-24T14:54:58.5709233Z 		return NULL;
2025-05-24T14:54:58.5709293Z 	}
2025-05-24T14:54:58.5709365Z 	memset(ai, '\0', sizeof(*ai));
2025-05-24T14:54:58.5709369Z 
2025-05-24T14:54:58.5709446Z 	psin = SMB_MALLOC(sizeof(*psin));
2025-05-24T14:54:58.5709505Z 	if (!psin) {
2025-05-24T14:54:58.5709566Z 		free(ai);
2025-05-24T14:54:58.5709625Z 		return NULL;
2025-05-24T14:54:58.5709676Z 	}
2025-05-24T14:54:58.5709681Z 
2025-05-24T14:54:58.5709760Z 	memset(psin, '\0', sizeof(*psin));
2025-05-24T14:54:58.5709764Z 
2025-05-24T14:54:58.5709834Z 	psin->sin_family = AF_INET;
2025-05-24T14:54:58.5709910Z 	psin->sin_port = htons(port);
2025-05-24T14:54:58.5709977Z 	psin->sin_addr = ip;
2025-05-24T14:54:58.5709986Z 
2025-05-24T14:54:58.5710052Z 	ai->ai_flags = 0;
2025-05-24T14:54:58.5710121Z 	ai->ai_family = AF_INET;
2025-05-24T14:54:58.5710277Z 	ai->ai_socktype = hints->ai_socktype;
2025-05-24T14:54:58.5710361Z 	ai->ai_protocol = hints->ai_protocol;
2025-05-24T14:54:58.5710438Z 	ai->ai_addrlen = sizeof(*psin);
2025-05-24T14:54:58.5710523Z 	ai->ai_addr = (struct sockaddr *) psin;
2025-05-24T14:54:58.5710598Z 	ai->ai_canonname = NULL;
2025-05-24T14:54:58.5710661Z 	ai->ai_next = NULL;
2025-05-24T14:54:58.5710665Z 
2025-05-24T14:54:58.5710725Z 	return ai;
2025-05-24T14:54:58.5710781Z }
2025-05-24T14:54:58.5710785Z 
2025-05-24T14:54:58.5710845Z /*
2025-05-24T14:54:58.5710939Z  * get address info for a single ipv4 address.
2025-05-24T14:54:58.5710997Z  *
2025-05-24T14:54:58.5711107Z  *	Bugs:	- servname can only be a number, not text.
2025-05-24T14:54:58.5711162Z  */
2025-05-24T14:54:58.5711166Z 
2025-05-24T14:54:58.5711288Z static int getaddr_info_single_addr(const char *service,
2025-05-24T14:54:58.5711351Z 				uint32_t addr,
2025-05-24T14:54:58.5711435Z 				const struct addrinfo *hints,
2025-05-24T14:54:58.5711505Z 				struct addrinfo **res)
2025-05-24T14:54:58.5711563Z {
2025-05-24T14:54:58.5711566Z 
2025-05-24T14:54:58.5711642Z 	struct addrinfo *ai = NULL;
2025-05-24T14:54:58.5711707Z 	struct in_addr ip;
2025-05-24T14:54:58.5711778Z 	unsigned short port = 0;
2025-05-24T14:54:58.5711782Z 
2025-05-24T14:54:58.5711848Z 	if (service) {
2025-05-24T14:54:58.5711933Z 		port = (unsigned short)atoi(service);
2025-05-24T14:54:58.5711989Z 	}
2025-05-24T14:54:58.5712058Z 	ip.s_addr = htonl(addr);
2025-05-24T14:54:58.5712062Z 
2025-05-24T14:54:58.5712145Z 	ai = alloc_entry(hints, ip, port);
2025-05-24T14:54:58.5712204Z 	if (!ai) {
2025-05-24T14:54:58.5712318Z 		return EAI_MEMORY;
2025-05-24T14:54:58.5712379Z 	}
2025-05-24T14:54:58.5712383Z 
2025-05-24T14:54:58.5712469Z 	/* If we're asked for the canonical name,
2025-05-24T14:54:58.5712551Z 	 * make sure it returns correctly. */
2025-05-24T14:54:58.5712637Z 	if (!(hints->ai_flags & AI_NUMERICSERV) &&
2025-05-24T14:54:58.5712792Z 			hints->ai_flags & AI_CANONNAME) {
2025-05-24T14:54:58.5712853Z 		int err;
2025-05-24T14:54:58.5712961Z 		if (addr == INADDR_LOOPBACK || addr == INADDR_ANY) {
2025-05-24T14:54:58.5713061Z 			ai->ai_canonname = get_my_canon_name(&err);
2025-05-24T14:54:58.5713118Z 		} else {
2025-05-24T14:54:58.5713184Z 			ai->ai_canonname =
2025-05-24T14:54:58.5713266Z 			get_canon_name_from_addr(ip,&err);
2025-05-24T14:54:58.5713327Z 		}
2025-05-24T14:54:58.5713400Z 		if (ai->ai_canonname == NULL) {
2025-05-24T14:54:58.5713467Z 			freeaddrinfo(ai);
2025-05-24T14:54:58.5713531Z 			return err;
2025-05-24T14:54:58.5713587Z 		}
2025-05-24T14:54:58.5713642Z 	}
2025-05-24T14:54:58.5713648Z 
2025-05-24T14:54:58.5713707Z 	*res = ai;
2025-05-24T14:54:58.5713769Z 	return 0;
2025-05-24T14:54:58.5713824Z }
2025-05-24T14:54:58.5713827Z 
2025-05-24T14:54:58.5713883Z /*
2025-05-24T14:54:58.5713986Z  * get address info for multiple ipv4 addresses.
2025-05-24T14:54:58.5714044Z  *
2025-05-24T14:54:58.5714176Z  *	Bugs:	- servname can only be a number, not text.
2025-05-24T14:54:58.5714280Z  */
2025-05-24T14:54:58.5714293Z 
2025-05-24T14:54:58.5714467Z static int getaddr_info_name(const char *node,
2025-05-24T14:54:58.5714581Z 				const char *service,
2025-05-24T14:54:58.5714707Z 				const struct addrinfo *hints,
2025-05-24T14:54:58.5714830Z 				struct addrinfo **res)
2025-05-24T14:54:58.5714921Z {
2025-05-24T14:54:58.5715081Z 	struct addrinfo *listp = NULL, *prevp = NULL;
2025-05-24T14:54:58.5715189Z 	char **pptr = NULL;
2025-05-24T14:54:58.5715289Z 	int err;
2025-05-24T14:54:58.5715519Z 	struct hostent *hp = NULL;
2025-05-24T14:54:58.5715632Z 	unsigned short port = 0;
2025-05-24T14:54:58.5715641Z 
2025-05-24T14:54:58.5715710Z 	if (service) {
2025-05-24T14:54:58.5715794Z 		port = (unsigned short)atoi(service);
2025-05-24T14:54:58.5715849Z 	}
2025-05-24T14:54:58.5715852Z 
2025-05-24T14:54:58.5715929Z 	hp = gethostbyname(node);
2025-05-24T14:54:58.5716002Z 	err = check_hostent_err(hp);
2025-05-24T14:54:58.5716063Z 	if (err) {
2025-05-24T14:54:58.5716123Z 		return err;
2025-05-24T14:54:58.5716182Z 	}
2025-05-24T14:54:58.5716186Z 
2025-05-24T14:54:58.5716376Z 	for(pptr = hp->h_addr_list; *pptr; pptr++) {
2025-05-24T14:54:58.5716476Z 		struct in_addr ip = *(struct in_addr *)*pptr;
2025-05-24T14:54:58.5716592Z 		struct addrinfo *ai = alloc_entry(hints, ip, port);
2025-05-24T14:54:58.5716596Z 
2025-05-24T14:54:58.5716656Z 		if (!ai) {
2025-05-24T14:54:58.5716729Z 			freeaddrinfo(listp);
2025-05-24T14:54:58.5716793Z 			return EAI_MEMORY;
2025-05-24T14:54:58.5716853Z 		}
2025-05-24T14:54:58.5716857Z 
2025-05-24T14:54:58.5716916Z 		if (!listp) {
2025-05-24T14:54:58.5716977Z 			listp = ai;
2025-05-24T14:54:58.5717044Z 			prevp = ai;
2025-05-24T14:54:58.5717134Z 			ai->ai_canonname = SMB_STRDUP(hp->h_name);
2025-05-24T14:54:58.5717204Z 			if (!ai->ai_canonname) {
2025-05-24T14:54:58.5717273Z 				freeaddrinfo(listp);
2025-05-24T14:54:58.5717342Z 				return EAI_MEMORY;
2025-05-24T14:54:58.5717397Z 			}
2025-05-24T14:54:58.5717457Z 		} else {
2025-05-24T14:54:58.5717533Z 			prevp->ai_next = ai;
2025-05-24T14:54:58.5717593Z 			prevp = ai;
2025-05-24T14:54:58.5717651Z 		}
2025-05-24T14:54:58.5717707Z 	}
2025-05-24T14:54:58.5717775Z 	*res = listp;
2025-05-24T14:54:58.5717833Z 	return 0;
2025-05-24T14:54:58.5717888Z }
2025-05-24T14:54:58.5717891Z 
2025-05-24T14:54:58.5717952Z /*
2025-05-24T14:54:58.5718031Z  * get address info for ipv4 sockets.
2025-05-24T14:54:58.5718087Z  *
2025-05-24T14:54:58.5718186Z  *	Bugs:	- servname can only be a number, not text.
2025-05-24T14:54:58.5718243Z  */
2025-05-24T14:54:58.5718246Z 
2025-05-24T14:54:58.5718328Z int rep_getaddrinfo(const char *node,
2025-05-24T14:54:58.5718393Z 		const char *service,
2025-05-24T14:54:58.5718538Z 		const struct addrinfo * hintp,
2025-05-24T14:54:58.5718608Z 		struct addrinfo ** res)
2025-05-24T14:54:58.5718663Z {
2025-05-24T14:54:58.5718730Z 	struct addrinfo hints;
2025-05-24T14:54:58.5718740Z 
2025-05-24T14:54:58.5718813Z 	/* Setup the hints struct. */
2025-05-24T14:54:58.5718983Z 	if (hintp == NULL) {
2025-05-24T14:54:58.5719060Z 		memset(&hints, 0, sizeof(hints));
2025-05-24T14:54:58.5719139Z 		hints.ai_family = AF_INET;
2025-05-24T14:54:58.5719216Z 		hints.ai_socktype = SOCK_STREAM;
2025-05-24T14:54:58.5719275Z 	} else {
2025-05-24T14:54:58.5719364Z 		memcpy(&hints, hintp, sizeof(hints));
2025-05-24T14:54:58.5719418Z 	}
2025-05-24T14:54:58.5719421Z 
2025-05-24T14:54:58.5719561Z 	if (hints.ai_family != AF_INET && hints.ai_family != AF_UNSPEC) {
2025-05-24T14:54:58.5719628Z 		return EAI_FAMILY;
2025-05-24T14:54:58.5719687Z 	}
2025-05-24T14:54:58.5719690Z 
2025-05-24T14:54:58.5719765Z 	if (hints.ai_socktype == 0) {
2025-05-24T14:54:58.5719841Z 		hints.ai_socktype = SOCK_STREAM;
2025-05-24T14:54:58.5719902Z 	}
2025-05-24T14:54:58.5719905Z 
2025-05-24T14:54:58.5719971Z 	if (!node && !service) {
2025-05-24T14:54:58.5720035Z 		return EAI_NONAME;
2025-05-24T14:54:58.5720092Z 	}
2025-05-24T14:54:58.5720096Z 
2025-05-24T14:54:58.5720159Z 	if (node) {
2025-05-24T14:54:58.5720226Z 		if (node[0] == '\0') {
2025-05-24T14:54:58.5720313Z 			return getaddr_info_single_addr(service,
2025-05-24T14:54:58.5720380Z 					INADDR_ANY,
2025-05-24T14:54:58.5720439Z 					&hints,
2025-05-24T14:54:58.5720497Z 					res);
2025-05-24T14:54:58.5720590Z 		} else if (hints.ai_flags & AI_NUMERICHOST) {
2025-05-24T14:54:58.5720662Z 			struct in_addr ip;
2025-05-24T14:54:58.5720733Z 			if (!inet_aton(node, &ip)) {
2025-05-24T14:54:58.5720800Z 				return EAI_FAIL;
2025-05-24T14:54:58.5720859Z 			}
2025-05-24T14:54:58.5720944Z 			return getaddr_info_single_addr(service,
2025-05-24T14:54:58.5721011Z 					ntohl(ip.s_addr),
2025-05-24T14:54:58.5721069Z 					&hints,
2025-05-24T14:54:58.5721130Z 					res);
2025-05-24T14:54:58.5721187Z 		} else {
2025-05-24T14:54:58.5721261Z 			return getaddr_info_name(node,
2025-05-24T14:54:58.5721324Z 						service,
2025-05-24T14:54:58.5721382Z 						&hints,
2025-05-24T14:54:58.5721439Z 						res);
2025-05-24T14:54:58.5721495Z 		}
2025-05-24T14:54:58.5721587Z 	} else if (hints.ai_flags & AI_PASSIVE) {
2025-05-24T14:54:58.5721670Z 		return getaddr_info_single_addr(service,
2025-05-24T14:54:58.5721729Z 					INADDR_ANY,
2025-05-24T14:54:58.5721847Z 					&hints,
2025-05-24T14:54:58.5721904Z 					res);
2025-05-24T14:54:58.5721959Z 	}
2025-05-24T14:54:58.5722046Z 	return getaddr_info_single_addr(service,
2025-05-24T14:54:58.5722118Z 					INADDR_LOOPBACK,
2025-05-24T14:54:58.5722174Z 					&hints,
2025-05-24T14:54:58.5722235Z 					res);
2025-05-24T14:54:58.5722291Z }
2025-05-24T14:54:58.5722299Z 
2025-05-24T14:54:58.5722302Z 
2025-05-24T14:54:58.5722395Z void rep_freeaddrinfo(struct addrinfo *res)
2025-05-24T14:54:58.5722453Z {
2025-05-24T14:54:58.5722526Z 	struct addrinfo *next = NULL;
2025-05-24T14:54:58.5722532Z 
2025-05-24T14:54:58.5722604Z 	for (;res; res = next) {
2025-05-24T14:54:58.5722672Z 		next = res->ai_next;
2025-05-24T14:54:58.5722743Z 		free(res->ai_canonname);
2025-05-24T14:54:58.5722811Z 		free(res->ai_addr);
2025-05-24T14:54:58.5722868Z 		free(res);
2025-05-24T14:54:58.5722924Z 	}
2025-05-24T14:54:58.5722982Z }
2025-05-24T14:54:58.5722986Z 
2025-05-24T14:54:58.5722994Z 
2025-05-24T14:54:58.5723081Z const char *rep_gai_strerror(int errcode)
2025-05-24T14:54:58.5723138Z {
2025-05-24T14:54:58.5723206Z #ifdef HAVE_HSTRERROR
2025-05-24T14:54:58.5723271Z 	int			hcode;
2025-05-24T14:54:58.5723275Z 
2025-05-24T14:54:58.5723339Z 	switch (errcode)
2025-05-24T14:54:58.5723395Z 	{
2025-05-24T14:54:58.5723462Z 		case EAI_NONAME:
2025-05-24T14:54:58.5723532Z 			hcode = HOST_NOT_FOUND;
2025-05-24T14:54:58.5723589Z 			break;
2025-05-24T14:54:58.5723651Z 		case EAI_AGAIN:
2025-05-24T14:54:58.5723719Z 			hcode = TRY_AGAIN;
2025-05-24T14:54:58.5723776Z 			break;
2025-05-24T14:54:58.5723888Z 		case EAI_FAIL:
2025-05-24T14:54:58.5723949Z 		default:
2025-05-24T14:54:58.5724018Z 			hcode = NO_RECOVERY;
2025-05-24T14:54:58.5724073Z 			break;
2025-05-24T14:54:58.5724130Z 	}
2025-05-24T14:54:58.5724133Z 
2025-05-24T14:54:58.5724209Z 	return hstrerror(hcode);
2025-05-24T14:54:58.5724357Z #else							/* !HAVE_HSTRERROR */
2025-05-24T14:54:58.5724361Z 
2025-05-24T14:54:58.5724424Z 	switch (errcode)
2025-05-24T14:54:58.5724485Z 	{
2025-05-24T14:54:58.5724552Z 		case EAI_NONAME:
2025-05-24T14:54:58.5724621Z 			return "Unknown host";
2025-05-24T14:54:58.5724680Z 		case EAI_AGAIN:
2025-05-24T14:54:58.5724764Z 			return "Host name lookup failure";
2025-05-24T14:54:58.5724830Z #ifdef EAI_BADFLAGS
2025-05-24T14:54:58.5724894Z 		case EAI_BADFLAGS:
2025-05-24T14:54:58.5724974Z 			return "Invalid argument";
2025-05-24T14:54:58.5725030Z #endif
2025-05-24T14:54:58.5725092Z #ifdef EAI_FAMILY
2025-05-24T14:54:58.5725152Z 		case EAI_FAMILY:
2025-05-24T14:54:58.5725240Z 			return "Address family not supported";
2025-05-24T14:54:58.5725298Z #endif
2025-05-24T14:54:58.5725542Z #ifdef EAI_MEMORY
2025-05-24T14:54:58.5725622Z 		case EAI_MEMORY:
2025-05-24T14:54:58.5725701Z 			return "Not enough memory";
2025-05-24T14:54:58.5725755Z #endif
2025-05-24T14:54:58.5725820Z #ifdef EAI_NODATA
2025-05-24T14:54:58.5725886Z 		case EAI_NODATA:
2025-05-24T14:54:58.5725989Z 			return "No host data of that type was found";
2025-05-24T14:54:58.5726048Z #endif
2025-05-24T14:54:58.5726113Z #ifdef EAI_SERVICE
2025-05-24T14:54:58.5726178Z 		case EAI_SERVICE:
2025-05-24T14:54:58.5726252Z 			return "Class type not found";
2025-05-24T14:54:58.5726308Z #endif
2025-05-24T14:54:58.5726380Z #ifdef EAI_SOCKTYPE
2025-05-24T14:54:58.5726445Z 		case EAI_SOCKTYPE:
2025-05-24T14:54:58.5726528Z 			return "Socket type not supported";
2025-05-24T14:54:58.5726583Z #endif
2025-05-24T14:54:58.5726645Z 		default:
2025-05-24T14:54:58.5726716Z 			return "Unknown server error";
2025-05-24T14:54:58.5726771Z 	}
2025-05-24T14:54:58.5726851Z #endif   /* HAVE_HSTRERROR */
2025-05-24T14:54:58.5726908Z }
2025-05-24T14:54:58.5726911Z 
2025-05-24T14:54:58.5727030Z static int gethostnameinfo(const struct sockaddr *sa,
2025-05-24T14:54:58.5727090Z 			char *node,
2025-05-24T14:54:58.5727171Z 			size_t nodelen,
2025-05-24T14:54:58.5727282Z 			int flags)
2025-05-24T14:54:58.5727381Z {
2025-05-24T14:54:58.5727502Z 	int ret = -1;
2025-05-24T14:54:58.5727605Z 	char *p = NULL;
2025-05-24T14:54:58.5727610Z 
2025-05-24T14:54:58.5727858Z 	if (!(flags & NI_NUMERICHOST)) {
2025-05-24T14:54:58.5727994Z 		struct hostent *hp = gethostbyaddr(
2025-05-24T14:54:58.5728131Z 				&((struct sockaddr_in *)sa)->sin_addr,
2025-05-24T14:54:58.5728252Z 				sizeof(struct in_addr),
2025-05-24T14:54:58.5728350Z 				sa->sa_family);
2025-05-24T14:54:58.5728430Z 		ret = check_hostent_err(hp);
2025-05-24T14:54:58.5728492Z 		if (ret == 0) {
2025-05-24T14:54:58.5728574Z 			/* Name looked up successfully. */
2025-05-24T14:54:58.5728674Z 			ret = snprintf(node, nodelen, "%s", hp->h_name);
2025-05-24T14:54:58.5728761Z 			if (ret < 0 || (size_t)ret >= nodelen) {
2025-05-24T14:54:58.5728826Z 				return EAI_MEMORY;
2025-05-24T14:54:58.5728882Z 			}
2025-05-24T14:54:58.5728956Z 			if (flags & NI_NOFQDN) {
2025-05-24T14:54:58.5729024Z 				p = strchr(node,'.');
2025-05-24T14:54:58.5729089Z 				if (p) {
2025-05-24T14:54:58.5729146Z 					*p = '\0';
2025-05-24T14:54:58.5729215Z 				}
2025-05-24T14:54:58.5729271Z 			}
2025-05-24T14:54:58.5729330Z 			return 0;
2025-05-24T14:54:58.5729393Z 		}
2025-05-24T14:54:58.5729397Z 
2025-05-24T14:54:58.5729469Z 		if (flags & NI_NAMEREQD) {
2025-05-24T14:54:58.5729559Z 			/* If we require a name and didn't get one,
2025-05-24T14:54:58.5729636Z 			 * automatically fail. */
2025-05-24T14:54:58.5729700Z 			return ret;
2025-05-24T14:54:58.5729756Z 		}
2025-05-24T14:54:58.5729879Z 		/* Otherwise just fall into the numeric host code... */
2025-05-24T14:54:58.5729940Z 	}
2025-05-24T14:54:58.5730046Z 	p = inet_ntoa(((struct sockaddr_in *)sa)->sin_addr);
2025-05-24T14:54:58.5730131Z 	ret = snprintf(node, nodelen, "%s", p);
2025-05-24T14:54:58.5730283Z 	if (ret < 0 || (size_t)ret >= nodelen) {
2025-05-24T14:54:58.5730353Z 		return EAI_MEMORY;
2025-05-24T14:54:58.5730410Z 	}
2025-05-24T14:54:58.5730468Z 	return 0;
2025-05-24T14:54:58.5730526Z }
2025-05-24T14:54:58.5730530Z 
2025-05-24T14:54:58.5730766Z static int getservicenameinfo(const struct sockaddr *sa,
2025-05-24T14:54:58.5730831Z 			char *service,
2025-05-24T14:54:58.5730896Z 			size_t servicelen,
2025-05-24T14:54:58.5730962Z 			int flags)
2025-05-24T14:54:58.5731017Z {
2025-05-24T14:54:58.5731082Z 	int ret = -1;
2025-05-24T14:54:58.5731200Z 	int port = ntohs(((struct sockaddr_in *)sa)->sin_port);
2025-05-24T14:54:58.5731204Z 
2025-05-24T14:54:58.5731281Z 	if (!(flags & NI_NUMERICSERV)) {
2025-05-24T14:54:58.5731366Z 		struct servent *se = getservbyport(
2025-05-24T14:54:58.5731424Z 				port,
2025-05-24T14:54:58.5731510Z 				(flags & NI_DGRAM) ? "udp" : "tcp");
2025-05-24T14:54:58.5731577Z 		if (se && se->s_name) {
2025-05-24T14:54:58.5731669Z 			/* Service name looked up successfully. */
2025-05-24T14:54:58.5731792Z 			ret = snprintf(service, servicelen, "%s", se->s_name);
2025-05-24T14:54:58.5731879Z 			if (ret < 0 || (size_t)ret >= servicelen) {
2025-05-24T14:54:58.5731944Z 				return EAI_MEMORY;
2025-05-24T14:54:58.5732005Z 			}
2025-05-24T14:54:58.5732063Z 			return 0;
2025-05-24T14:54:58.5732124Z 		}
2025-05-24T14:54:58.5732249Z 		/* Otherwise just fall into the numeric service code... */
2025-05-24T14:54:58.5732312Z 	}
2025-05-24T14:54:58.5732416Z 	ret = snprintf(service, servicelen, "%d", port);
2025-05-24T14:54:58.5732504Z 	if (ret < 0 || (size_t)ret >= servicelen) {
2025-05-24T14:54:58.5732576Z 		return EAI_MEMORY;
2025-05-24T14:54:58.5732632Z 	}
2025-05-24T14:54:58.5732692Z 	return 0;
2025-05-24T14:54:58.5732747Z }
2025-05-24T14:54:58.5732751Z 
2025-05-24T14:54:58.5732813Z /*
2025-05-24T14:54:58.5732901Z  * Convert an ipv4 address to a hostname.
2025-05-24T14:54:58.5732957Z  *
2025-05-24T14:54:58.5733030Z  * Bugs:	- No IPv6 support.
2025-05-24T14:54:58.5733094Z  */
2025-05-24T14:54:58.5733243Z int rep_getnameinfo(const struct sockaddr *sa, socklen_t salen,
2025-05-24T14:54:58.5733317Z 			char *node, size_t nodelen,
2025-05-24T14:54:58.5733419Z 			char *service, size_t servicelen, int flags)
2025-05-24T14:54:58.5733477Z {
2025-05-24T14:54:58.5733481Z 
2025-05-24T14:54:58.5733554Z 	/* Invalid arguments. */
2025-05-24T14:54:58.5733667Z 	if (sa == NULL || (node == NULL && service == NULL)) {
2025-05-24T14:54:58.5733783Z 		return EAI_FAIL;
2025-05-24T14:54:58.5733841Z 	}
2025-05-24T14:54:58.5733845Z 
2025-05-24T14:54:58.5733920Z 	if (sa->sa_family != AF_INET) {
2025-05-24T14:54:58.5733992Z 		return EAI_FAIL;
2025-05-24T14:54:58.5734049Z 	}
2025-05-24T14:54:58.5734052Z 
2025-05-24T14:54:58.5734140Z 	if (salen < sizeof(struct sockaddr_in)) {
2025-05-24T14:54:58.5734210Z 		return EAI_FAIL;
2025-05-24T14:54:58.5734266Z 	}
2025-05-24T14:54:58.5734269Z 
2025-05-24T14:54:58.5734329Z 	if (node) {
2025-05-24T14:54:58.5734436Z 		return gethostnameinfo(sa, node, nodelen, flags);
2025-05-24T14:54:58.5734500Z 	}
2025-05-24T14:54:58.5734504Z 
2025-05-24T14:54:58.5734566Z 	if (service) {
2025-05-24T14:54:58.5734703Z 		return getservicenameinfo(sa, service, servicelen, flags);
2025-05-24T14:54:58.5734768Z 	}
2025-05-24T14:54:58.5734830Z 	return 0;
2025-05-24T14:54:58.5734885Z }
2025-05-24T14:54:58.5746927Z -------------------
2025-05-24T14:54:58.5747057Z Content of lib/replace/getifaddrs.c:
2025-05-24T14:54:58.5747158Z /*
2025-05-24T14:54:58.5747306Z    Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5747434Z    Samba utility functions
2025-05-24T14:54:58.5747576Z    Copyright (C) Andrew Tridgell 1998
2025-05-24T14:54:58.5747704Z    Copyright (C) Jeremy Allison 2007
2025-05-24T14:54:58.5747910Z    Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
2025-05-24T14:54:58.5747917Z 
2025-05-24T14:54:58.5748128Z      ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5748356Z      ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5748553Z      ** under the LGPL
2025-05-24T14:54:58.5748557Z 
2025-05-24T14:54:58.5748700Z    This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5748841Z    modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5749094Z    License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5749249Z    version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5749255Z 
2025-05-24T14:54:58.5749403Z    This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5749546Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5749708Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5749818Z    Library General Public License for more details.
2025-05-24T14:54:58.5749822Z 
2025-05-24T14:54:58.5749971Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5750163Z    License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5750224Z */
2025-05-24T14:54:58.5750231Z 
2025-05-24T14:54:58.5750301Z #include "replace.h"
2025-05-24T14:54:58.5750375Z #include "system/network.h"
2025-05-24T14:54:58.5750378Z 
2025-05-24T14:54:58.5750441Z #include <unistd.h>
2025-05-24T14:54:58.5750508Z #include <stdio.h>
2025-05-24T14:54:58.5750576Z #include <sys/types.h>
2025-05-24T14:54:58.5750580Z 
2025-05-24T14:54:58.5750649Z #ifdef HAVE_SYS_TIME_H
2025-05-24T14:54:58.5750715Z #include <sys/time.h>
2025-05-24T14:54:58.5750770Z #endif
2025-05-24T14:54:58.5750774Z 
2025-05-24T14:54:58.5750840Z #ifndef SIOCGIFCONF
2025-05-24T14:54:58.5750912Z #ifdef HAVE_SYS_SOCKIO_H
2025-05-24T14:54:58.5750977Z #include <sys/sockio.h>
2025-05-24T14:54:58.5751033Z #endif
2025-05-24T14:54:58.5751088Z #endif
2025-05-24T14:54:58.5751091Z 
2025-05-24T14:54:58.5751168Z #ifdef HAVE_IFACE_GETIFADDRS
2025-05-24T14:54:58.5751237Z #define _FOUND_IFACE_ANY
2025-05-24T14:54:58.5751291Z #else
2025-05-24T14:54:58.5751297Z 
2025-05-24T14:54:58.5751396Z void rep_freeifaddrs(struct ifaddrs *ifp)
2025-05-24T14:54:58.5751451Z {
2025-05-24T14:54:58.5751514Z 	if (ifp != NULL) {
2025-05-24T14:54:58.5751580Z 		free(ifp->ifa_name);
2025-05-24T14:54:58.5751649Z 		free(ifp->ifa_addr);
2025-05-24T14:54:58.5751717Z 		free(ifp->ifa_netmask);
2025-05-24T14:54:58.5751788Z 		free(ifp->ifa_dstaddr);
2025-05-24T14:54:58.5751863Z 		freeifaddrs(ifp->ifa_next);
2025-05-24T14:54:58.5752000Z 		free(ifp);
2025-05-24T14:54:58.5752056Z 	}
2025-05-24T14:54:58.5752112Z }
2025-05-24T14:54:58.5752115Z 
2025-05-24T14:54:58.5752258Z static struct sockaddr *sockaddr_dup(struct sockaddr *sa)
2025-05-24T14:54:58.5752312Z {
2025-05-24T14:54:58.5752378Z 	struct sockaddr *ret;
2025-05-24T14:54:58.5752442Z 	socklen_t socklen;
2025-05-24T14:54:58.5752521Z #ifdef HAVE_SOCKADDR_SA_LEN
2025-05-24T14:54:58.5752586Z 	socklen = sa->sa_len;
2025-05-24T14:54:58.5752643Z #else
2025-05-24T14:54:58.5752740Z 	socklen = sizeof(struct sockaddr_storage);
2025-05-24T14:54:58.5752798Z #endif
2025-05-24T14:54:58.5752867Z 	ret = calloc(1, socklen);
2025-05-24T14:54:58.5752928Z 	if (ret == NULL)
2025-05-24T14:54:58.5753012Z 		return NULL;
2025-05-24T14:54:58.5753136Z 	memcpy(ret, sa, socklen);
2025-05-24T14:54:58.5753241Z 	return ret;
2025-05-24T14:54:58.5753339Z }
2025-05-24T14:54:58.5753436Z #endif
2025-05-24T14:54:58.5753442Z 
2025-05-24T14:54:58.5753556Z #ifdef HAVE_IFACE_IFCONF
2025-05-24T14:54:58.5753565Z 
2025-05-24T14:54:58.5753802Z /* this works for Linux 2.2, Solaris 2.5, SunOS4, HPUX 10.20, OSF1
2025-05-24T14:54:58.5753985Z    V4.0, Ultrix 4.4, SCO Unix 3.2, IRIX 6.4 and FreeBSD 3.2.
2025-05-24T14:54:58.5753991Z 
2025-05-24T14:54:58.5754152Z    It probably also works on any BSD style system.  */
2025-05-24T14:54:58.5754156Z 
2025-05-24T14:54:58.5754254Z int rep_getifaddrs(struct ifaddrs **ifap)
2025-05-24T14:54:58.5754310Z {
2025-05-24T14:54:58.5754374Z 	struct ifconf ifc;
2025-05-24T14:54:58.5754438Z 	char buff[8192];
2025-05-24T14:54:58.5754505Z 	int fd, i, n;
2025-05-24T14:54:58.5754640Z 	struct ifreq *ifr=NULL;
2025-05-24T14:54:58.5754708Z 	struct ifaddrs *curif;
2025-05-24T14:54:58.5754782Z 	struct ifaddrs *lastif = NULL;
2025-05-24T14:54:58.5754790Z 
2025-05-24T14:54:58.5754853Z 	*ifap = NULL;
2025-05-24T14:54:58.5754856Z 
2025-05-24T14:54:58.5755036Z 	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
2025-05-24T14:54:58.5755101Z 		return -1;
2025-05-24T14:54:58.5755162Z 	}
2025-05-24T14:54:58.5755167Z 
2025-05-24T14:54:58.5755242Z 	ifc.ifc_len = sizeof(buff);
2025-05-24T14:54:58.5755307Z 	ifc.ifc_buf = buff;
2025-05-24T14:54:58.5755311Z 
2025-05-24T14:54:58.5755610Z 	if (ioctl(fd, SIOCGIFCONF, &ifc) != 0) {
2025-05-24T14:54:58.5755682Z 		close(fd);
2025-05-24T14:54:58.5755746Z 		return -1;
2025-05-24T14:54:58.5755801Z 	}
2025-05-24T14:54:58.5755811Z 
2025-05-24T14:54:58.5755872Z 	ifr = ifc.ifc_req;
2025-05-24T14:54:58.5755876Z 
2025-05-24T14:54:58.5755959Z 	n = ifc.ifc_len / sizeof(struct ifreq);
2025-05-24T14:54:58.5755963Z 
2025-05-24T14:54:58.5756099Z 	/* Loop through interfaces, looking for given IP address */
2025-05-24T14:54:58.5756182Z 	for (i=n-1; i>=0; i--) {
2025-05-24T14:54:58.5756279Z 		if (ioctl(fd, SIOCGIFFLAGS, &ifr[i]) == -1) {
2025-05-24T14:54:58.5756349Z 			freeifaddrs(*ifap);
2025-05-24T14:54:58.5756414Z 			close(fd);
2025-05-24T14:54:58.5756475Z 			return -1;
2025-05-24T14:54:58.5756535Z 		}
2025-05-24T14:54:58.5756539Z 
2025-05-24T14:54:58.5756628Z 		curif = calloc(1, sizeof(struct ifaddrs));
2025-05-24T14:54:58.5756700Z 		if (curif == NULL) {
2025-05-24T14:54:58.5756766Z 			freeifaddrs(*ifap);
2025-05-24T14:54:58.5756830Z 			close(fd);
2025-05-24T14:54:58.5756894Z 			return -1;
2025-05-24T14:54:58.5756950Z 		}
2025-05-24T14:54:58.5757040Z 		curif->ifa_name = strdup(ifr[i].ifr_name);
2025-05-24T14:54:58.5757113Z 		if (curif->ifa_name == NULL) {
2025-05-24T14:54:58.5757177Z 			free(curif);
2025-05-24T14:54:58.5757243Z 			freeifaddrs(*ifap);
2025-05-24T14:54:58.5757300Z 			close(fd);
2025-05-24T14:54:58.5757363Z 			return -1;
2025-05-24T14:54:58.5757422Z 		}
2025-05-24T14:54:58.5757500Z 		curif->ifa_flags = ifr[i].ifr_flags;
2025-05-24T14:54:58.5757572Z 		curif->ifa_dstaddr = NULL;
2025-05-24T14:54:58.5757643Z 		curif->ifa_data = NULL;
2025-05-24T14:54:58.5757711Z 		curif->ifa_next = NULL;
2025-05-24T14:54:58.5757714Z 
2025-05-24T14:54:58.5757783Z 		curif->ifa_addr = NULL;
2025-05-24T14:54:58.5757880Z 		if (ioctl(fd, SIOCGIFADDR, &ifr[i]) != -1) {
2025-05-24T14:54:58.5757988Z 			curif->ifa_addr = sockaddr_dup(&ifr[i].ifr_addr);
2025-05-24T14:54:58.5758169Z 			if (curif->ifa_addr == NULL) {
2025-05-24T14:54:58.5758242Z 				free(curif->ifa_name);
2025-05-24T14:54:58.5758308Z 				free(curif);
2025-05-24T14:54:58.5758380Z 				freeifaddrs(*ifap);
2025-05-24T14:54:58.5758440Z 				close(fd);
2025-05-24T14:54:58.5758505Z 				return -1;
2025-05-24T14:54:58.5758563Z 			}
2025-05-24T14:54:58.5758619Z 		}
2025-05-24T14:54:58.5758623Z 
2025-05-24T14:54:58.5758693Z 		curif->ifa_netmask = NULL;
2025-05-24T14:54:58.5758794Z 		if (ioctl(fd, SIOCGIFNETMASK, &ifr[i]) != -1) {
2025-05-24T14:54:58.5758909Z 			curif->ifa_netmask = sockaddr_dup(&ifr[i].ifr_addr);
2025-05-24T14:54:58.5758985Z 			if (curif->ifa_netmask == NULL) {
2025-05-24T14:54:58.5759062Z 				if (curif->ifa_addr != NULL) {
2025-05-24T14:54:58.5759132Z 					free(curif->ifa_addr);
2025-05-24T14:54:58.5759189Z 				}
2025-05-24T14:54:58.5759260Z 				free(curif->ifa_name);
2025-05-24T14:54:58.5759322Z 				free(curif);
2025-05-24T14:54:58.5759391Z 				freeifaddrs(*ifap);
2025-05-24T14:54:58.5759449Z 				close(fd);
2025-05-24T14:54:58.5759515Z 				return -1;
2025-05-24T14:54:58.5759571Z 			}
2025-05-24T14:54:58.5759626Z 		}
2025-05-24T14:54:58.5759630Z 
2025-05-24T14:54:58.5759694Z 		if (lastif == NULL) {
2025-05-24T14:54:58.5759762Z 			*ifap = curif;
2025-05-24T14:54:58.5759820Z 		} else {
2025-05-24T14:54:58.5759890Z 			lastif->ifa_next = curif;
2025-05-24T14:54:58.5759949Z 		}
2025-05-24T14:54:58.5760008Z 		lastif = curif;
2025-05-24T14:54:58.5760063Z 	}
2025-05-24T14:54:58.5760067Z 
2025-05-24T14:54:58.5760196Z 	close(fd);
2025-05-24T14:54:58.5760203Z 
2025-05-24T14:54:58.5760260Z 	return 0;
2025-05-24T14:54:58.5760314Z }
2025-05-24T14:54:58.5760318Z 
2025-05-24T14:54:58.5760386Z #define _FOUND_IFACE_ANY
2025-05-24T14:54:58.5760466Z #endif /* HAVE_IFACE_IFCONF */
2025-05-24T14:54:58.5760532Z #ifdef HAVE_IFACE_IFREQ
2025-05-24T14:54:58.5760658Z 
2025-05-24T14:54:58.5760720Z #ifndef I_STR
2025-05-24T14:54:58.5760795Z #include <sys/stropts.h>
2025-05-24T14:54:58.5760854Z #endif
2025-05-24T14:54:58.5760858Z 
2025-05-24T14:54:58.5760949Z /****************************************************************************
2025-05-24T14:54:58.5761062Z this should cover most of the streams based systems
2025-05-24T14:54:58.5761242Z Thanks to Andrej.Borsenkow@mow.siemens.ru for several ideas in this code
2025-05-24T14:54:58.5761325Z ****************************************************************************/
2025-05-24T14:54:58.5761415Z int rep_getifaddrs(struct ifaddrs **ifap)
2025-05-24T14:54:58.5761477Z {
2025-05-24T14:54:58.5761544Z 	struct ifreq ifreq;
2025-05-24T14:54:58.5761614Z 	struct strioctl strioctl;
2025-05-24T14:54:58.5761683Z 	char buff[8192];
2025-05-24T14:54:58.5761743Z 	int fd, i, n;
2025-05-24T14:54:58.5761810Z 	struct ifreq *ifr=NULL;
2025-05-24T14:54:58.5761876Z 	struct ifaddrs *curif;
2025-05-24T14:54:58.5761989Z 	struct ifaddrs *lastif = NULL;
2025-05-24T14:54:58.5761993Z 
2025-05-24T14:54:58.5762053Z 	*ifap = NULL;
2025-05-24T14:54:58.5762058Z 
2025-05-24T14:54:58.5762156Z 	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
2025-05-24T14:54:58.5762219Z 		return -1;
2025-05-24T14:54:58.5762275Z 	}
2025-05-24T14:54:58.5762278Z 
2025-05-24T14:54:58.5762355Z 	strioctl.ic_cmd = SIOCGIFCONF;
2025-05-24T14:54:58.5762424Z 	strioctl.ic_dp  = buff;
2025-05-24T14:54:58.5762504Z 	strioctl.ic_len = sizeof(buff);
2025-05-24T14:54:58.5762585Z 	if (ioctl(fd, I_STR, &strioctl) < 0) {
2025-05-24T14:54:58.5762645Z 		close(fd);
2025-05-24T14:54:58.5762710Z 		return -1;
2025-05-24T14:54:58.5762766Z 	}
2025-05-24T14:54:58.5762771Z 
2025-05-24T14:54:58.5762907Z 	/* we can ignore the possible sizeof(int) here as the resulting
2025-05-24T14:54:58.5763018Z 	   number of interface structures won't change */
2025-05-24T14:54:58.5763105Z 	n = strioctl.ic_len / sizeof(struct ifreq);
2025-05-24T14:54:58.5763109Z 
2025-05-24T14:54:58.5763238Z 	/* we will assume that the kernel returns the length as an int
2025-05-24T14:54:58.5763349Z            at the start of the buffer if the offered size is a
2025-05-24T14:54:58.5763507Z            multiple of the structure size plus an int */
2025-05-24T14:54:58.5763638Z 	if (n*sizeof(struct ifreq) + sizeof(int) == strioctl.ic_len) {
2025-05-24T14:54:58.5763725Z 		ifr = (struct ifreq *)(buff + sizeof(int));
2025-05-24T14:54:58.5763786Z 	} else {
2025-05-24T14:54:58.5763856Z 		ifr = (struct ifreq *)buff;
2025-05-24T14:54:58.5763913Z 	}
2025-05-24T14:54:58.5763916Z 
2025-05-24T14:54:58.5763996Z 	/* Loop through interfaces */
2025-05-24T14:54:58.5763999Z 
2025-05-24T14:54:58.5764065Z 	for (i = 0; i<n; i++) {
2025-05-24T14:54:58.5764127Z 		ifreq = ifr[i];
2025-05-24T14:54:58.5764130Z 
2025-05-24T14:54:58.5764216Z 		curif = calloc(1, sizeof(struct ifaddrs));
2025-05-24T14:54:58.5764283Z 		if (lastif == NULL) {
2025-05-24T14:54:58.5764341Z 			*ifap = curif;
2025-05-24T14:54:58.5764397Z 		} else {
2025-05-24T14:54:58.5764468Z 			lastif->ifa_next = curif;
2025-05-24T14:54:58.5764525Z 		}
2025-05-24T14:54:58.5764528Z 
2025-05-24T14:54:58.5764604Z 		strioctl.ic_cmd = SIOCGIFFLAGS;
2025-05-24T14:54:58.5764682Z 		strioctl.ic_dp  = (char *)&ifreq;
2025-05-24T14:54:58.5764764Z 		strioctl.ic_len = sizeof(struct ifreq);
2025-05-24T14:54:58.5764842Z 		if (ioctl(fd, I_STR, &strioctl) != 0) {
2025-05-24T14:54:58.5764909Z 			freeifaddrs(*ifap);
2025-05-24T14:54:58.5764968Z 			return -1;
2025-05-24T14:54:58.5765023Z 		}
2025-05-24T14:54:58.5765027Z 
2025-05-24T14:54:58.5765105Z 		curif->ifa_flags = ifreq.ifr_flags;
2025-05-24T14:54:58.5765159Z 		
2025-05-24T14:54:58.5765232Z 		strioctl.ic_cmd = SIOCGIFADDR;
2025-05-24T14:54:58.5765525Z 		strioctl.ic_dp  = (char *)&ifreq;
2025-05-24T14:54:58.5765647Z 		strioctl.ic_len = sizeof(struct ifreq);
2025-05-24T14:54:58.5765728Z 		if (ioctl(fd, I_STR, &strioctl) != 0) {
2025-05-24T14:54:58.5765798Z 			freeifaddrs(*ifap);
2025-05-24T14:54:58.5765882Z 			return -1;
2025-05-24T14:54:58.5765982Z 		}
2025-05-24T14:54:58.5766161Z 
2025-05-24T14:54:58.5766336Z 		curif->ifa_name = strdup(ifreq.ifr_name);
2025-05-24T14:54:58.5766512Z 		curif->ifa_addr = sockaddr_dup(&ifreq.ifr_addr);
2025-05-24T14:54:58.5766639Z 		curif->ifa_dstaddr = NULL;
2025-05-24T14:54:58.5766752Z 		curif->ifa_data = NULL;
2025-05-24T14:54:58.5766870Z 		curif->ifa_next = NULL;
2025-05-24T14:54:58.5766985Z 		curif->ifa_netmask = NULL;
2025-05-24T14:54:58.5766991Z 
2025-05-24T14:54:58.5767123Z 		strioctl.ic_cmd = SIOCGIFNETMASK;
2025-05-24T14:54:58.5767250Z 		strioctl.ic_dp  = (char *)&ifreq;
2025-05-24T14:54:58.5767389Z 		strioctl.ic_len = sizeof(struct ifreq);
2025-05-24T14:54:58.5767523Z 		if (ioctl(fd, I_STR, &strioctl) != 0) {
2025-05-24T14:54:58.5767644Z 			freeifaddrs(*ifap);
2025-05-24T14:54:58.5767745Z 			return -1;
2025-05-24T14:54:58.5767836Z 		}
2025-05-24T14:54:58.5767842Z 
2025-05-24T14:54:58.5768025Z 		curif->ifa_netmask = sockaddr_dup(&ifreq.ifr_addr);
2025-05-24T14:54:58.5768030Z 
2025-05-24T14:54:58.5768136Z 		lastif = curif;
2025-05-24T14:54:58.5768233Z 	}
2025-05-24T14:54:58.5768239Z 
2025-05-24T14:54:58.5768337Z 	close(fd);
2025-05-24T14:54:58.5768346Z 
2025-05-24T14:54:58.5768446Z 	return 0;
2025-05-24T14:54:58.5768536Z }
2025-05-24T14:54:58.5768541Z 
2025-05-24T14:54:58.5768654Z #define _FOUND_IFACE_ANY
2025-05-24T14:54:58.5768775Z #endif /* HAVE_IFACE_IFREQ */
2025-05-24T14:54:58.5768884Z #ifdef HAVE_IFACE_AIX
2025-05-24T14:54:58.5768889Z 
2025-05-24T14:54:58.5769027Z /****************************************************************************
2025-05-24T14:54:58.5769151Z this one is for AIX (tested on 4.2)
2025-05-24T14:54:58.5769290Z ****************************************************************************/
2025-05-24T14:54:58.5769448Z int rep_getifaddrs(struct ifaddrs **ifap)
2025-05-24T14:54:58.5769527Z {
2025-05-24T14:54:58.5769593Z 	char buff[8192];
2025-05-24T14:54:58.5769650Z 	int fd, i;
2025-05-24T14:54:58.5769713Z 	struct ifconf ifc;
2025-05-24T14:54:58.5769782Z 	struct ifreq *ifr=NULL;
2025-05-24T14:54:58.5769853Z 	struct ifaddrs *curif;
2025-05-24T14:54:58.5769926Z 	struct ifaddrs *lastif = NULL;
2025-05-24T14:54:58.5769930Z 
2025-05-24T14:54:58.5770066Z 	*ifap = NULL;
2025-05-24T14:54:58.5770070Z 
2025-05-24T14:54:58.5770171Z 	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
2025-05-24T14:54:58.5770230Z 		return -1;
2025-05-24T14:54:58.5770285Z 	}
2025-05-24T14:54:58.5770289Z 
2025-05-24T14:54:58.5770359Z 	ifc.ifc_len = sizeof(buff);
2025-05-24T14:54:58.5770422Z 	ifc.ifc_buf = buff;
2025-05-24T14:54:58.5770426Z 
2025-05-24T14:54:58.5770508Z 	if (ioctl(fd, SIOCGIFCONF, &ifc) != 0) {
2025-05-24T14:54:58.5770566Z 		close(fd);
2025-05-24T14:54:58.5770628Z 		return -1;
2025-05-24T14:54:58.5770685Z 	}
2025-05-24T14:54:58.5770689Z 
2025-05-24T14:54:58.5770750Z 	ifr = ifc.ifc_req;
2025-05-24T14:54:58.5770753Z 
2025-05-24T14:54:58.5770832Z 	/* Loop through interfaces */
2025-05-24T14:54:58.5770891Z 	i = ifc.ifc_len;
2025-05-24T14:54:58.5770894Z 
2025-05-24T14:54:58.5770954Z 	while (i > 0) {
2025-05-24T14:54:58.5771027Z 		unsigned int inc;
2025-05-24T14:54:58.5771030Z 
2025-05-24T14:54:58.5771104Z 		inc = ifr->ifr_addr.sa_len;
2025-05-24T14:54:58.5771109Z 
2025-05-24T14:54:58.5771191Z 		if (ioctl(fd, SIOCGIFADDR, ifr) != 0) {
2025-05-24T14:54:58.5771261Z 			freeaddrinfo(*ifap);
2025-05-24T14:54:58.5771328Z 			return -1;
2025-05-24T14:54:58.5771382Z 		}
2025-05-24T14:54:58.5771386Z 
2025-05-24T14:54:58.5771478Z 		curif = calloc(1, sizeof(struct ifaddrs));
2025-05-24T14:54:58.5771546Z 		if (lastif == NULL) {
2025-05-24T14:54:58.5771609Z 			*ifap = curif;
2025-05-24T14:54:58.5771665Z 		} else {
2025-05-24T14:54:58.5771739Z 			lastif->ifa_next = curif;
2025-05-24T14:54:58.5771796Z 		}
2025-05-24T14:54:58.5771863Z 
2025-05-24T14:54:58.5771949Z 		curif->ifa_name = strdup(ifr->ifr_name);
2025-05-24T14:54:58.5772051Z 		curif->ifa_addr = sockaddr_dup(&ifr->ifr_addr);
2025-05-24T14:54:58.5772126Z 		curif->ifa_dstaddr = NULL;
2025-05-24T14:54:58.5772192Z 		curif->ifa_data = NULL;
2025-05-24T14:54:58.5772260Z 		curif->ifa_netmask = NULL;
2025-05-24T14:54:58.5772409Z 		curif->ifa_next = NULL;
2025-05-24T14:54:58.5772414Z 
2025-05-24T14:54:58.5772498Z 		if (ioctl(fd, SIOCGIFFLAGS, ifr) != 0) {
2025-05-24T14:54:58.5772567Z 			freeaddrinfo(*ifap);
2025-05-24T14:54:58.5772626Z 			return -1;
2025-05-24T14:54:58.5772686Z 		}
2025-05-24T14:54:58.5772689Z 
2025-05-24T14:54:58.5772765Z 		curif->ifa_flags = ifr->ifr_flags;
2025-05-24T14:54:58.5772769Z 
2025-05-24T14:54:58.5772855Z 		if (ioctl(fd, SIOCGIFNETMASK, ifr) != 0) {
2025-05-24T14:54:58.5772923Z 			freeaddrinfo(*ifap);
2025-05-24T14:54:58.5772979Z 			return -1;
2025-05-24T14:54:58.5773033Z 		}
2025-05-24T14:54:58.5773036Z 
2025-05-24T14:54:58.5773143Z 		curif->ifa_netmask = sockaddr_dup(&ifr->ifr_addr);
2025-05-24T14:54:58.5773149Z 
2025-05-24T14:54:58.5773209Z 		lastif = curif;
2025-05-24T14:54:58.5773213Z 
2025-05-24T14:54:58.5773267Z 	next:
2025-05-24T14:54:58.5773320Z 		/*
2025-05-24T14:54:58.5773438Z 		 * Patch from Archie Cobbs (archie@whistle.com).  The
2025-05-24T14:54:58.5773552Z 		 * addresses in the SIOCGIFCONF interface list have a
2025-05-24T14:54:58.5773663Z 		 * minimum size. Usually this doesn't matter, but if
2025-05-24T14:54:58.5773772Z 		 * your machine has tunnel interfaces, etc. that have
2025-05-24T14:54:58.5773880Z 		 * a zero length "link address", this does matter.  */
2025-05-24T14:54:58.5773884Z 
2025-05-24T14:54:58.5773960Z 		if (inc < sizeof(ifr->ifr_addr))
2025-05-24T14:54:58.5774033Z 			inc = sizeof(ifr->ifr_addr);
2025-05-24T14:54:58.5774094Z 		inc += IFNAMSIZ;
2025-05-24T14:54:58.5774098Z 
2025-05-24T14:54:58.5774186Z 		ifr = (struct ifreq*) (((char*) ifr) + inc);
2025-05-24T14:54:58.5774251Z 		i -= inc;
2025-05-24T14:54:58.5774313Z 	}
2025-05-24T14:54:58.5774319Z 
2025-05-24T14:54:58.5774378Z 	close(fd);
2025-05-24T14:54:58.5774437Z 	return 0;
2025-05-24T14:54:58.5774498Z }
2025-05-24T14:54:58.5774502Z 
2025-05-24T14:54:58.5774574Z #define _FOUND_IFACE_ANY
2025-05-24T14:54:58.5774645Z #endif /* HAVE_IFACE_AIX */
2025-05-24T14:54:58.5774717Z #ifndef _FOUND_IFACE_ANY
2025-05-24T14:54:58.5774812Z int rep_getifaddrs(struct ifaddrs **ifap)
2025-05-24T14:54:58.5774868Z {
2025-05-24T14:54:58.5774979Z 	errno = ENOSYS;
2025-05-24T14:54:58.5775044Z 	return -1;
2025-05-24T14:54:58.5775100Z }
2025-05-24T14:54:58.5775155Z #endif
2025-05-24T14:54:58.5775217Z -------------------
2025-05-24T14:54:58.5775300Z Content of lib/replace/inet_aton.c:
2025-05-24T14:54:58.5775493Z /*
2025-05-24T14:54:58.5775576Z  * Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5775649Z  * replacement functions
2025-05-24T14:54:58.5775762Z  * Copyright (C) Michael Adam <obnox@samba.org> 2008
2025-05-24T14:54:58.5775817Z  *
2025-05-24T14:54:58.5775942Z  *  ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5776084Z  *  ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5776149Z  *  ** under the LGPL
2025-05-24T14:54:58.5776203Z  *
2025-05-24T14:54:58.5776347Z  * This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5776479Z  * modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5776621Z  * License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5776771Z  * version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5776826Z  *
2025-05-24T14:54:58.5776966Z  * This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5777103Z  * but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5777276Z  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5777380Z  * Lesser General Public License for more details.
2025-05-24T14:54:58.5777436Z  *
2025-05-24T14:54:58.5777658Z  * You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5777844Z  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5777902Z  */
2025-05-24T14:54:58.5777906Z 
2025-05-24T14:54:58.5777976Z #include "replace.h"
2025-05-24T14:54:58.5778158Z #include "system/network.h"
2025-05-24T14:54:58.5778162Z 
2025-05-24T14:54:58.5778219Z /**
2025-05-24T14:54:58.5778351Z  * We know that we have inet_pton from earlier libreplace checks.
2025-05-24T14:54:58.5778410Z  */
2025-05-24T14:54:58.5778525Z int rep_inet_aton(const char *src, struct in_addr *dst)
2025-05-24T14:54:58.5778581Z {
2025-05-24T14:54:58.5778686Z 	return (inet_pton(AF_INET, src, dst) > 0) ? 1 : 0;
2025-05-24T14:54:58.5778741Z }
2025-05-24T14:54:58.5778819Z -------------------
2025-05-24T14:54:58.5778964Z Content of lib/replace/inet_ntoa.c:
2025-05-24T14:54:58.5779072Z /*
2025-05-24T14:54:58.5779204Z  * Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5779350Z  * replacement routines for broken systems
2025-05-24T14:54:58.5779489Z  * Copyright (C) Andrew Tridgell 2003
2025-05-24T14:54:58.5779613Z  * Copyright (C) Michael Adam 2008
2025-05-24T14:54:58.5779703Z  *
2025-05-24T14:54:58.5779906Z  *  ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5780086Z  *  ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5780153Z  *  ** under the LGPL
2025-05-24T14:54:58.5780212Z  *
2025-05-24T14:54:58.5780354Z  * This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5780489Z  * modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5780627Z  * License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5780765Z  * version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5780824Z  *
2025-05-24T14:54:58.5780967Z  * This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5781103Z  * but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5781278Z  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5781381Z  * Lesser General Public License for more details.
2025-05-24T14:54:58.5781436Z  *
2025-05-24T14:54:58.5781587Z  * You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5781772Z  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5781911Z  */
2025-05-24T14:54:58.5781915Z 
2025-05-24T14:54:58.5781984Z #include "replace.h"
2025-05-24T14:54:58.5782062Z #include "system/network.h"
2025-05-24T14:54:58.5782066Z 
2025-05-24T14:54:58.5782121Z /**
2025-05-24T14:54:58.5782231Z  * NOTE: this is not thread safe, but it can't be, either
2025-05-24T14:54:58.5782328Z  * since it returns a pointer to static memory.
2025-05-24T14:54:58.5782387Z  */
2025-05-24T14:54:58.5782471Z char *rep_inet_ntoa(struct in_addr ip)
2025-05-24T14:54:58.5782527Z {
2025-05-24T14:54:58.5782607Z 	uint8_t *p = (uint8_t *)&ip.s_addr;
2025-05-24T14:54:58.5782674Z 	static char buf[18];
2025-05-24T14:54:58.5782748Z 	slprintf(buf, 17, "%d.%d.%d.%d",
2025-05-24T14:54:58.5782841Z 		 (int)p[0], (int)p[1], (int)p[2], (int)p[3]);
2025-05-24T14:54:58.5782903Z 	return buf;
2025-05-24T14:54:58.5782959Z }
2025-05-24T14:54:58.5783022Z -------------------
2025-05-24T14:54:58.5783106Z Content of lib/replace/inet_ntop.c:
2025-05-24T14:54:58.5783161Z /*
2025-05-24T14:54:58.5783280Z  * Copyright (C) 1996-2001  Internet Software Consortium.
2025-05-24T14:54:58.5783339Z  *
2025-05-24T14:54:58.5783498Z  * Permission to use, copy, modify, and distribute this software for any
2025-05-24T14:54:58.5783657Z  * purpose with or without fee is hereby granted, provided that the above
2025-05-24T14:54:58.5783813Z  * copyright notice and this permission notice appear in all copies.
2025-05-24T14:54:58.5783868Z  *
2025-05-24T14:54:58.5784012Z  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
2025-05-24T14:54:58.5784215Z  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
2025-05-24T14:54:58.5784382Z  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
2025-05-24T14:54:58.5784529Z  * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
2025-05-24T14:54:58.5784785Z  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
2025-05-24T14:54:58.5784937Z  * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
2025-05-24T14:54:58.5785093Z  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
2025-05-24T14:54:58.5785195Z  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
2025-05-24T14:54:58.5785255Z  */
2025-05-24T14:54:58.5785258Z 
2025-05-24T14:54:58.5785262Z 
2025-05-24T14:54:58.5785330Z #include "replace.h"
2025-05-24T14:54:58.5785528Z #include "system/network.h"
2025-05-24T14:54:58.5785533Z 
2025-05-24T14:54:58.5785601Z #define NS_INT16SZ	 2
2025-05-24T14:54:58.5785673Z #define NS_IN6ADDRSZ	16
2025-05-24T14:54:58.5785676Z 
2025-05-24T14:54:58.5785734Z /*
2025-05-24T14:54:58.5785885Z  * WARNING: Don't even consider trying to compile this on a system where
2025-05-24T14:54:58.5786025Z  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
2025-05-24T14:54:58.5786080Z  */
2025-05-24T14:54:58.5786083Z 
2025-05-24T14:54:58.5786234Z static const char *inet_ntop4(const unsigned char *src, char *dst,
2025-05-24T14:54:58.5786307Z 			      socklen_t size);
2025-05-24T14:54:58.5786312Z 
2025-05-24T14:54:58.5786374Z #ifdef AF_INET6
2025-05-24T14:54:58.5786514Z static const char *inet_ntop6(const unsigned char *src, char *dst,
2025-05-24T14:54:58.5786580Z 			      socklen_t size);
2025-05-24T14:54:58.5786637Z #endif
2025-05-24T14:54:58.5786641Z 
2025-05-24T14:54:58.5786695Z /* char *
2025-05-24T14:54:58.5786768Z  * isc_net_ntop(af, src, dst, size)
2025-05-24T14:54:58.5786901Z  *	convert a network format address to presentation format.
2025-05-24T14:54:58.5786958Z  * return:
2025-05-24T14:54:58.5787113Z  *	pointer to presentation format address (`dst'), or NULL (see errno).
2025-05-24T14:54:58.5787176Z  * author:
2025-05-24T14:54:58.5787243Z  *	Paul Vixie, 1996.
2025-05-24T14:54:58.5787298Z  */
2025-05-24T14:54:58.5787358Z const char *
2025-05-24T14:54:58.5787500Z rep_inet_ntop(int af, const void *src, char *dst, socklen_t size)
2025-05-24T14:54:58.5787558Z {
2025-05-24T14:54:58.5787623Z 	switch (af) {
2025-05-24T14:54:58.5787687Z 	case AF_INET:
2025-05-24T14:54:58.5787767Z 		return (inet_ntop4(src, dst, size));
2025-05-24T14:54:58.5787900Z #ifdef AF_INET6
2025-05-24T14:54:58.5787960Z 	case AF_INET6:
2025-05-24T14:54:58.5788041Z 		return (inet_ntop6(src, dst, size));
2025-05-24T14:54:58.5788096Z #endif
2025-05-24T14:54:58.5788155Z 	default:
2025-05-24T14:54:58.5788226Z 		errno = EAFNOSUPPORT;
2025-05-24T14:54:58.5788292Z 		return (NULL);
2025-05-24T14:54:58.5788347Z 	}
2025-05-24T14:54:58.5788411Z 	/* NOTREACHED */
2025-05-24T14:54:58.5788470Z }
2025-05-24T14:54:58.5788474Z 
2025-05-24T14:54:58.5788535Z /* const char *
2025-05-24T14:54:58.5788609Z  * inet_ntop4(src, dst, size)
2025-05-24T14:54:58.5788676Z  *	format an IPv4 address
2025-05-24T14:54:58.5788740Z  * return:
2025-05-24T14:54:58.5788803Z  *	`dst' (as a const)
2025-05-24T14:54:58.5788863Z  * author:
2025-05-24T14:54:58.5788933Z  *	Paul Vixie, 1996.
2025-05-24T14:54:58.5788989Z  */
2025-05-24T14:54:58.5789056Z static const char *
2025-05-24T14:54:58.5789204Z inet_ntop4(const unsigned char *src, char *dst, socklen_t size)
2025-05-24T14:54:58.5789268Z {
2025-05-24T14:54:58.5789344Z 	char tmp[sizeof("255.255.255.255")];
2025-05-24T14:54:58.5789404Z 	size_t len;
2025-05-24T14:54:58.5789408Z 
2025-05-24T14:54:58.5789477Z 	len = snprintf(tmp,
2025-05-24T14:54:58.5789541Z 		       sizeof(tmp),
2025-05-24T14:54:58.5789610Z 		       "%hhu.%hhu.%hhu.%hhu",
2025-05-24T14:54:58.5789667Z 		       src[0],
2025-05-24T14:54:58.5789728Z 		       src[1],
2025-05-24T14:54:58.5789783Z 		       src[2],
2025-05-24T14:54:58.5789841Z 		       src[3]);
2025-05-24T14:54:58.5789905Z 	if (len >= size) {
2025-05-24T14:54:58.5790033Z 		errno = ENOSPC;
2025-05-24T14:54:58.5790094Z 		return (NULL);
2025-05-24T14:54:58.5790150Z 	}
2025-05-24T14:54:58.5790226Z 	memcpy(dst, tmp, len + 1);
2025-05-24T14:54:58.5790230Z 
2025-05-24T14:54:58.5790291Z 	return (dst);
2025-05-24T14:54:58.5790354Z }
2025-05-24T14:54:58.5790358Z 
2025-05-24T14:54:58.5790524Z /* const char *
2025-05-24T14:54:58.5790600Z  * isc_inet_ntop6(src, dst, size)
2025-05-24T14:54:58.5790759Z  *	convert IPv6 binary address into presentation (printable) format
2025-05-24T14:54:58.5790822Z  * author:
2025-05-24T14:54:58.5790886Z  *	Paul Vixie, 1996.
2025-05-24T14:54:58.5790942Z  */
2025-05-24T14:54:58.5791002Z #ifdef AF_INET6
2025-05-24T14:54:58.5791067Z static const char *
2025-05-24T14:54:58.5791203Z inet_ntop6(const unsigned char *src, char *dst, socklen_t size)
2025-05-24T14:54:58.5791258Z {
2025-05-24T14:54:58.5791310Z 	/*
2025-05-24T14:54:58.5791498Z 	 * Note that int32_t and int16_t need only be "at least" large enough
2025-05-24T14:54:58.5791753Z 	 * to contain a value of the specified size.  On some systems, like
2025-05-24T14:54:58.5791999Z 	 * Crays, there is no such thing as an integer variable with 16 bits.
2025-05-24T14:54:58.5792245Z 	 * Keep this in mind if you think this function should have been coded
2025-05-24T14:54:58.5792430Z 	 * to use pointer overlays.  All the world's not a VAX.
2025-05-24T14:54:58.5792526Z 	 */
2025-05-24T14:54:58.5792694Z 	char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
2025-05-24T14:54:58.5792775Z 	struct { int base, len; } best, cur;
2025-05-24T14:54:58.5792878Z 	unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];
2025-05-24T14:54:58.5792938Z 	int i, inc;
2025-05-24T14:54:58.5792942Z 
2025-05-24T14:54:58.5793003Z 	/*
2025-05-24T14:54:58.5793067Z 	 * Preprocess:
2025-05-24T14:54:58.5793184Z 	 *	Copy the input (bytewise) array into a wordwise array.
2025-05-24T14:54:58.5793333Z 	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
2025-05-24T14:54:58.5793389Z 	 */
2025-05-24T14:54:58.5793467Z 	memset(words, '\0', sizeof words);
2025-05-24T14:54:58.5793540Z 	for (i = 0; i < NS_IN6ADDRSZ; i++)
2025-05-24T14:54:58.5793641Z 		words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
2025-05-24T14:54:58.5793705Z 	best.base = -1;
2025-05-24T14:54:58.5793764Z 	best.len = 0;
2025-05-24T14:54:58.5793829Z 	cur.base = -1;
2025-05-24T14:54:58.5793890Z 	cur.len = 0;
2025-05-24T14:54:58.5793988Z 	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
2025-05-24T14:54:58.5794112Z 		if (words[i] == 0) {
2025-05-24T14:54:58.5794183Z 			if (cur.base == -1)
2025-05-24T14:54:58.5794256Z 				cur.base = i, cur.len = 1;
2025-05-24T14:54:58.5794313Z 			else
2025-05-24T14:54:58.5794379Z 				cur.len++;
2025-05-24T14:54:58.5794436Z 		} else {
2025-05-24T14:54:58.5794504Z 			if (cur.base != -1) {
2025-05-24T14:54:58.5794594Z 				if (best.base == -1 || cur.len > best.len)
2025-05-24T14:54:58.5794657Z 					best = cur;
2025-05-24T14:54:58.5794720Z 				cur.base = -1;
2025-05-24T14:54:58.5794776Z 			}
2025-05-24T14:54:58.5794834Z 		}
2025-05-24T14:54:58.5794893Z 	}
2025-05-24T14:54:58.5794957Z 	if (cur.base != -1) {
2025-05-24T14:54:58.5795042Z 		if (best.base == -1 || cur.len > best.len)
2025-05-24T14:54:58.5795106Z 			best = cur;
2025-05-24T14:54:58.5795160Z 	}
2025-05-24T14:54:58.5795237Z 	if (best.base != -1 && best.len < 2)
2025-05-24T14:54:58.5795311Z 		best.base = -1;
2025-05-24T14:54:58.5795315Z 
2025-05-24T14:54:58.5795529Z 	/*
2025-05-24T14:54:58.5795641Z 	 * Format the result.
2025-05-24T14:54:58.5795703Z 	 */
2025-05-24T14:54:58.5795769Z 	tp = tmp;
2025-05-24T14:54:58.5795865Z 	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
2025-05-24T14:54:58.5795955Z 		/* Are we inside the best run of 0x00's? */
2025-05-24T14:54:58.5796038Z 		if (best.base != -1 && i >= best.base &&
2025-05-24T14:54:58.5796113Z 		    i < (best.base + best.len)) {
2025-05-24T14:54:58.5796176Z 			if (i == best.base)
2025-05-24T14:54:58.5796237Z 				*tp++ = ':';
2025-05-24T14:54:58.5796297Z 			continue;
2025-05-24T14:54:58.5796351Z 		}
2025-05-24T14:54:58.5796566Z 		/* Are we following an initial run of 0x00s or any real hex? */
2025-05-24T14:54:58.5796627Z 		if (i != 0)
2025-05-24T14:54:58.5796688Z 			*tp++ = ':';
2025-05-24T14:54:58.5796777Z 		/* Is this address an encapsulated IPv4? */
2025-05-24T14:54:58.5796848Z 		if (i == 6 && best.base == 0 &&
2025-05-24T14:54:58.5797063Z 		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
2025-05-24T14:54:58.5797180Z 			if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
2025-05-24T14:54:58.5797251Z 				return (NULL);
2025-05-24T14:54:58.5797318Z 			tp += strlen(tp);
2025-05-24T14:54:58.5797375Z 			break;
2025-05-24T14:54:58.5797431Z 		}
2025-05-24T14:54:58.5797512Z 		inc = snprintf(tp, 5, "%x", words[i]);
2025-05-24T14:54:58.5797574Z 		if (inc >= 5) {
2025-05-24T14:54:58.5797633Z 			abort();
2025-05-24T14:54:58.5797687Z 		}
2025-05-24T14:54:58.5797749Z 		tp += inc;
2025-05-24T14:54:58.5797806Z 	}
2025-05-24T14:54:58.5797886Z 	/* Was it a trailing run of 0x00's? */
2025-05-24T14:54:58.5797983Z 	if (best.base != -1 && (best.base + best.len) ==
2025-05-24T14:54:58.5798065Z 	    (NS_IN6ADDRSZ / NS_INT16SZ))
2025-05-24T14:54:58.5798124Z 		*tp++ = ':';
2025-05-24T14:54:58.5798182Z 	*tp++ = '\0';
2025-05-24T14:54:58.5798186Z 
2025-05-24T14:54:58.5798246Z 	/*
2025-05-24T14:54:58.5798332Z 	 * Check for overflow, copy, and we're done.
2025-05-24T14:54:58.5798391Z 	 */
2025-05-24T14:54:58.5798463Z 	if ((size_t)(tp - tmp) > size) {
2025-05-24T14:54:58.5798531Z 		errno = ENOSPC;
2025-05-24T14:54:58.5798593Z 		return (NULL);
2025-05-24T14:54:58.5798647Z 	}
2025-05-24T14:54:58.5798728Z 	memcpy(dst, tmp, tp - tmp);
2025-05-24T14:54:58.5798788Z 	return (dst);
2025-05-24T14:54:58.5798842Z }
2025-05-24T14:54:58.5798907Z #endif /* AF_INET6 */
2025-05-24T14:54:58.5798972Z -------------------
2025-05-24T14:54:58.5799051Z Content of lib/replace/inet_pton.c:
2025-05-24T14:54:58.5799108Z /*
2025-05-24T14:54:58.5799234Z  * Copyright (C) 1996-2001  Internet Software Consortium.
2025-05-24T14:54:58.5799289Z  *
2025-05-24T14:54:58.5799450Z  * Permission to use, copy, modify, and distribute this software for any
2025-05-24T14:54:58.5799609Z  * purpose with or without fee is hereby granted, provided that the above
2025-05-24T14:54:58.5799768Z  * copyright notice and this permission notice appear in all copies.
2025-05-24T14:54:58.5799824Z  *
2025-05-24T14:54:58.5799970Z  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
2025-05-24T14:54:58.5800129Z  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
2025-05-24T14:54:58.5800366Z  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
2025-05-24T14:54:58.5800514Z  * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
2025-05-24T14:54:58.5800676Z  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
2025-05-24T14:54:58.5800822Z  * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
2025-05-24T14:54:58.5800974Z  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
2025-05-24T14:54:58.5801075Z  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
2025-05-24T14:54:58.5801133Z  */
2025-05-24T14:54:58.5801137Z 
2025-05-24T14:54:58.5801203Z #include "replace.h"
2025-05-24T14:54:58.5801273Z #include "system/network.h"
2025-05-24T14:54:58.5801277Z 
2025-05-24T14:54:58.5801346Z #define NS_INT16SZ	 2
2025-05-24T14:54:58.5801416Z #define NS_INADDRSZ	 4
2025-05-24T14:54:58.5801483Z #define NS_IN6ADDRSZ	16
2025-05-24T14:54:58.5801486Z 
2025-05-24T14:54:58.5801548Z /*
2025-05-24T14:54:58.5801699Z  * WARNING: Don't even consider trying to compile this on a system where
2025-05-24T14:54:58.5801834Z  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
2025-05-24T14:54:58.5801887Z  */
2025-05-24T14:54:58.5801895Z 
2025-05-24T14:54:58.5802026Z static int inet_pton4(const char *src, unsigned char *dst);
2025-05-24T14:54:58.5802088Z #ifdef AF_INET6
2025-05-24T14:54:58.5802206Z static int inet_pton6(const char *src, unsigned char *dst);
2025-05-24T14:54:58.5802267Z #endif
2025-05-24T14:54:58.5802316Z 
2025-05-24T14:54:58.5802378Z /* int
2025-05-24T14:54:58.5802448Z  * inet_pton(af, src, dst)
2025-05-24T14:54:58.5802622Z  *	convert from presentation format (which usually means ASCII printable)
2025-05-24T14:54:58.5802763Z  *	to network format (which is usually some kind of binary format).
2025-05-24T14:54:58.5802896Z  * return:
2025-05-24T14:54:58.5803020Z  *	1 if the address was valid for the specified address family
2025-05-24T14:54:58.5803157Z  *	0 if the address wasn't valid (`dst' is untouched in this case)
2025-05-24T14:54:58.5803305Z  *	-1 if some other error occurred (`dst' is untouched in this case, too)
2025-05-24T14:54:58.5803362Z  * author:
2025-05-24T14:54:58.5803430Z  *	Paul Vixie, 1996.
2025-05-24T14:54:58.5803486Z  */
2025-05-24T14:54:58.5803540Z int
2025-05-24T14:54:58.5803607Z rep_inet_pton(int af,
2025-05-24T14:54:58.5803672Z 	  const char *src,
2025-05-24T14:54:58.5803730Z 	  void *dst)
2025-05-24T14:54:58.5803783Z {
2025-05-24T14:54:58.5803847Z 	switch (af) {
2025-05-24T14:54:58.5803908Z 	case AF_INET:
2025-05-24T14:54:58.5803985Z 		return (inet_pton4(src, dst));
2025-05-24T14:54:58.5804043Z #ifdef AF_INET6
2025-05-24T14:54:58.5804107Z 	case AF_INET6:
2025-05-24T14:54:58.5804180Z 		return (inet_pton6(src, dst));
2025-05-24T14:54:58.5804274Z #endif
2025-05-24T14:54:58.5804387Z 	default:
2025-05-24T14:54:58.5804512Z 		errno = EAFNOSUPPORT;
2025-05-24T14:54:58.5804616Z 		return (-1);
2025-05-24T14:54:58.5804708Z 	}
2025-05-24T14:54:58.5804821Z 	/* NOTREACHED */
2025-05-24T14:54:58.5804912Z }
2025-05-24T14:54:58.5804918Z 
2025-05-24T14:54:58.5805008Z /* int
2025-05-24T14:54:58.5805123Z  * inet_pton4(src, dst)
2025-05-24T14:54:58.5805531Z  *	like inet_aton() but without all the hexadecimal and shorthand.
2025-05-24T14:54:58.5805610Z  * return:
2025-05-24T14:54:58.5805703Z  *	1 if `src' is a valid dotted quad, else 0.
2025-05-24T14:54:58.5805764Z  * notice:
2025-05-24T14:54:58.5805862Z  *	does not touch `dst' unless it's returning 1.
2025-05-24T14:54:58.5805917Z  * author:
2025-05-24T14:54:58.5805988Z  *	Paul Vixie, 1996.
2025-05-24T14:54:58.5806044Z  */
2025-05-24T14:54:58.5806101Z static int
2025-05-24T14:54:58.5806164Z inet_pton4(src, dst)
2025-05-24T14:54:58.5806231Z 	const char *src;
2025-05-24T14:54:58.5806296Z 	unsigned char *dst;
2025-05-24T14:54:58.5806350Z {
2025-05-24T14:54:58.5806438Z 	static const char digits[] = "0123456789";
2025-05-24T14:54:58.5806513Z 	int saw_digit, octets, ch;
2025-05-24T14:54:58.5806596Z 	unsigned char tmp[NS_INADDRSZ], *tp;
2025-05-24T14:54:58.5806688Z 
2025-05-24T14:54:58.5806753Z 	saw_digit = 0;
2025-05-24T14:54:58.5806816Z 	octets = 0;
2025-05-24T14:54:58.5806878Z 	*(tp = tmp) = 0;
2025-05-24T14:54:58.5806946Z 	while ((ch = *src++) != '\0') {
2025-05-24T14:54:58.5807015Z 		const char *pch;
2025-05-24T14:54:58.5807019Z 
2025-05-24T14:54:58.5807103Z 		if ((pch = strchr(digits, ch)) != NULL) {
2025-05-24T14:54:58.5807199Z 			unsigned int new = *tp * 10 + (pch - digits);
2025-05-24T14:54:58.5807204Z 
2025-05-24T14:54:58.5807264Z 			if (new > 255)
2025-05-24T14:54:58.5807330Z 				return (0);
2025-05-24T14:54:58.5807389Z 			*tp = new;
2025-05-24T14:54:58.5807452Z 			if (! saw_digit) {
2025-05-24T14:54:58.5807522Z 				if (++octets > 4)
2025-05-24T14:54:58.5807582Z 					return (0);
2025-05-24T14:54:58.5807642Z 				saw_digit = 1;
2025-05-24T14:54:58.5807696Z 			}
2025-05-24T14:54:58.5807778Z 		} else if (ch == '.' && saw_digit) {
2025-05-24T14:54:58.5807840Z 			if (octets == 4)
2025-05-24T14:54:58.5807903Z 				return (0);
2025-05-24T14:54:58.5807965Z 			*++tp = 0;
2025-05-24T14:54:58.5808025Z 			saw_digit = 0;
2025-05-24T14:54:58.5808081Z 		} else
2025-05-24T14:54:58.5808139Z 			return (0);
2025-05-24T14:54:58.5808199Z 	}
2025-05-24T14:54:58.5808258Z 	if (octets < 4)
2025-05-24T14:54:58.5808316Z 		return (0);
2025-05-24T14:54:58.5808392Z 	memcpy(dst, tmp, NS_INADDRSZ);
2025-05-24T14:54:58.5808456Z 	return (1);
2025-05-24T14:54:58.5808511Z }
2025-05-24T14:54:58.5808515Z 
2025-05-24T14:54:58.5808570Z /* int
2025-05-24T14:54:58.5808642Z  * inet_pton6(src, dst)
2025-05-24T14:54:58.5808883Z  *	convert presentation level address to network order binary form.
2025-05-24T14:54:58.5808940Z  * return:
2025-05-24T14:54:58.5809047Z  *	1 if `src' is a valid [RFC1884 2.2] address, else 0.
2025-05-24T14:54:58.5809104Z  * notice:
2025-05-24T14:54:58.5809304Z  *	(1) does not touch `dst' unless it's returning 1.
2025-05-24T14:54:58.5809406Z  *	(2) :: in a full address is silently ignored.
2025-05-24T14:54:58.5809466Z  * credit:
2025-05-24T14:54:58.5809542Z  *	inspired by Mark Andrews.
2025-05-24T14:54:58.5809599Z  * author:
2025-05-24T14:54:58.5809669Z  *	Paul Vixie, 1996.
2025-05-24T14:54:58.5809724Z  */
2025-05-24T14:54:58.5809787Z #ifdef AF_INET6
2025-05-24T14:54:58.5809845Z static int
2025-05-24T14:54:58.5809914Z inet_pton6(src, dst)
2025-05-24T14:54:58.5809977Z 	const char *src;
2025-05-24T14:54:58.5810040Z 	unsigned char *dst;
2025-05-24T14:54:58.5810095Z {
2025-05-24T14:54:58.5810201Z 	static const char xdigits_l[] = "0123456789abcdef",
2025-05-24T14:54:58.5810277Z 			  xdigits_u[] = "0123456789ABCDEF";
2025-05-24T14:54:58.5810397Z 	unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;
2025-05-24T14:54:58.5810474Z 	const char *xdigits, *curtok;
2025-05-24T14:54:58.5810537Z 	int ch, saw_xdigit;
2025-05-24T14:54:58.5810599Z 	unsigned int val;
2025-05-24T14:54:58.5810603Z 
2025-05-24T14:54:58.5810692Z 	memset((tp = tmp), '\0', NS_IN6ADDRSZ);
2025-05-24T14:54:58.5810761Z 	endp = tp + NS_IN6ADDRSZ;
2025-05-24T14:54:58.5810824Z 	colonp = NULL;
2025-05-24T14:54:58.5810927Z 	/* Leading :: requires some special handling. */
2025-05-24T14:54:58.5810991Z 	if (*src == ':')
2025-05-24T14:54:58.5811052Z 		if (*++src != ':')
2025-05-24T14:54:58.5811111Z 			return (0);
2025-05-24T14:54:58.5811175Z 	curtok = src;
2025-05-24T14:54:58.5811236Z 	saw_xdigit = 0;
2025-05-24T14:54:58.5811293Z 	val = 0;
2025-05-24T14:54:58.5811362Z 	while ((ch = *src++) != '\0') {
2025-05-24T14:54:58.5811431Z 		const char *pch;
2025-05-24T14:54:58.5811434Z 
2025-05-24T14:54:58.5811539Z 		if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)
2025-05-24T14:54:58.5811630Z 			pch = strchr((xdigits = xdigits_u), ch);
2025-05-24T14:54:58.5811699Z 		if (pch != NULL) {
2025-05-24T14:54:58.5811756Z 			val <<= 4;
2025-05-24T14:54:58.5811827Z 			val |= (pch - xdigits);
2025-05-24T14:54:58.5811888Z 			if (val > 0xffff)
2025-05-24T14:54:58.5811950Z 				return (0);
2025-05-24T14:54:58.5812015Z 			saw_xdigit = 1;
2025-05-24T14:54:58.5812076Z 			continue;
2025-05-24T14:54:58.5812188Z 		}
2025-05-24T14:54:58.5812249Z 		if (ch == ':') {
2025-05-24T14:54:58.5812309Z 			curtok = src;
2025-05-24T14:54:58.5812371Z 			if (!saw_xdigit) {
2025-05-24T14:54:58.5812435Z 				if (colonp)
2025-05-24T14:54:58.5812492Z 					return (0);
2025-05-24T14:54:58.5812551Z 				colonp = tp;
2025-05-24T14:54:58.5812609Z 				continue;
2025-05-24T14:54:58.5812671Z 			}
2025-05-24T14:54:58.5812743Z 			if (tp + NS_INT16SZ > endp)
2025-05-24T14:54:58.5812803Z 				return (0);
2025-05-24T14:54:58.5812892Z 			*tp++ = (unsigned char) (val >> 8) & 0xff;
2025-05-24T14:54:58.5812971Z 			*tp++ = (unsigned char) val & 0xff;
2025-05-24T14:54:58.5813035Z 			saw_xdigit = 0;
2025-05-24T14:54:58.5813091Z 			val = 0;
2025-05-24T14:54:58.5813152Z 			continue;
2025-05-24T14:54:58.5813206Z 		}
2025-05-24T14:54:58.5813295Z 		if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
2025-05-24T14:54:58.5813379Z 		    inet_pton4(curtok, tp) > 0) {
2025-05-24T14:54:58.5813441Z 			tp += NS_INADDRSZ;
2025-05-24T14:54:58.5813503Z 			saw_xdigit = 0;
2025-05-24T14:54:58.5813598Z 			break;	/* '\0' was seen by inet_pton4(). */
2025-05-24T14:54:58.5813657Z 		}
2025-05-24T14:54:58.5813715Z 		return (0);
2025-05-24T14:54:58.5813771Z 	}
2025-05-24T14:54:58.5813838Z 	if (saw_xdigit) {
2025-05-24T14:54:58.5813908Z 		if (tp + NS_INT16SZ > endp)
2025-05-24T14:54:58.5813969Z 			return (0);
2025-05-24T14:54:58.5814050Z 		*tp++ = (unsigned char) (val >> 8) & 0xff;
2025-05-24T14:54:58.5814130Z 		*tp++ = (unsigned char) val & 0xff;
2025-05-24T14:54:58.5814187Z 	}
2025-05-24T14:54:58.5814251Z 	if (colonp != NULL) {
2025-05-24T14:54:58.5814361Z 		/*
2025-05-24T14:54:58.5814469Z 		 * Since some memmove()'s erroneously fail to handle
2025-05-24T14:54:58.5814575Z 		 * overlapping regions, we'll do the shift by hand.
2025-05-24T14:54:58.5814632Z 		 */
2025-05-24T14:54:58.5814712Z 		const int n = tp - colonp;
2025-05-24T14:54:58.5814771Z 		int i;
2025-05-24T14:54:58.5814866Z 
2025-05-24T14:54:58.5814934Z 		for (i = 1; i <= n; i++) {
2025-05-24T14:54:58.5815011Z 			endp[- i] = colonp[n - i];
2025-05-24T14:54:58.5815078Z 			colonp[n - i] = 0;
2025-05-24T14:54:58.5815134Z 		}
2025-05-24T14:54:58.5815194Z 		tp = endp;
2025-05-24T14:54:58.5815253Z 	}
2025-05-24T14:54:58.5815314Z 	if (tp != endp)
2025-05-24T14:54:58.5815496Z 		return (0);
2025-05-24T14:54:58.5815577Z 	memcpy(dst, tmp, NS_IN6ADDRSZ);
2025-05-24T14:54:58.5815637Z 	return (1);
2025-05-24T14:54:58.5815691Z }
2025-05-24T14:54:58.5815747Z #endif
2025-05-24T14:54:58.5815813Z -------------------
2025-05-24T14:54:58.5815888Z Content of lib/replace/poll.c:
2025-05-24T14:54:58.5815946Z /*
2025-05-24T14:54:58.5816022Z    Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5816097Z    poll.c - poll wrapper
2025-05-24T14:54:58.5816101Z 
2025-05-24T14:54:58.5816240Z    This file is based on code from libssh (LGPLv2.1+ at the time it
2025-05-24T14:54:58.5816342Z    was downloaded), thus the following copyrights:
2025-05-24T14:54:58.5816348Z 
2025-05-24T14:54:58.5816493Z    Copyright (c) 2009-2010 by Andreas Schneider <mail@cynapses.org>
2025-05-24T14:54:58.5816587Z    Copyright (c) 2003-2009 by Aris Adamantiadis
2025-05-24T14:54:58.5816667Z    Copyright (c) 2009 Aleksandar Kanchev
2025-05-24T14:54:58.5816754Z    Copyright (C) Volker Lendecke 2011
2025-05-24T14:54:58.5816758Z 
2025-05-24T14:54:58.5816882Z      ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5817010Z      ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5817079Z      ** under the LGPL
2025-05-24T14:54:58.5817083Z 
2025-05-24T14:54:58.5817217Z    This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5817347Z    modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5817485Z    License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5817623Z    version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5817629Z 
2025-05-24T14:54:58.5817771Z    This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5817994Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5818154Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5818316Z    Lesser General Public License for more details.
2025-05-24T14:54:58.5818322Z 
2025-05-24T14:54:58.5818586Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5818900Z    License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5818993Z  */
2025-05-24T14:54:58.5818999Z 
2025-05-24T14:54:58.5819115Z #include "replace.h"
2025-05-24T14:54:58.5819233Z #include "system/select.h"
2025-05-24T14:54:58.5819350Z #ifdef HAVE_SYS_TIME_H
2025-05-24T14:54:58.5819428Z #include <sys/time.h>
2025-05-24T14:54:58.5819487Z #endif
2025-05-24T14:54:58.5819552Z #ifdef HAVE_SYS_IOCTL_H
2025-05-24T14:54:58.5819621Z #include <sys/ioctl.h>
2025-05-24T14:54:58.5819680Z #endif
2025-05-24T14:54:58.5819684Z 
2025-05-24T14:54:58.5819687Z 
2025-05-24T14:54:58.5819812Z int rep_poll(struct pollfd *fds, nfds_t nfds, int timeout)
2025-05-24T14:54:58.5819868Z {
2025-05-24T14:54:58.5819958Z 	fd_set rfds, wfds, efds;
2025-05-24T14:54:58.5820097Z 	struct timeval tv, *ptv;
2025-05-24T14:54:58.5820202Z 	int max_fd;
2025-05-24T14:54:58.5820267Z 	int rc;
2025-05-24T14:54:58.5820330Z 	nfds_t i;
2025-05-24T14:54:58.5820335Z 
2025-05-24T14:54:58.5820409Z 	if ((fds == NULL) && (nfds != 0)) {
2025-05-24T14:54:58.5820470Z 		errno = EFAULT;
2025-05-24T14:54:58.5820535Z 		return -1;
2025-05-24T14:54:58.5820590Z 	}
2025-05-24T14:54:58.5820677Z 
2025-05-24T14:54:58.5820742Z 	FD_ZERO(&rfds);
2025-05-24T14:54:58.5820819Z 	FD_ZERO(&wfds);
2025-05-24T14:54:58.5820941Z 	FD_ZERO(&efds);
2025-05-24T14:54:58.5820946Z 
2025-05-24T14:54:58.5821050Z 	rc = 0;
2025-05-24T14:54:58.5821118Z 	max_fd = 0;
2025-05-24T14:54:58.5821122Z 
2025-05-24T14:54:58.5821344Z 	/* compute fd_sets and find largest descriptor */
2025-05-24T14:54:58.5821419Z 	for (i = 0; i < nfds; i++) {
2025-05-24T14:54:58.5821521Z 		if ((fds[i].fd < 0) || (fds[i].fd >= FD_SETSIZE)) {
2025-05-24T14:54:58.5821594Z 			fds[i].revents = POLLNVAL;
2025-05-24T14:54:58.5821658Z 			continue;
2025-05-24T14:54:58.5821713Z 		}
2025-05-24T14:54:58.5821716Z 
2025-05-24T14:54:58.5821809Z 		if (fds[i].events & (POLLIN | POLLRDNORM)) {
2025-05-24T14:54:58.5821888Z 			FD_SET(fds[i].fd, &rfds);
2025-05-24T14:54:58.5821942Z 		}
2025-05-24T14:54:58.5822063Z 		if (fds[i].events & (POLLOUT | POLLWRNORM | POLLWRBAND)) {
2025-05-24T14:54:58.5822131Z 			FD_SET(fds[i].fd, &wfds);
2025-05-24T14:54:58.5822190Z 		}
2025-05-24T14:54:58.5822284Z 		if (fds[i].events & (POLLPRI | POLLRDBAND)) {
2025-05-24T14:54:58.5822350Z 			FD_SET(fds[i].fd, &efds);
2025-05-24T14:54:58.5822410Z 		}
2025-05-24T14:54:58.5822479Z 		if (fds[i].fd > max_fd &&
2025-05-24T14:54:58.5822576Z 		    (fds[i].events & (POLLIN | POLLOUT | POLLPRI |
2025-05-24T14:54:58.5822658Z 				      POLLRDNORM | POLLRDBAND |
2025-05-24T14:54:58.5822740Z 				      POLLWRNORM | POLLWRBAND))) {
2025-05-24T14:54:58.5822807Z 			max_fd = fds[i].fd;
2025-05-24T14:54:58.5822860Z 		}
2025-05-24T14:54:58.5822918Z 	}
2025-05-24T14:54:58.5822922Z 
2025-05-24T14:54:58.5822985Z 	if (timeout < 0) {
2025-05-24T14:54:58.5823045Z 		ptv = NULL;
2025-05-24T14:54:58.5823102Z 	} else {
2025-05-24T14:54:58.5823167Z 		ptv = &tv;
2025-05-24T14:54:58.5823231Z 		if (timeout == 0) {
2025-05-24T14:54:58.5823292Z 			tv.tv_sec = 0;
2025-05-24T14:54:58.5823356Z 			tv.tv_usec = 0;
2025-05-24T14:54:58.5823417Z 		} else {
2025-05-24T14:54:58.5823486Z 			tv.tv_sec = timeout / 1000;
2025-05-24T14:54:58.5823565Z 			tv.tv_usec = (timeout % 1000) * 1000;
2025-05-24T14:54:58.5823623Z 		}
2025-05-24T14:54:58.5823678Z 	}
2025-05-24T14:54:58.5823682Z 
2025-05-24T14:54:58.5823780Z 	rc = select(max_fd + 1, &rfds, &wfds, &efds, ptv);
2025-05-24T14:54:58.5823844Z 	if (rc < 0) {
2025-05-24T14:54:58.5823905Z 		return -1;
2025-05-24T14:54:58.5823964Z 	}
2025-05-24T14:54:58.5823967Z 
2025-05-24T14:54:58.5824043Z 	for (rc = 0, i = 0; i < nfds; i++) {
2025-05-24T14:54:58.5824188Z 		if ((fds[i].fd < 0) || (fds[i].fd >= FD_SETSIZE)) {
2025-05-24T14:54:58.5824245Z 			continue;
2025-05-24T14:54:58.5824298Z 		}
2025-05-24T14:54:58.5824302Z 
2025-05-24T14:54:58.5824369Z 		fds[i].revents = 0;
2025-05-24T14:54:58.5824373Z 
2025-05-24T14:54:58.5824448Z 		if (FD_ISSET(fds[i].fd, &rfds)) {
2025-05-24T14:54:58.5824509Z 			int err = errno;
2025-05-24T14:54:58.5824579Z 			int available = 0;
2025-05-24T14:54:58.5824637Z 			int ret;
2025-05-24T14:54:58.5824641Z 
2025-05-24T14:54:58.5824714Z 			/* support for POLLHUP */
2025-05-24T14:54:58.5824809Z 			ret = ioctl(fds[i].fd, FIONREAD, &available);
2025-05-24T14:54:58.5824893Z 			if ((ret == -1) || (available == 0)) {
2025-05-24T14:54:58.5824964Z 				fds[i].revents |= POLLHUP;
2025-05-24T14:54:58.5825021Z 			} else {
2025-05-24T14:54:58.5825101Z 				fds[i].revents |= fds[i].events
2025-05-24T14:54:58.5825181Z 					& (POLLIN | POLLRDNORM);
2025-05-24T14:54:58.5825243Z 			}
2025-05-24T14:54:58.5825247Z 
2025-05-24T14:54:58.5825307Z 			errno = err;
2025-05-24T14:54:58.5825493Z 		}
2025-05-24T14:54:58.5825566Z 		if (FD_ISSET(fds[i].fd, &wfds)) {
2025-05-24T14:54:58.5825640Z 			fds[i].revents |= fds[i].events
2025-05-24T14:54:58.5825732Z 				& (POLLOUT | POLLWRNORM | POLLWRBAND);
2025-05-24T14:54:58.5825787Z 		}
2025-05-24T14:54:58.5825858Z 		if (FD_ISSET(fds[i].fd, &efds)) {
2025-05-24T14:54:58.5825927Z 			fds[i].revents |= fds[i].events
2025-05-24T14:54:58.5826001Z 				& (POLLPRI | POLLRDBAND);
2025-05-24T14:54:58.5826058Z 		}
2025-05-24T14:54:58.5826140Z 		if (fds[i].revents & ~POLLHUP) {
2025-05-24T14:54:58.5826271Z 			rc++;
2025-05-24T14:54:58.5826326Z 		}
2025-05-24T14:54:58.5826380Z 	}
2025-05-24T14:54:58.5826440Z 	return rc;
2025-05-24T14:54:58.5826498Z }
2025-05-24T14:54:58.5826558Z -------------------
2025-05-24T14:54:58.5826643Z Content of lib/replace/replace.c:
2025-05-24T14:54:58.5827254Z + echo -------------------
2025-05-24T14:54:58.5827440Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5827536Z + echo 'Content of lib/replace/snprintf.c:'
2025-05-24T14:54:58.5827616Z + cat lib/replace/snprintf.c
2025-05-24T14:54:58.5827683Z + echo -------------------
2025-05-24T14:54:58.5827753Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5827836Z + echo 'Content of lib/replace/socket.c:'
2025-05-24T14:54:58.5827910Z + cat lib/replace/socket.c
2025-05-24T14:54:58.5827974Z + echo -------------------
2025-05-24T14:54:58.5828042Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5828138Z + echo 'Content of lib/replace/socketpair.c:'
2025-05-24T14:54:58.5828213Z + cat lib/replace/socketpair.c
2025-05-24T14:54:58.5828279Z + echo -------------------
2025-05-24T14:54:58.5828350Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5828440Z + echo 'Content of lib/replace/strptime.c:'
2025-05-24T14:54:58.5828511Z + cat lib/replace/strptime.c
2025-05-24T14:54:58.5828575Z + echo -------------------
2025-05-24T14:54:58.5828652Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5828732Z + echo 'Content of lib/replace/timegm.c:'
2025-05-24T14:54:58.5828802Z + cat lib/replace/timegm.c
2025-05-24T14:54:58.5828866Z + echo -------------------
2025-05-24T14:54:58.5828942Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5829021Z + echo 'Content of lib/replace/xattr.c:'
2025-05-24T14:54:58.5829089Z + cat lib/replace/xattr.c
2025-05-24T14:54:58.5829156Z + echo -------------------
2025-05-24T14:54:58.5829269Z + echo 'Analyzing replace.h for typedef conflicts...'
2025-05-24T14:54:58.5829331Z + PATTERNS=()
2025-05-24T14:54:58.5829441Z + grep -q 'typedef.*intptr_t' lib/replace/replace.h
2025-05-24T14:54:58.5829518Z + PATTERNS+=("typedef.*intptr_t")
2025-05-24T14:54:58.5829622Z + grep -q 'typedef.*uintptr_t' lib/replace/replace.h
2025-05-24T14:54:58.5829697Z + PATTERNS+=("typedef.*uintptr_t")
2025-05-24T14:54:58.5829800Z + grep -q 'typedef.*ptrdiff_t' lib/replace/replace.h
2025-05-24T14:54:58.5829876Z + PATTERNS+=("typedef.*ptrdiff_t")
2025-05-24T14:54:58.5829979Z + grep -q 'typedef.*useconds_t' lib/replace/replace.h
2025-05-24T14:54:58.5830057Z + PATTERNS+=("typedef.*useconds_t")
2025-05-24T14:54:58.5830206Z + RTLD_NEEDED=false
2025-05-24T14:54:58.5830277Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5830378Z + grep -q RTLD_DEFAULT lib/replace/closefrom.c
2025-05-24T14:54:58.5830449Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5830533Z + grep -q RTLD_DEFAULT lib/replace/dlfcn.c
2025-05-24T14:54:58.5830604Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5830703Z + grep -q RTLD_DEFAULT lib/replace/getaddrinfo.c
2025-05-24T14:54:58.5830771Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5830866Z + grep -q RTLD_DEFAULT lib/replace/getifaddrs.c
2025-05-24T14:54:58.5830937Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5831034Z + grep -q RTLD_DEFAULT lib/replace/inet_aton.c
2025-05-24T14:54:58.5831121Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5831297Z + grep -q RTLD_DEFAULT lib/replace/inet_ntoa.c
2025-05-24T14:54:58.5831437Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5831601Z + grep -q RTLD_DEFAULT lib/replace/inet_ntop.c
2025-05-24T14:54:58.5831722Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5831876Z + grep -q RTLD_DEFAULT lib/replace/inet_pton.c
2025-05-24T14:54:58.5832001Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5832143Z + grep -q RTLD_DEFAULT lib/replace/poll.c
2025-05-24T14:54:58.5832260Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5832416Z + grep -q RTLD_DEFAULT lib/replace/replace.c
2025-05-24T14:54:58.5832516Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5832609Z + grep -q RTLD_DEFAULT lib/replace/snprintf.c
2025-05-24T14:54:58.5832686Z + for file in lib/replace/*.c
2025-05-24T14:54:58.5832837Z + grep -q RTLD_DEFAULT lib/replace/socket.c
2025-05-24T14:54:58.5832908Z /* 
2025-05-24T14:54:58.5833048Z    Unix SMB/CIFS implementation.
2025-05-24T14:54:58.5833167Z    replacement routines for broken systems
2025-05-24T14:54:58.5833255Z    Copyright (C) Andrew Tridgell 1992-1998
2025-05-24T14:54:58.5833422Z    Copyright (C) Jelmer Vernooij 2005-2008
2025-05-24T14:54:58.5833513Z    Copyright (C) Matthieu Patou  2010
2025-05-24T14:54:58.5833519Z 
2025-05-24T14:54:58.5833649Z      ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.5833846Z      ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.5833942Z      ** under the LGPL
2025-05-24T14:54:58.5834005Z    
2025-05-24T14:54:58.5834145Z    This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.5834273Z    modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.5834411Z    License as published by the Free Software Foundation; either
2025-05-24T14:54:58.5834552Z    version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.5834555Z 
2025-05-24T14:54:58.5834694Z    This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.5834833Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.5834997Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.5835101Z    Lesser General Public License for more details.
2025-05-24T14:54:58.5835104Z 
2025-05-24T14:54:58.5835254Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.5835640Z    License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.5835700Z */
2025-05-24T14:54:58.5835704Z 
2025-05-24T14:54:58.5835774Z #include "replace.h"
2025-05-24T14:54:58.5835782Z 
2025-05-24T14:54:58.5835854Z #include "system/filesys.h"
2025-05-24T14:54:58.5835924Z #include "system/time.h"
2025-05-24T14:54:58.5835998Z #include "system/network.h"
2025-05-24T14:54:58.5836080Z #include "system/passwd.h"
2025-05-24T14:54:58.5836146Z #include "system/syslog.h"
2025-05-24T14:54:58.5836213Z #include "system/locale.h"
2025-05-24T14:54:58.5836283Z #include "system/wait.h"
2025-05-24T14:54:58.5836287Z 
2025-05-24T14:54:58.5836356Z #ifdef HAVE_SYS_SYSCALL_H
2025-05-24T14:54:58.5836427Z #include <sys/syscall.h>
2025-05-24T14:54:58.5836484Z #endif
2025-05-24T14:54:58.5836571Z 
2025-05-24T14:54:58.5836639Z #ifdef _WIN32
2025-05-24T14:54:58.5836710Z #define mkdir(d,m) _mkdir(d)
2025-05-24T14:54:58.5836766Z #endif
2025-05-24T14:54:58.5836769Z 
2025-05-24T14:54:58.5836843Z void replace_dummy(void);
2025-05-24T14:54:58.5836918Z void replace_dummy(void) {}
2025-05-24T14:54:58.5836921Z 
2025-05-24T14:54:58.5836988Z #ifndef HAVE_FTRUNCATE
2025-05-24T14:54:58.5837073Z  /*******************************************************************
2025-05-24T14:54:58.5837185Z ftruncate for operating systems that don't have it
2025-05-24T14:54:58.5837262Z ********************************************************************/
2025-05-24T14:54:58.5837340Z int rep_ftruncate(int f, off_t l)
2025-05-24T14:54:58.5837398Z {
2025-05-24T14:54:58.5837466Z #ifdef HAVE_CHSIZE
2025-05-24T14:54:58.5837535Z       return chsize(f,l);
2025-05-24T14:54:58.5837608Z #elif defined(F_FREESP)
2025-05-24T14:54:58.5837677Z       struct  flock   fl;
2025-05-24T14:54:58.5837680Z 
2025-05-24T14:54:58.5837742Z       fl.l_whence = 0;
2025-05-24T14:54:58.5837803Z       fl.l_len = 0;
2025-05-24T14:54:58.5837869Z       fl.l_start = l;
2025-05-24T14:54:58.5837938Z       fl.l_type = F_WRLCK;
2025-05-24T14:54:58.5838018Z       return fcntl(f, F_FREESP, &fl);
2025-05-24T14:54:58.5838079Z #else
2025-05-24T14:54:58.5838169Z #error "you must have a ftruncate function"
2025-05-24T14:54:58.5838224Z #endif
2025-05-24T14:54:58.5838278Z }
2025-05-24T14:54:58.5838353Z #endif /* HAVE_FTRUNCATE */
2025-05-24T14:54:58.5838356Z 
2025-05-24T14:54:58.5838360Z 
2025-05-24T14:54:58.5838425Z #ifndef HAVE_STRLCPY
2025-05-24T14:54:58.5838545Z /*
2025-05-24T14:54:58.5838679Z  * Like strncpy but does not 0 fill the buffer and always null
2025-05-24T14:54:58.5838809Z  * terminates. bufsize is the size of the destination buffer.
2025-05-24T14:54:58.5838876Z  * Returns the length of s.
2025-05-24T14:54:58.5838932Z  */
2025-05-24T14:54:58.5839160Z size_t rep_strlcpy(char *d, const char *s, size_t bufsize)
2025-05-24T14:54:58.5839217Z {
2025-05-24T14:54:58.5839283Z 	size_t len = strlen(s);
2025-05-24T14:54:58.5839353Z 	size_t ret = len;
2025-05-24T14:54:58.5839357Z 
2025-05-24T14:54:58.5839421Z 	if (bufsize <= 0) {
2025-05-24T14:54:58.5839480Z 		return 0;
2025-05-24T14:54:58.5839533Z 	}
2025-05-24T14:54:58.5839599Z 	if (len >= bufsize) {
2025-05-24T14:54:58.5839663Z 		len = bufsize - 1;
2025-05-24T14:54:58.5839717Z 	}
2025-05-24T14:54:58.5839783Z 	memcpy(d, s, len);
2025-05-24T14:54:58.5839842Z 	d[len] = 0;
2025-05-24T14:54:58.5839901Z 	return ret;
2025-05-24T14:54:58.5839952Z }
2025-05-24T14:54:58.5840011Z #endif
2025-05-24T14:54:58.5840016Z 
2025-05-24T14:54:58.5840079Z #ifndef HAVE_STRLCAT
2025-05-24T14:54:58.5840205Z /* like strncat but does not 0 fill the buffer and always null 
2025-05-24T14:54:58.5840345Z    terminates. bufsize is the length of the buffer, which should
2025-05-24T14:54:58.5840461Z    be one more than the maximum resulting string length */
2025-05-24T14:54:58.5840573Z size_t rep_strlcat(char *d, const char *s, size_t bufsize)
2025-05-24T14:54:58.5840633Z {
2025-05-24T14:54:58.5840709Z 	size_t len1 = strnlen(d, bufsize);
2025-05-24T14:54:58.5840777Z 	size_t len2 = strlen(s);
2025-05-24T14:54:58.5840842Z 	size_t ret = len1 + len2;
2025-05-24T14:54:58.5840845Z 
2025-05-24T14:54:58.5840919Z 	if (len1+len2 >= bufsize) {
2025-05-24T14:54:58.5840988Z 		if (bufsize < (len1+1)) {
2025-05-24T14:54:58.5841047Z 			return ret;
2025-05-24T14:54:58.5841103Z 		}
2025-05-24T14:54:58.5841171Z 		len2 = bufsize - (len1+1);
2025-05-24T14:54:58.5841224Z 	}
2025-05-24T14:54:58.5841284Z 	if (len2 > 0) {
2025-05-24T14:54:58.5841357Z 		memcpy(d+len1, s, len2);
2025-05-24T14:54:58.5841421Z 		d[len1+len2] = 0;
2025-05-24T14:54:58.5841475Z 	}
2025-05-24T14:54:58.5841532Z 	return ret;
2025-05-24T14:54:58.5841589Z }
2025-05-24T14:54:58.5841645Z #endif
2025-05-24T14:54:58.5841649Z 
2025-05-24T14:54:58.5841713Z #ifndef HAVE_MKTIME
2025-05-24T14:54:58.5841799Z /*******************************************************************
2025-05-24T14:54:58.5841951Z a mktime() replacement for those who don't have it - contributed by 
2025-05-24T14:54:58.5842073Z C.A. Lademann <cal@zls.com>
2025-05-24T14:54:58.5842176Z Corrections by richard.kettlewell@kewill.com
2025-05-24T14:54:58.5842254Z ********************************************************************/
2025-05-24T14:54:58.5842258Z 
2025-05-24T14:54:58.5842321Z #define  MINUTE  60
2025-05-24T14:54:58.5842386Z #define  HOUR    60*MINUTE
2025-05-24T14:54:58.5842464Z #define  DAY             24*HOUR
2025-05-24T14:54:58.5842528Z #define  YEAR    365*DAY
2025-05-24T14:54:58.5842603Z time_t rep_mktime(struct tm *t)
2025-05-24T14:54:58.5842664Z {
2025-05-24T14:54:58.5842728Z   struct tm       *u;
2025-05-24T14:54:58.5842790Z   time_t  epoch = 0;
2025-05-24T14:54:58.5842846Z   int n;
2025-05-24T14:54:58.5842955Z   int             mon [] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
2025-05-24T14:54:58.5843017Z   y, m, i;
2025-05-24T14:54:58.5843024Z 
2025-05-24T14:54:58.5843088Z   if(t->tm_year < 70)
2025-05-24T14:54:58.5843161Z     return((time_t)-1);
2025-05-24T14:54:58.5843166Z 
2025-05-24T14:54:58.5843234Z   n = t->tm_year + 1900 - 1;
2025-05-24T14:54:58.5843310Z   epoch = (t->tm_year - 70) * YEAR + 
2025-05-24T14:54:58.5843427Z     ((n / 4 - n / 100 + n / 400) - (1969 / 4 - 1969 / 100 + 1969 / 400)) * DAY;
2025-05-24T14:54:58.5843431Z 
2025-05-24T14:54:58.5843494Z   y = t->tm_year + 1900;
2025-05-24T14:54:58.5843550Z   m = 0;
2025-05-24T14:54:58.5843553Z 
2025-05-24T14:54:58.5843663Z   for(i = 0; i < t->tm_mon; i++) {
2025-05-24T14:54:58.5843796Z     epoch += mon [m] * DAY;
2025-05-24T14:54:58.5844024Z     if(m == 1 && y % 4 == 0 && (y % 100 != 0 || y % 400 == 0))
2025-05-24T14:54:58.5844128Z       epoch += DAY;
2025-05-24T14:54:58.5844224Z     
2025-05-24T14:54:58.5844322Z     if(++m > 11) {
2025-05-24T14:54:58.5844418Z       m = 0;
2025-05-24T14:54:58.5844511Z       y++;
2025-05-24T14:54:58.5844606Z     }
2025-05-24T14:54:58.5844812Z   }
2025-05-24T14:54:58.5844818Z 
2025-05-24T14:54:58.5844901Z   epoch += (t->tm_mday - 1) * DAY;
2025-05-24T14:54:58.5845031Z   epoch += t->tm_hour * HOUR + t->tm_min * MINUTE + t->tm_sec;
2025-05-24T14:54:58.5845086Z   
2025-05-24T14:54:58.5845166Z   if((u = localtime(&epoch)) != NULL) {
2025-05-24T14:54:58.5845232Z     t->tm_sec = u->tm_sec;
2025-05-24T14:54:58.5845300Z     t->tm_min = u->tm_min;
2025-05-24T14:54:58.5845528Z     t->tm_hour = u->tm_hour;
2025-05-24T14:54:58.5845654Z     t->tm_mday = u->tm_mday;
2025-05-24T14:54:58.5845727Z     t->tm_mon = u->tm_mon;
2025-05-24T14:54:58.5845794Z     t->tm_year = u->tm_year;
2025-05-24T14:54:58.5845858Z     t->tm_wday = u->tm_wday;
2025-05-24T14:54:58.5845956Z     t->tm_yday = u->tm_yday;
2025-05-24T14:54:58.5846092Z     t->tm_isdst = u->tm_isdst;
2025-05-24T14:54:58.5846176Z   }
2025-05-24T14:54:58.5846181Z 
2025-05-24T14:54:58.5846246Z   return(epoch);
2025-05-24T14:54:58.5846308Z }
2025-05-24T14:54:58.5846377Z #endif /* !HAVE_MKTIME */
2025-05-24T14:54:58.5846384Z 
2025-05-24T14:54:58.5846387Z 
2025-05-24T14:54:58.5846457Z #ifndef HAVE_INITGROUPS
2025-05-24T14:54:58.5846548Z /****************************************************************************
2025-05-24T14:54:58.5846643Z  some systems don't have an initgroups call 
2025-05-24T14:54:58.5846722Z ****************************************************************************/
2025-05-24T14:54:58.5846880Z int rep_initgroups(char *name, gid_t id)
2025-05-24T14:54:58.5846986Z {
2025-05-24T14:54:58.5847057Z #ifndef HAVE_SETGROUPS
2025-05-24T14:54:58.5847184Z 	/* yikes! no SETGROUPS or INITGROUPS? how can this work? */
2025-05-24T14:54:58.5847248Z 	errno = ENOSYS;
2025-05-24T14:54:58.5847311Z 	return -1;
2025-05-24T14:54:58.5847382Z #else /* HAVE_SETGROUPS */
2025-05-24T14:54:58.5847386Z 
2025-05-24T14:54:58.5847452Z #include <grp.h>
2025-05-24T14:54:58.5847456Z 
2025-05-24T14:54:58.5847524Z 	gid_t *grouplst = NULL;
2025-05-24T14:54:58.5847597Z 	int max_gr = NGROUPS_MAX;
2025-05-24T14:54:58.5847656Z 	int ret;
2025-05-24T14:54:58.5847719Z 	int    i,j;
2025-05-24T14:54:58.5847783Z 	struct group *g;
2025-05-24T14:54:58.5847931Z 	char   *gr;
2025-05-24T14:54:58.5847990Z 	
2025-05-24T14:54:58.5848107Z 	if((grouplst = malloc(sizeof(gid_t) * max_gr)) == NULL) {
2025-05-24T14:54:58.5848169Z 		errno = ENOMEM;
2025-05-24T14:54:58.5848229Z 		return -1;
2025-05-24T14:54:58.5848287Z 	}
2025-05-24T14:54:58.5848290Z 
2025-05-24T14:54:58.5848354Z 	grouplst[0] = id;
2025-05-24T14:54:58.5848410Z 	i = 1;
2025-05-24T14:54:58.5848574Z 	while (i < max_gr && ((g = (struct group *)getgrent()) != (struct group *)NULL)) {
2025-05-24T14:54:58.5848640Z 		if (g->gr_gid == id)
2025-05-24T14:54:58.5848699Z 			continue;
2025-05-24T14:54:58.5848758Z 		j = 0;
2025-05-24T14:54:58.5848823Z 		gr = g->gr_mem[0];
2025-05-24T14:54:58.5848900Z 		while (gr && (*gr != (char)NULL)) {
2025-05-24T14:54:58.5848972Z 			if (strcmp(name,gr) == 0) {
2025-05-24T14:54:58.5849045Z 				grouplst[i] = g->gr_gid;
2025-05-24T14:54:58.5849102Z 				i++;
2025-05-24T14:54:58.5849167Z 				gr = (char *)NULL;
2025-05-24T14:54:58.5849224Z 				break;
2025-05-24T14:54:58.5849283Z 			}
2025-05-24T14:54:58.5849349Z 			gr = g->gr_mem[++j];
2025-05-24T14:54:58.5849403Z 		}
2025-05-24T14:54:58.5849461Z 	}
2025-05-24T14:54:58.5849524Z 	endgrent();
2025-05-24T14:54:58.5849598Z 	ret = setgroups(i, grouplst);
2025-05-24T14:54:58.5849661Z 	free(grouplst);
2025-05-24T14:54:58.5849723Z 	return ret;
2025-05-24T14:54:58.5849794Z #endif /* HAVE_SETGROUPS */
2025-05-24T14:54:58.5849849Z }
2025-05-24T14:54:58.5849921Z #endif /* HAVE_INITGROUPS */
2025-05-24T14:54:58.5849924Z 
2025-05-24T14:54:58.5849931Z 
2025-05-24T14:54:58.5849997Z #ifndef HAVE_MEMMOVE
2025-05-24T14:54:58.5850149Z /*******************************************************************
2025-05-24T14:54:58.5850261Z safely copies memory, ensuring no overlap problems.
2025-05-24T14:54:58.5850402Z this is only used if the machine does not have its own memmove().
2025-05-24T14:54:58.5850656Z this is not the fastest algorithm in town, but it will do for our
2025-05-24T14:54:58.5850715Z needs.
2025-05-24T14:54:58.5850800Z ********************************************************************/
2025-05-24T14:54:58.5850924Z void *rep_memmove(void *dest,const void *src,int size)
2025-05-24T14:54:58.5850978Z {
2025-05-24T14:54:58.5851043Z 	unsigned long d,s;
2025-05-24T14:54:58.5851105Z 	int i;
2025-05-24T14:54:58.5851186Z 	if (dest==src || !size) return(dest);
2025-05-24T14:54:58.5851190Z 
2025-05-24T14:54:58.5851259Z 	d = (unsigned long)dest;
2025-05-24T14:54:58.5851329Z 	s = (unsigned long)src;
2025-05-24T14:54:58.5851333Z 
2025-05-24T14:54:58.5851411Z 	if ((d >= (s+size)) || (s >= (d+size))) {
2025-05-24T14:54:58.5851476Z 		/* no overlap */
2025-05-24T14:54:58.5851551Z 		memcpy(dest,src,size);
2025-05-24T14:54:58.5851610Z 		return(dest);
2025-05-24T14:54:58.5851663Z 	}
2025-05-24T14:54:58.5851667Z 
2025-05-24T14:54:58.5851727Z 	if (d < s) {
2025-05-24T14:54:58.5851799Z 		/* we can forward copy */
2025-05-24T14:54:58.5851878Z 		if (s-d >= sizeof(int) && 
2025-05-24T14:54:58.5851946Z 		    !(s%sizeof(int)) && 
2025-05-24T14:54:58.5852009Z 		    !(d%sizeof(int)) && 
2025-05-24T14:54:58.5852082Z 		    !(size%sizeof(int))) {
2025-05-24T14:54:58.5852149Z 			/* do it all as words */
2025-05-24T14:54:58.5852216Z 			int *idest = (int *)dest;
2025-05-24T14:54:58.5852286Z 			int *isrc = (int *)src;
2025-05-24T14:54:58.5852349Z 			size /= sizeof(int);
2025-05-24T14:54:58.5852431Z 			for (i=0;i<size;i++) idest[i] = isrc[i];
2025-05-24T14:54:58.5852489Z 		} else {
2025-05-24T14:54:58.5852556Z 			/* simplest */
2025-05-24T14:54:58.5852625Z 			char *cdest = (char *)dest;
2025-05-24T14:54:58.5852689Z 			char *csrc = (char *)src;
2025-05-24T14:54:58.5852776Z 			for (i=0;i<size;i++) cdest[i] = csrc[i];
2025-05-24T14:54:58.5852831Z 		}
2025-05-24T14:54:58.5852887Z 	} else {
2025-05-24T14:54:58.5852959Z 		/* must backward copy */
2025-05-24T14:54:58.5853030Z 		if (d-s >= sizeof(int) && 
2025-05-24T14:54:58.5853094Z 		    !(s%sizeof(int)) && 
2025-05-24T14:54:58.5853159Z 		    !(d%sizeof(int)) && 
2025-05-24T14:54:58.5853229Z 		    !(size%sizeof(int))) {
2025-05-24T14:54:58.5853295Z 			/* do it all as words */
2025-05-24T14:54:58.5853413Z 			int *idest = (int *)dest;
2025-05-24T14:54:58.5853478Z 			int *isrc = (int *)src;
2025-05-24T14:54:58.5853544Z 			size /= sizeof(int);
2025-05-24T14:54:58.5853629Z 			for (i=size-1;i>=0;i--) idest[i] = isrc[i];
2025-05-24T14:54:58.5853686Z 		} else {
2025-05-24T14:54:58.5853750Z 			/* simplest */
2025-05-24T14:54:58.5853818Z 			char *cdest = (char *)dest;
2025-05-24T14:54:58.5853886Z 			char *csrc = (char *)src;
2025-05-24T14:54:58.5853967Z 			for (i=size-1;i>=0;i--) cdest[i] = csrc[i];
2025-05-24T14:54:58.5854029Z 		}      
2025-05-24T14:54:58.5854084Z 	}
2025-05-24T14:54:58.5854145Z 	return(dest);
2025-05-24T14:54:58.5854202Z }
2025-05-24T14:54:58.5854269Z #endif /* HAVE_MEMMOVE */
2025-05-24T14:54:58.5854272Z 
2025-05-24T14:54:58.5854337Z #ifndef HAVE_STRDUP
2025-05-24T14:54:58.5854426Z /****************************************************************************
2025-05-24T14:54:58.5854499Z duplicate a string
2025-05-24T14:54:58.5854575Z ****************************************************************************/
2025-05-24T14:54:58.5854652Z char *rep_strdup(const char *s)
2025-05-24T14:54:58.5854711Z {
2025-05-24T14:54:58.5854771Z 	size_t len;
2025-05-24T14:54:58.5854830Z 	char *ret;
2025-05-24T14:54:58.5854834Z 
2025-05-24T14:54:58.5854902Z 	if (!s) return(NULL);
2025-05-24T14:54:58.5854906Z 
2025-05-24T14:54:58.5854970Z 	len = strlen(s)+1;
2025-05-24T14:54:58.5855036Z 	ret = (char *)malloc(len);
2025-05-24T14:54:58.5855102Z 	if (!ret) return(NULL);
2025-05-24T14:54:58.5855169Z 	memcpy(ret,s,len);
2025-05-24T14:54:58.5855276Z 	return(ret);
2025-05-24T14:54:58.5855329Z }
2025-05-24T14:54:58.5855606Z #endif /* HAVE_STRDUP */
2025-05-24T14:54:58.5855611Z 
2025-05-24T14:54:58.5855681Z #ifndef HAVE_SETLINEBUF
2025-05-24T14:54:58.5855764Z void rep_setlinebuf(FILE *stream)
2025-05-24T14:54:58.5855820Z {
2025-05-24T14:54:58.5856031Z 	setvbuf(stream, (char *)NULL, _IOLBF, 0);
2025-05-24T14:54:58.5856091Z }
2025-05-24T14:54:58.5856164Z #endif /* HAVE_SETLINEBUF */
2025-05-24T14:54:58.5856170Z 
2025-05-24T14:54:58.5856237Z #ifndef HAVE_VSYSLOG
2025-05-24T14:54:58.5856301Z #ifdef HAVE_SYSLOG
2025-05-24T14:54:58.5856478Z void rep_vsyslog (int facility_priority, const char *format, va_list arglist)
2025-05-24T14:54:58.5856533Z {
2025-05-24T14:54:58.5856598Z 	char *msg = NULL;
2025-05-24T14:54:58.5856729Z 	vasprintf(&msg, format, arglist);
2025-05-24T14:54:58.5856833Z 	if (!msg)
2025-05-24T14:54:58.5856935Z 		return;
2025-05-24T14:54:58.5857068Z 	syslog(facility_priority, "%s", msg);
2025-05-24T14:54:58.5857165Z 	free(msg);
2025-05-24T14:54:58.5857259Z }
2025-05-24T14:54:58.5857374Z #endif /* HAVE_SYSLOG */
2025-05-24T14:54:58.5857487Z #endif /* HAVE_VSYSLOG */
2025-05-24T14:54:58.5857492Z 
2025-05-24T14:54:58.5857594Z #ifndef HAVE_STRNLEN
2025-05-24T14:54:58.5857691Z /**
2025-05-24T14:54:58.5857814Z  Some platforms don't have strnlen
2025-05-24T14:54:58.5857873Z **/
2025-05-24T14:54:58.5857970Z  size_t rep_strnlen(const char *s, size_t max)
2025-05-24T14:54:58.5858030Z {
2025-05-24T14:54:58.5858089Z         size_t len;
2025-05-24T14:54:58.5858143Z   
2025-05-24T14:54:58.5858224Z         for (len = 0; len < max; len++) {
2025-05-24T14:54:58.5858294Z                 if (s[len] == '\0') {
2025-05-24T14:54:58.5858368Z                         break;
2025-05-24T14:54:58.5858475Z                 }
2025-05-24T14:54:58.5858581Z         }
2025-05-24T14:54:58.5858650Z         return len;  
2025-05-24T14:54:58.5858705Z }
2025-05-24T14:54:58.5858766Z #endif
2025-05-24T14:54:58.5858823Z   
2025-05-24T14:54:58.5858887Z #ifndef HAVE_STRNDUP
2025-05-24T14:54:58.5858943Z /**
2025-05-24T14:54:58.5859028Z  Some platforms don't have strndup.
2025-05-24T14:54:58.5859082Z **/
2025-05-24T14:54:58.5859168Z char *rep_strndup(const char *s, size_t n)
2025-05-24T14:54:58.5859254Z {
2025-05-24T14:54:58.5859369Z 	char *ret;
2025-05-24T14:54:58.5859458Z 	
2025-05-24T14:54:58.5859529Z 	n = strnlen(s, n);
2025-05-24T14:54:58.5859594Z 	ret = malloc(n+1);
2025-05-24T14:54:58.5859653Z 	if (!ret)
2025-05-24T14:54:58.5859799Z 		return NULL;
2025-05-24T14:54:58.5859864Z 	memcpy(ret, s, n);
2025-05-24T14:54:58.5859925Z 	ret[n] = 0;
2025-05-24T14:54:58.5859929Z 
2025-05-24T14:54:58.5859988Z 	return ret;
2025-05-24T14:54:58.5860043Z }
2025-05-24T14:54:58.5860101Z #endif
2025-05-24T14:54:58.5860104Z 
2025-05-24T14:54:58.5860205Z #if !defined(HAVE_WAITPID) && defined(HAVE_WAIT4)
2025-05-24T14:54:58.5860316Z int rep_waitpid(pid_t pid,int *status,int options)
2025-05-24T14:54:58.5860370Z {
2025-05-24T14:54:58.5860463Z   return wait4(pid, status, options, NULL);
2025-05-24T14:54:58.5860520Z }
2025-05-24T14:54:58.5860572Z #endif
2025-05-24T14:54:58.5860575Z 
2025-05-24T14:54:58.5860641Z #ifndef HAVE_SETEUID
2025-05-24T14:54:58.5860713Z int rep_seteuid(uid_t euid)
2025-05-24T14:54:58.5860767Z {
2025-05-24T14:54:58.5860831Z #ifdef HAVE_SETRESUID
2025-05-24T14:54:58.5860913Z 	return setresuid(-1, euid, -1);
2025-05-24T14:54:58.5860974Z #else
2025-05-24T14:54:58.5861035Z 	errno = ENOSYS;
2025-05-24T14:54:58.5861098Z 	return -1;
2025-05-24T14:54:58.5861155Z #endif
2025-05-24T14:54:58.5861210Z }
2025-05-24T14:54:58.5861264Z #endif
2025-05-24T14:54:58.5861267Z 
2025-05-24T14:54:58.5861333Z #ifndef HAVE_SETEGID
2025-05-24T14:54:58.5861404Z int rep_setegid(gid_t egid)
2025-05-24T14:54:58.5861459Z {
2025-05-24T14:54:58.5861526Z #ifdef HAVE_SETRESGID
2025-05-24T14:54:58.5861600Z 	return setresgid(-1, egid, -1);
2025-05-24T14:54:58.5861654Z #else
2025-05-24T14:54:58.5861715Z 	errno = ENOSYS;
2025-05-24T14:54:58.5861778Z 	return -1;
2025-05-24T14:54:58.5861832Z #endif
2025-05-24T14:54:58.5861995Z }
2025-05-24T14:54:58.5862054Z #endif
2025-05-24T14:54:58.5862058Z 
2025-05-24T14:54:58.5862141Z /*******************************************************************
2025-05-24T14:54:58.5862215Z os/2 also doesn't have chroot
2025-05-24T14:54:58.5862294Z ********************************************************************/
2025-05-24T14:54:58.5862435Z #ifndef HAVE_CHROOT
2025-05-24T14:54:58.5862514Z int rep_chroot(const char *dname)
2025-05-24T14:54:58.5862570Z {
2025-05-24T14:54:58.5862634Z 	errno = ENOSYS;
2025-05-24T14:54:58.5862693Z 	return -1;
2025-05-24T14:54:58.5862747Z }
2025-05-24T14:54:58.5862801Z #endif
2025-05-24T14:54:58.5862804Z 
2025-05-24T14:54:58.5862890Z /*****************************************************************
2025-05-24T14:54:58.5862977Z  Possibly replace mkstemp if it is broken.
2025-05-24T14:54:58.5863054Z *****************************************************************/  
2025-05-24T14:54:58.5863057Z 
2025-05-24T14:54:58.5863130Z #ifndef HAVE_SECURE_MKSTEMP
2025-05-24T14:54:58.5863207Z int rep_mkstemp(char *template)
2025-05-24T14:54:58.5863261Z {
2025-05-24T14:54:58.5863369Z 	/* have a reasonable go at emulating it. Hope that
2025-05-24T14:54:58.5863474Z 	   the system mktemp() isn't completely hopeless */
2025-05-24T14:54:58.5863540Z 	mktemp(template);
2025-05-24T14:54:58.5863604Z 	if (template[0] == 0)
2025-05-24T14:54:58.5863671Z 		return -1;
2025-05-24T14:54:58.5863777Z 	return open(template, O_CREAT|O_EXCL|O_RDWR, 0600);
2025-05-24T14:54:58.5863832Z }
2025-05-24T14:54:58.5863890Z #endif
2025-05-24T14:54:58.5863893Z 
2025-05-24T14:54:58.5863957Z #ifndef HAVE_MKDTEMP
2025-05-24T14:54:58.5864034Z char *rep_mkdtemp(char *template)
2025-05-24T14:54:58.5864090Z {
2025-05-24T14:54:58.5864154Z 	char *dname;
2025-05-24T14:54:58.5864209Z 	
2025-05-24T14:54:58.5864286Z 	if ((dname = mktemp(template))) {
2025-05-24T14:54:58.5864360Z 		if (mkdir(dname, 0700) >= 0) {
2025-05-24T14:54:58.5864422Z 			return dname;
2025-05-24T14:54:58.5864477Z 		}
2025-05-24T14:54:58.5864532Z 	}
2025-05-24T14:54:58.5864537Z 
2025-05-24T14:54:58.5864601Z 	return NULL;
2025-05-24T14:54:58.5864655Z }
2025-05-24T14:54:58.5864710Z #endif
2025-05-24T14:54:58.5864713Z 
2025-05-24T14:54:58.5864798Z /*****************************************************************
2025-05-24T14:54:58.5864877Z  Watch out: this is not thread safe.
2025-05-24T14:54:58.5864956Z *****************************************************************/
2025-05-24T14:54:58.5864959Z 
2025-05-24T14:54:58.5865074Z #ifndef HAVE_PREAD
2025-05-24T14:54:58.5865235Z ssize_t rep_pread(int __fd, void *__buf, size_t __nbytes, off_t __offset)
2025-05-24T14:54:58.5865288Z {
2025-05-24T14:54:58.5865510Z 	if (lseek(__fd, __offset, SEEK_SET) != __offset) {
2025-05-24T14:54:58.5865576Z 		return -1;
2025-05-24T14:54:58.5865632Z 	}
2025-05-24T14:54:58.5865705Z 	return read(__fd, __buf, __nbytes);
2025-05-24T14:54:58.5865758Z }
2025-05-24T14:54:58.5865817Z #endif
2025-05-24T14:54:58.5865821Z 
2025-05-24T14:54:58.5865896Z /*****************************************************************
2025-05-24T14:54:58.5865974Z  Watch out: this is not thread safe.
2025-05-24T14:54:58.5866055Z *****************************************************************/
2025-05-24T14:54:58.5866058Z 
2025-05-24T14:54:58.5866122Z #ifndef HAVE_PWRITE
2025-05-24T14:54:58.5866298Z ssize_t rep_pwrite(int __fd, const void *__buf, size_t __nbytes, off_t __offset)
2025-05-24T14:54:58.5866356Z {
2025-05-24T14:54:58.5866450Z 	if (lseek(__fd, __offset, SEEK_SET) != __offset) {
2025-05-24T14:54:58.5866517Z 		return -1;
2025-05-24T14:54:58.5866575Z 	}
2025-05-24T14:54:58.5866656Z 	return write(__fd, __buf, __nbytes);
2025-05-24T14:54:58.5866711Z }
2025-05-24T14:54:58.5866766Z #endif
2025-05-24T14:54:58.5866770Z 
2025-05-24T14:54:58.5866839Z #ifndef HAVE_STRCASESTR
2025-05-24T14:54:58.5866975Z char *rep_strcasestr(const char *haystack, const char *needle)
2025-05-24T14:54:58.5867030Z {
2025-05-24T14:54:58.5867089Z 	const char *s;
2025-05-24T14:54:58.5867167Z 	size_t nlen = strlen(needle);
2025-05-24T14:54:58.5867318Z 	for (s=haystack;*s;s++) {
2025-05-24T14:54:58.5867402Z 		if (toupper(*needle) == toupper(*s) &&
2025-05-24T14:54:58.5867490Z 		    strncasecmp(s, needle, nlen) == 0) {
2025-05-24T14:54:58.5867563Z 			return (char *)((uintptr_t)s);
2025-05-24T14:54:58.5867617Z 		}
2025-05-24T14:54:58.5867671Z 	}
2025-05-24T14:54:58.5867836Z 	return NULL;
2025-05-24T14:54:58.5867938Z }
2025-05-24T14:54:58.5868014Z #endif
2025-05-24T14:54:58.5868018Z 
2025-05-24T14:54:58.5868086Z #ifndef HAVE_STRSEP
2025-05-24T14:54:58.5868189Z char *rep_strsep(char **pps, const char *delim)
2025-05-24T14:54:58.5868244Z {
2025-05-24T14:54:58.5868308Z 	char *ret = *pps;
2025-05-24T14:54:58.5868389Z 	char *p = *pps;
2025-05-24T14:54:58.5868393Z 
2025-05-24T14:54:58.5868459Z 	if (p == NULL) {
2025-05-24T14:54:58.5868518Z 		return NULL;
2025-05-24T14:54:58.5868576Z 	}
2025-05-24T14:54:58.5868649Z 	p += strcspn(p, delim);
2025-05-24T14:54:58.5868708Z 	if (*p == '\0') {
2025-05-24T14:54:58.5868769Z 		*pps = NULL;
2025-05-24T14:54:58.5868831Z 	} else {
2025-05-24T14:54:58.5868892Z 		*p = '\0';
2025-05-24T14:54:58.5868951Z 		*pps = p + 1;
2025-05-24T14:54:58.5869009Z 	}
2025-05-24T14:54:58.5869067Z 	return ret;
2025-05-24T14:54:58.5869124Z }
2025-05-24T14:54:58.5869180Z #endif
2025-05-24T14:54:58.5869183Z 
2025-05-24T14:54:58.5869253Z #ifndef HAVE_STRTOK_R
2025-05-24T14:54:58.5869490Z /* based on GLIBC version, copyright Free Software Foundation */
2025-05-24T14:54:58.5869727Z char *rep_strtok_r(char *s, const char *delim, char **save_ptr)
2025-05-24T14:54:58.5869828Z {
2025-05-24T14:54:58.5869926Z 	char *token;
2025-05-24T14:54:58.5869932Z 
2025-05-24T14:54:58.5870045Z 	if (s == NULL) s = *save_ptr;
2025-05-24T14:54:58.5870050Z 
2025-05-24T14:54:58.5870162Z 	s += strspn(s, delim);
2025-05-24T14:54:58.5870258Z 	if (*s == '\0') {
2025-05-24T14:54:58.5870359Z 		*save_ptr = s;
2025-05-24T14:54:58.5870464Z 		return NULL;
2025-05-24T14:54:58.5870527Z 	}
2025-05-24T14:54:58.5870531Z 
2025-05-24T14:54:58.5870590Z 	token = s;
2025-05-24T14:54:58.5870661Z 	s = strpbrk(token, delim);
2025-05-24T14:54:58.5870726Z 	if (s == NULL) {
2025-05-24T14:54:58.5870800Z 		*save_ptr = token + strlen(token);
2025-05-24T14:54:58.5870857Z 	} else {
2025-05-24T14:54:58.5870914Z 		*s = '\0';
2025-05-24T14:54:58.5870996Z 		*save_ptr = s + 1;
2025-05-24T14:54:58.5871095Z 	}
2025-05-24T14:54:58.5871101Z 
2025-05-24T14:54:58.5871202Z 	return token;
2025-05-24T14:54:58.5871263Z }
2025-05-24T14:54:58.5871317Z #endif
2025-05-24T14:54:58.5871403Z 
2025-05-24T14:54:58.5871406Z 
2025-05-24T14:54:58.5871474Z #ifndef HAVE_STRTOLL
2025-05-24T14:54:58.5871624Z long long int rep_strtoll(const char *str, char **endptr, int base)
2025-05-24T14:54:58.5871681Z {
2025-05-24T14:54:58.5871744Z #ifdef HAVE_STRTOQ
2025-05-24T14:54:58.5871864Z 	return strtoq(str, endptr, base);
2025-05-24T14:54:58.5871993Z #elif defined(HAVE___STRTOLL) 
2025-05-24T14:54:58.5872077Z 	return __strtoll(str, endptr, base);
2025-05-24T14:54:58.5872156Z #elif SIZEOF_LONG == SIZEOF_LONG_LONG
2025-05-24T14:54:58.5872260Z 	return (long long int) strtol(str, endptr, base);
2025-05-24T14:54:58.5872324Z #else
2025-05-24T14:54:58.5872405Z # error "You need a strtoll function"
2025-05-24T14:54:58.5872460Z #endif
2025-05-24T14:54:58.5872518Z }
2025-05-24T14:54:58.5872573Z #else
2025-05-24T14:54:58.5872641Z #ifdef HAVE_BSD_STRTOLL
2025-05-24T14:54:58.5872702Z #undef strtoll
2025-05-24T14:54:58.5872851Z long long int rep_strtoll(const char *str, char **endptr, int base)
2025-05-24T14:54:58.5872907Z {
2025-05-24T14:54:58.5872977Z 	int saved_errno = errno;
2025-05-24T14:54:58.5873076Z 	long long int nb = strtoll(str, endptr, base);
2025-05-24T14:54:58.5873196Z 	/* With glibc EINVAL is only returned if base is not ok */
2025-05-24T14:54:58.5873261Z 	if (errno == EINVAL) {
2025-05-24T14:54:58.5873339Z 		if (base == 0 || (base >1 && base <37)) {
2025-05-24T14:54:58.5873428Z 			/* Base was ok so it's because we were not
2025-05-24T14:54:58.5873503Z 			 * able to make the conversion.
2025-05-24T14:54:58.5873569Z 			 * Let's reset errno.
2025-05-24T14:54:58.5873682Z 			 */
2025-05-24T14:54:58.5873746Z 			errno = saved_errno;
2025-05-24T14:54:58.5873802Z 		}
2025-05-24T14:54:58.5873856Z 	}
2025-05-24T14:54:58.5873920Z 	return nb;
2025-05-24T14:54:58.5873973Z }
2025-05-24T14:54:58.5874045Z #endif /* HAVE_BSD_STRTOLL */
2025-05-24T14:54:58.5874117Z #endif /* HAVE_STRTOLL */
2025-05-24T14:54:58.5874236Z 
2025-05-24T14:54:58.5874240Z 
2025-05-24T14:54:58.5874309Z #ifndef HAVE_STRTOULL
2025-05-24T14:54:58.5874490Z unsigned long long int rep_strtoull(const char *str, char **endptr, int base)
2025-05-24T14:54:58.5874544Z {
2025-05-24T14:54:58.5874609Z #ifdef HAVE_STRTOUQ
2025-05-24T14:54:58.5874687Z 	return strtouq(str, endptr, base);
2025-05-24T14:54:58.5874760Z #elif defined(HAVE___STRTOULL) 
2025-05-24T14:54:58.5874844Z 	return __strtoull(str, endptr, base);
2025-05-24T14:54:58.5874921Z #elif SIZEOF_LONG == SIZEOF_LONG_LONG
2025-05-24T14:54:58.5875050Z 	return (unsigned long long int) strtoul(str, endptr, base);
2025-05-24T14:54:58.5875108Z #else
2025-05-24T14:54:58.5875191Z # error "You need a strtoull function"
2025-05-24T14:54:58.5875246Z #endif
2025-05-24T14:54:58.5875298Z }
2025-05-24T14:54:58.5875524Z #else
2025-05-24T14:54:58.5875642Z #ifdef HAVE_BSD_STRTOLL
2025-05-24T14:54:58.5875711Z #undef strtoull
2025-05-24T14:54:58.5875898Z unsigned long long int rep_strtoull(const char *str, char **endptr, int base)
2025-05-24T14:54:58.5875958Z {
2025-05-24T14:54:58.5876029Z 	int saved_errno = errno;
2025-05-24T14:54:58.5876157Z 	unsigned long long int nb = strtoull(str, endptr, base);
2025-05-24T14:54:58.5876279Z 	/* With glibc EINVAL is only returned if base is not ok */
2025-05-24T14:54:58.5876343Z 	if (errno == EINVAL) {
2025-05-24T14:54:58.5876420Z 		if (base == 0 || (base >1 && base <37)) {
2025-05-24T14:54:58.5876513Z 			/* Base was ok so it's because we were not
2025-05-24T14:54:58.5876588Z 			 * able to make the conversion.
2025-05-24T14:54:58.5876655Z 			 * Let's reset errno.
2025-05-24T14:54:58.5876709Z 			 */
2025-05-24T14:54:58.5876779Z 			errno = saved_errno;
2025-05-24T14:54:58.5876836Z 		}
2025-05-24T14:54:58.5876890Z 	}
2025-05-24T14:54:58.5876949Z 	return nb;
2025-05-24T14:54:58.5877006Z }
2025-05-24T14:54:58.5877078Z #endif /* HAVE_BSD_STRTOLL */
2025-05-24T14:54:58.5877147Z #endif /* HAVE_STRTOULL */
2025-05-24T14:54:58.5877151Z 
2025-05-24T14:54:58.5877218Z #ifndef HAVE_SETENV
2025-05-24T14:54:58.5877374Z int rep_setenv(const char *name, const char *value, int overwrite) 
2025-05-24T14:54:58.5877511Z {
2025-05-24T14:54:58.5877576Z 	char *p;
2025-05-24T14:54:58.5877640Z 	size_t l1, l2;
2025-05-24T14:54:58.5877695Z 	int ret;
2025-05-24T14:54:58.5877699Z 
2025-05-24T14:54:58.5877774Z 	if (!overwrite && getenv(name)) {
2025-05-24T14:54:58.5877836Z 		return 0;
2025-05-24T14:54:58.5877890Z 	}
2025-05-24T14:54:58.5877893Z 
2025-05-24T14:54:58.5877953Z 	l1 = strlen(name);
2025-05-24T14:54:58.5878019Z 	l2 = strlen(value);
2025-05-24T14:54:58.5878022Z 
2025-05-24T14:54:58.5878088Z 	p = malloc(l1+l2+2);
2025-05-24T14:54:58.5878148Z 	if (p == NULL) {
2025-05-24T14:54:58.5878212Z 		return -1;
2025-05-24T14:54:58.5878272Z 	}
2025-05-24T14:54:58.5878337Z 	memcpy(p, name, l1);
2025-05-24T14:54:58.5878396Z 	p[l1] = '=';
2025-05-24T14:54:58.5878473Z 	memcpy(p+l1+1, value, l2);
2025-05-24T14:54:58.5878533Z 	p[l1+l2+1] = 0;
2025-05-24T14:54:58.5878536Z 
2025-05-24T14:54:58.5878602Z 	ret = putenv(p);
2025-05-24T14:54:58.5878664Z 	if (ret != 0) {
2025-05-24T14:54:58.5878727Z 		free(p);
2025-05-24T14:54:58.5878783Z 	}
2025-05-24T14:54:58.5878787Z 
2025-05-24T14:54:58.5878845Z 	return ret;
2025-05-24T14:54:58.5878903Z }
2025-05-24T14:54:58.5878956Z #endif
2025-05-24T14:54:58.5878960Z 
2025-05-24T14:54:58.5879024Z #ifndef HAVE_UNSETENV
2025-05-24T14:54:58.5879101Z int rep_unsetenv(const char *name)
2025-05-24T14:54:58.5879159Z {
2025-05-24T14:54:58.5879227Z 	extern char **environ;
2025-05-24T14:54:58.5879295Z 	size_t len = strlen(name);
2025-05-24T14:54:58.5879363Z 	size_t i, count;
2025-05-24T14:54:58.5879366Z 
2025-05-24T14:54:58.5879457Z 	if (environ == NULL || getenv(name) == NULL) {
2025-05-24T14:54:58.5879588Z 		return 0;
2025-05-24T14:54:58.5879642Z 	}
2025-05-24T14:54:58.5879650Z 
2025-05-24T14:54:58.5879729Z 	for (i=0;environ[i];i++) /* noop */ ;
2025-05-24T14:54:58.5879733Z 
2025-05-24T14:54:58.5879791Z 	count=i;
2025-05-24T14:54:58.5879846Z 	
2025-05-24T14:54:58.5879914Z 	for (i=0;i<count;) {
2025-05-24T14:54:58.5880163Z 		if (strncmp(environ[i], name, len) == 0 && environ[i][len] == '=') {
2025-05-24T14:54:58.5880297Z 			/* note: we do _not_ free the old variable here. It is unsafe to 
2025-05-24T14:54:58.5880412Z 			   do so, as the pointer may not have come from malloc */
2025-05-24T14:54:58.5880549Z 			memmove(&environ[i], &environ[i+1], (count-i)*sizeof(char *));
2025-05-24T14:54:58.5880607Z 			count--;
2025-05-24T14:54:58.5880664Z 		} else {
2025-05-24T14:54:58.5880724Z 			i++;
2025-05-24T14:54:58.5880778Z 		}
2025-05-24T14:54:58.5880833Z 	}
2025-05-24T14:54:58.5880837Z 
2025-05-24T14:54:58.5880899Z 	return 0;
2025-05-24T14:54:58.5880953Z }
2025-05-24T14:54:58.5881010Z #endif
2025-05-24T14:54:58.5881014Z 
2025-05-24T14:54:58.5881078Z #ifndef HAVE_UTIME
2025-05-24T14:54:58.5881221Z int rep_utime(const char *filename, const struct utimbuf *buf)
2025-05-24T14:54:58.5881276Z {
2025-05-24T14:54:58.5881337Z 	errno = ENOSYS;
2025-05-24T14:54:58.5881398Z 	return -1;
2025-05-24T14:54:58.5881453Z }
2025-05-24T14:54:58.5881512Z #endif
2025-05-24T14:54:58.5881516Z 
2025-05-24T14:54:58.5881581Z #ifndef HAVE_UTIMES
2025-05-24T14:54:58.5881725Z int rep_utimes(const char *filename, const struct timeval tv[2])
2025-05-24T14:54:58.5881780Z {
2025-05-24T14:54:58.5881843Z 	struct utimbuf u;
2025-05-24T14:54:58.5881847Z 
2025-05-24T14:54:58.5881915Z 	u.actime = tv[0].tv_sec;
2025-05-24T14:54:58.5881982Z 	if (tv[0].tv_usec > 500000) {
2025-05-24T14:54:58.5882042Z 		u.actime += 1;
2025-05-24T14:54:58.5882096Z 	}
2025-05-24T14:54:58.5882102Z 
2025-05-24T14:54:58.5882197Z 	u.modtime = tv[1].tv_sec;
2025-05-24T14:54:58.5882321Z 	if (tv[1].tv_usec > 500000) {
2025-05-24T14:54:58.5882432Z 		u.modtime += 1;
2025-05-24T14:54:58.5882532Z 	}
2025-05-24T14:54:58.5882537Z 
2025-05-24T14:54:58.5882663Z 	return utime(filename, &u);
2025-05-24T14:54:58.5882753Z }
2025-05-24T14:54:58.5882847Z #endif
2025-05-24T14:54:58.5882853Z 
2025-05-24T14:54:58.5882960Z #ifndef HAVE_DUP2
2025-05-24T14:54:58.5883100Z int rep_dup2(int oldfd, int newfd) 
2025-05-24T14:54:58.5883196Z {
2025-05-24T14:54:58.5883300Z 	errno = ENOSYS;
2025-05-24T14:54:58.5883399Z 	return -1;
2025-05-24T14:54:58.5883556Z }
2025-05-24T14:54:58.5883663Z #endif
2025-05-24T14:54:58.5883669Z 
2025-05-24T14:54:58.5895030Z #ifndef HAVE_CHOWN
2025-05-24T14:54:58.5895151Z /**
2025-05-24T14:54:58.5895586Z chown isn't used much but OS/2 doesn't have it
2025-05-24T14:54:58.5895662Z **/
2025-05-24T14:54:58.5895796Z int rep_chown(const char *fname, uid_t uid, gid_t gid)
2025-05-24T14:54:58.5895856Z {
2025-05-24T14:54:58.5895920Z 	errno = ENOSYS;
2025-05-24T14:54:58.5895984Z 	return -1;
2025-05-24T14:54:58.5896039Z }
2025-05-24T14:54:58.5896094Z #endif
2025-05-24T14:54:58.5896107Z 
2025-05-24T14:54:58.5896175Z #ifndef HAVE_LINK
2025-05-24T14:54:58.5896302Z int rep_link(const char *oldpath, const char *newpath)
2025-05-24T14:54:58.5896356Z {
2025-05-24T14:54:58.5896422Z 	errno = ENOSYS;
2025-05-24T14:54:58.5896487Z 	return -1;
2025-05-24T14:54:58.5896541Z }
2025-05-24T14:54:58.5896595Z #endif
2025-05-24T14:54:58.5896604Z 
2025-05-24T14:54:58.5896675Z #ifndef HAVE_READLINK
2025-05-24T14:54:58.5896812Z int rep_readlink(const char *path, char *buf, size_t bufsiz)
2025-05-24T14:54:58.5896871Z {
2025-05-24T14:54:58.5896933Z 	errno = ENOSYS;
2025-05-24T14:54:58.5896995Z 	return -1;
2025-05-24T14:54:58.5897050Z }
2025-05-24T14:54:58.5897105Z #endif
2025-05-24T14:54:58.5897108Z 
2025-05-24T14:54:58.5897174Z #ifndef HAVE_SYMLINK
2025-05-24T14:54:58.5897299Z int rep_symlink(const char *oldpath, const char *newpath)
2025-05-24T14:54:58.5897352Z {
2025-05-24T14:54:58.5897411Z 	errno = ENOSYS;
2025-05-24T14:54:58.5897476Z 	return -1;
2025-05-24T14:54:58.5897532Z }
2025-05-24T14:54:58.5897705Z #endif
2025-05-24T14:54:58.5897709Z 
2025-05-24T14:54:58.5897779Z #ifndef HAVE_LCHOWN
2025-05-24T14:54:58.5897893Z int rep_lchown(const char *fname,uid_t uid,gid_t gid)
2025-05-24T14:54:58.5897946Z {
2025-05-24T14:54:58.5898006Z 	errno = ENOSYS;
2025-05-24T14:54:58.5898070Z 	return -1;
2025-05-24T14:54:58.5898122Z }
2025-05-24T14:54:58.5898291Z #endif
2025-05-24T14:54:58.5898295Z 
2025-05-24T14:54:58.5898374Z #ifndef HAVE_REALPATH
2025-05-24T14:54:58.5898507Z char *rep_realpath(const char *path, char *resolved_path)
2025-05-24T14:54:58.5898562Z {
2025-05-24T14:54:58.5898700Z 	/* As realpath is not a system call we can't return ENOSYS. */
2025-05-24T14:54:58.5898768Z 	errno = EINVAL;
2025-05-24T14:54:58.5898829Z 	return NULL;
2025-05-24T14:54:58.5898884Z }
2025-05-24T14:54:58.5898940Z #endif
2025-05-24T14:54:58.5898944Z 
2025-05-24T14:54:58.5898948Z 
2025-05-24T14:54:58.5899012Z #ifndef HAVE_MEMMEM
2025-05-24T14:54:58.5899138Z void *rep_memmem(const void *haystack, size_t haystacklen,
2025-05-24T14:54:58.5899228Z 		 const void *needle, size_t needlelen)
2025-05-24T14:54:58.5899282Z {
2025-05-24T14:54:58.5899349Z 	if (needlelen == 0) {
2025-05-24T14:54:58.5899428Z 		return discard_const(haystack);
2025-05-24T14:54:58.5899485Z 	}
2025-05-24T14:54:58.5899563Z 	while (haystacklen >= needlelen) {
2025-05-24T14:54:58.5899689Z 		char *p = (char *)memchr(haystack, *(const char *)needle,
2025-05-24T14:54:58.5899771Z 					 haystacklen-(needlelen-1));
2025-05-24T14:54:58.5899840Z 		if (!p) return NULL;
2025-05-24T14:54:58.5899928Z 		if (memcmp(p, needle, needlelen) == 0) {
2025-05-24T14:54:58.5899988Z 			return p;
2025-05-24T14:54:58.5900047Z 		}
2025-05-24T14:54:58.5900110Z 		haystack = p+1;
2025-05-24T14:54:58.5900219Z 		haystacklen -= (p - (const char *)haystack) + 1;
2025-05-24T14:54:58.5900279Z 	}
2025-05-24T14:54:58.5900339Z 	return NULL;
2025-05-24T14:54:58.5900393Z }
2025-05-24T14:54:58.5900447Z #endif
2025-05-24T14:54:58.5900451Z 
2025-05-24T14:54:58.5900580Z #if !defined(HAVE_VDPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5900709Z int rep_vdprintf(int fd, const char *format, va_list ap)
2025-05-24T14:54:58.5900764Z {
2025-05-24T14:54:58.5900830Z 	char *s = NULL;
2025-05-24T14:54:58.5900888Z 	int ret;
2025-05-24T14:54:58.5900891Z 
2025-05-24T14:54:58.5900968Z 	vasprintf(&s, format, ap);
2025-05-24T14:54:58.5901031Z 	if (s == NULL) {
2025-05-24T14:54:58.5901099Z 		errno = ENOMEM;
2025-05-24T14:54:58.5901161Z 		return -1;
2025-05-24T14:54:58.5901289Z 	}
2025-05-24T14:54:58.5901396Z 	ret = write(fd, s, strlen(s));
2025-05-24T14:54:58.5901676Z 	free(s);
2025-05-24T14:54:58.5901785Z 	return ret;
2025-05-24T14:54:58.5901877Z }
2025-05-24T14:54:58.5901973Z #endif
2025-05-24T14:54:58.5901979Z 
2025-05-24T14:54:58.5902192Z #if !defined(HAVE_DPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5902363Z int rep_dprintf(int fd, const char *format, ...)
2025-05-24T14:54:58.5902461Z {
2025-05-24T14:54:58.5902564Z 	int ret;
2025-05-24T14:54:58.5902626Z 	va_list ap;
2025-05-24T14:54:58.5902630Z 
2025-05-24T14:54:58.5902702Z 	va_start(ap, format);
2025-05-24T14:54:58.5902784Z 	ret = vdprintf(fd, format, ap);
2025-05-24T14:54:58.5902843Z 	va_end(ap);
2025-05-24T14:54:58.5902847Z 
2025-05-24T14:54:58.5902907Z 	return ret;
2025-05-24T14:54:58.5902968Z }
2025-05-24T14:54:58.5903025Z #endif
2025-05-24T14:54:58.5903029Z 
2025-05-24T14:54:58.5903115Z #ifndef HAVE_GET_CURRENT_DIR_NAME
2025-05-24T14:54:58.5903260Z char *rep_get_current_dir_name(void)
2025-05-24T14:54:58.5903370Z {
2025-05-24T14:54:58.5903450Z 	char buf[PATH_MAX+1];
2025-05-24T14:54:58.5903511Z 	char *p;
2025-05-24T14:54:58.5903593Z 	p = getcwd(buf, sizeof(buf));
2025-05-24T14:54:58.5903655Z 	if (p == NULL) {
2025-05-24T14:54:58.5903716Z 		return NULL;
2025-05-24T14:54:58.5903773Z 	}
2025-05-24T14:54:58.5903839Z 	return strdup(p);
2025-05-24T14:54:58.5903899Z }
2025-05-24T14:54:58.5903956Z #endif
2025-05-24T14:54:58.5903959Z 
2025-05-24T14:54:58.5904084Z #ifndef HAVE_STRERROR_R
2025-05-24T14:54:58.5904293Z int rep_strerror_r(int errnum, char *buf, size_t buflen)
2025-05-24T14:54:58.5904425Z {
2025-05-24T14:54:58.5904501Z 	char *s = strerror(errnum);
2025-05-24T14:54:58.5904575Z 	if (strlen(s)+1 > buflen) {
2025-05-24T14:54:58.5904637Z 		errno = ERANGE;
2025-05-24T14:54:58.5904698Z 		return -1;
2025-05-24T14:54:58.5904756Z 	}
2025-05-24T14:54:58.5904825Z 	strncpy(buf, s, buflen);
2025-05-24T14:54:58.5904961Z 	return 0;
2025-05-24T14:54:58.5905018Z }
2025-05-24T14:54:58.5905112Z #elif (!defined(STRERROR_R_XSI_NOT_GNU))
2025-05-24T14:54:58.5905176Z #undef strerror_r
2025-05-24T14:54:58.5905292Z int rep_strerror_r(int errnum, char *buf, size_t buflen)
2025-05-24T14:54:58.5905473Z {
2025-05-24T14:54:58.5905566Z 	char *s = strerror_r(errnum, buf, buflen);
2025-05-24T14:54:58.5905625Z 	if (s == NULL) {
2025-05-24T14:54:58.5905733Z 		/* Shouldn't happen, should always get a string */
2025-05-24T14:54:58.5905798Z 		return EINVAL;
2025-05-24T14:54:58.5905852Z 	}
2025-05-24T14:54:58.5905912Z 	if (s != buf) {
2025-05-24T14:54:58.5905985Z 		strlcpy(buf, s, buflen);
2025-05-24T14:54:58.5906061Z 		if (strlen(s) > buflen - 1) {
2025-05-24T14:54:58.5906123Z 			return ERANGE;
2025-05-24T14:54:58.5906178Z 		}
2025-05-24T14:54:58.5906237Z 	}
2025-05-24T14:54:58.5906295Z 	return 0;
2025-05-24T14:54:58.5906299Z 
2025-05-24T14:54:58.5906356Z }
2025-05-24T14:54:58.5906417Z #endif
2025-05-24T14:54:58.5906425Z 
2025-05-24T14:54:58.5906495Z #ifndef HAVE_CLOCK_GETTIME
2025-05-24T14:54:58.5906630Z int rep_clock_gettime(clockid_t clk_id, struct timespec *tp)
2025-05-24T14:54:58.5906687Z {
2025-05-24T14:54:58.5906757Z 	struct timeval tval;
2025-05-24T14:54:58.5906819Z 	switch (clk_id) {
2025-05-24T14:54:58.5906889Z 		case 0: /* CLOCK_REALTIME :*/
2025-05-24T14:54:58.5907061Z #if defined(HAVE_GETTIMEOFDAY_TZ) || defined(HAVE_GETTIMEOFDAY_TZ_VOID)
2025-05-24T14:54:58.5907136Z 			gettimeofday(&tval,NULL);
2025-05-24T14:54:58.5907192Z #else
2025-05-24T14:54:58.5907259Z 			gettimeofday(&tval);
2025-05-24T14:54:58.5907318Z #endif
2025-05-24T14:54:58.5907388Z 			tp->tv_sec = tval.tv_sec;
2025-05-24T14:54:58.5907468Z 			tp->tv_nsec = tval.tv_usec * 1000;
2025-05-24T14:54:58.5907528Z 			break;
2025-05-24T14:54:58.5907585Z 		default:
2025-05-24T14:54:58.5907646Z 			errno = EINVAL;
2025-05-24T14:54:58.5907705Z 			return -1;
2025-05-24T14:54:58.5907765Z 	}
2025-05-24T14:54:58.5907824Z 	return 0;
2025-05-24T14:54:58.5907880Z }
2025-05-24T14:54:58.5907939Z #endif
2025-05-24T14:54:58.5907947Z 
2025-05-24T14:54:58.5908014Z #ifndef HAVE_MEMALIGN
2025-05-24T14:54:58.5908198Z void *rep_memalign( size_t align, size_t size )
2025-05-24T14:54:58.5908252Z {
2025-05-24T14:54:58.5908334Z #if defined(HAVE_POSIX_MEMALIGN)
2025-05-24T14:54:58.5908398Z 	void *p = NULL;
2025-05-24T14:54:58.5908492Z 	int ret = posix_memalign( &p, align, size );
2025-05-24T14:54:58.5908557Z 	if ( ret == 0 )
2025-05-24T14:54:58.5908618Z 		return p;
2025-05-24T14:54:58.5908622Z 
2025-05-24T14:54:58.5908681Z 	return NULL;
2025-05-24T14:54:58.5908737Z #else
2025-05-24T14:54:58.5908865Z 	/* On *BSD systems memaligns doesn't exist, but memory will
2025-05-24T14:54:58.5908964Z 	 * be aligned on allocations of > pagesize. */
2025-05-24T14:54:58.5909039Z #if defined(SYSCONF_SC_PAGESIZE)
2025-05-24T14:54:58.5909145Z 	size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);
2025-05-24T14:54:58.5909220Z #elif defined(HAVE_GETPAGESIZE)
2025-05-24T14:54:58.5909311Z 	size_t pagesize = (size_t)getpagesize();
2025-05-24T14:54:58.5909366Z #else
2025-05-24T14:54:58.5909445Z 	size_t pagesize = (size_t)-1;
2025-05-24T14:54:58.5909503Z #endif
2025-05-24T14:54:58.5909575Z 	if (pagesize == (size_t)-1) {
2025-05-24T14:54:58.5909640Z 		errno = ENOSYS;
2025-05-24T14:54:58.5909699Z 		return NULL;
2025-05-24T14:54:58.5909753Z 	}
2025-05-24T14:54:58.5909821Z 	if (size < pagesize) {
2025-05-24T14:54:58.5909890Z 		size = pagesize;
2025-05-24T14:54:58.5909944Z 	}
2025-05-24T14:54:58.5910010Z 	return malloc(size);
2025-05-24T14:54:58.5910069Z #endif
2025-05-24T14:54:58.5910124Z }
2025-05-24T14:54:58.5910179Z #endif
2025-05-24T14:54:58.5910183Z 
2025-05-24T14:54:58.5910251Z #ifndef HAVE_GETPEEREID
2025-05-24T14:54:58.5910425Z int rep_getpeereid(int s, uid_t *uid, gid_t *gid)
2025-05-24T14:54:58.5910478Z {
2025-05-24T14:54:58.5910549Z #if defined(HAVE_PEERCRED)
2025-05-24T14:54:58.5910615Z 	struct ucred cred;
2025-05-24T14:54:58.5910703Z 	socklen_t cred_len = sizeof(struct ucred);
2025-05-24T14:54:58.5910864Z 	int ret;
2025-05-24T14:54:58.5910869Z 
2025-05-24T14:54:58.5910933Z #undef getsockopt
2025-05-24T14:54:58.5911090Z 	ret = getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void *)&cred, &cred_len);
2025-05-24T14:54:58.5911156Z 	if (ret != 0) {
2025-05-24T14:54:58.5911215Z 		return -1;
2025-05-24T14:54:58.5911271Z 	}
2025-05-24T14:54:58.5911275Z 
2025-05-24T14:54:58.5911360Z 	if (cred_len != sizeof(struct ucred)) {
2025-05-24T14:54:58.5911421Z 		errno = EINVAL;
2025-05-24T14:54:58.5911484Z 		return -1;
2025-05-24T14:54:58.5911538Z 	}
2025-05-24T14:54:58.5911545Z 
2025-05-24T14:54:58.5911603Z 	*uid = cred.uid;
2025-05-24T14:54:58.5911663Z 	*gid = cred.gid;
2025-05-24T14:54:58.5911720Z 	return 0;
2025-05-24T14:54:58.5911777Z #else
2025-05-24T14:54:58.5911836Z 	errno = ENOSYS;
2025-05-24T14:54:58.5911894Z 	return -1;
2025-05-24T14:54:58.5911950Z #endif
2025-05-24T14:54:58.5912008Z }
2025-05-24T14:54:58.5912061Z #endif
2025-05-24T14:54:58.5912064Z 
2025-05-24T14:54:58.5912128Z #ifndef HAVE_USLEEP
2025-05-24T14:54:58.5912213Z int rep_usleep(useconds_t sec)
2025-05-24T14:54:58.5912268Z {
2025-05-24T14:54:58.5912335Z 	struct timeval tval;
2025-05-24T14:54:58.5912392Z 	/*
2025-05-24T14:54:58.5912463Z 	 * Fake it with select...
2025-05-24T14:54:58.5912516Z 	 */
2025-05-24T14:54:58.5912582Z 	tval.tv_sec = 0;
2025-05-24T14:54:58.5912654Z 	tval.tv_usec = usecs/1000;
2025-05-24T14:54:58.5912730Z 	select(0,NULL,NULL,NULL,&tval);
2025-05-24T14:54:58.5912788Z 	return 0;
2025-05-24T14:54:58.5912843Z }
2025-05-24T14:54:58.5912916Z #endif /* HAVE_USLEEP */
2025-05-24T14:54:58.5912920Z 
2025-05-24T14:54:58.5912989Z #ifndef HAVE_SETPROCTITLE
2025-05-24T14:54:58.5913078Z void rep_setproctitle(const char *fmt, ...)
2025-05-24T14:54:58.5913137Z {
2025-05-24T14:54:58.5913194Z }
2025-05-24T14:54:58.5913248Z #endif
2025-05-24T14:54:58.5913323Z #ifndef HAVE_SETPROCTITLE_INIT
2025-05-24T14:54:58.5913472Z void rep_setproctitle_init(int argc, char *argv[], char *envp[])
2025-05-24T14:54:58.5913528Z {
2025-05-24T14:54:58.5913582Z }
2025-05-24T14:54:58.5913644Z #endif
2025-05-24T14:54:58.5913648Z 
2025-05-24T14:54:58.5913714Z #ifndef HAVE_MEMSET_S
2025-05-24T14:54:58.5913851Z # ifndef RSIZE_MAX
2025-05-24T14:54:58.5913927Z #  define RSIZE_MAX (SIZE_MAX >> 1)
2025-05-24T14:54:58.5913988Z # endif
2025-05-24T14:54:58.5913992Z 
2025-05-24T14:54:58.5914130Z int rep_memset_s(void *dest, size_t destsz, int ch, size_t count)
2025-05-24T14:54:58.5914185Z {
2025-05-24T14:54:58.5914252Z 	if (dest == NULL) {
2025-05-24T14:54:58.5914312Z 		return EINVAL;
2025-05-24T14:54:58.5914366Z 	}
2025-05-24T14:54:58.5914369Z 
2025-05-24T14:54:58.5914438Z 	if (destsz > RSIZE_MAX ||
2025-05-24T14:54:58.5914508Z 	    count > RSIZE_MAX ||
2025-05-24T14:54:58.5914571Z 	    count > destsz) {
2025-05-24T14:54:58.5914631Z 		return ERANGE;
2025-05-24T14:54:58.5914688Z 	}
2025-05-24T14:54:58.5914691Z 
2025-05-24T14:54:58.5914771Z #if defined(HAVE_MEMSET_EXPLICIT)
2025-05-24T14:54:58.5914858Z 	memset_explicit(dest, destsz, ch, count);
2025-05-24T14:54:58.5914936Z #else /* HAVE_MEMSET_EXPLICIT */
2025-05-24T14:54:58.5915007Z 	memset(dest, ch, count);
2025-05-24T14:54:58.5915105Z # if defined(HAVE_GCC_VOLATILE_MEMORY_PROTECTION)
2025-05-24T14:54:58.5915224Z 	/* See http://llvm.org/bugs/show_bug.cgi?id=15495 */
2025-05-24T14:54:58.5915318Z 	__asm__ volatile("" : : "g"(dest) : "memory");
2025-05-24T14:54:58.5915636Z # endif /* HAVE_GCC_VOLATILE_MEMORY_PROTECTION */
2025-05-24T14:54:58.5915840Z #endif /* HAVE_MEMSET_EXPLICIT */
2025-05-24T14:54:58.5915845Z 
2025-05-24T14:54:58.5915911Z 	return 0;
2025-05-24T14:54:58.5915967Z }
2025-05-24T14:54:58.5916036Z #endif /* HAVE_MEMSET_S */
2025-05-24T14:54:58.5916040Z 
2025-05-24T14:54:58.5916111Z #ifndef HAVE_GETPROGNAME
2025-05-24T14:54:58.5916297Z # ifndef HAVE_PROGRAM_INVOCATION_SHORT_NAME
2025-05-24T14:54:58.5916367Z # define PROGNAME_SIZE 32
2025-05-24T14:54:58.5916453Z static char rep_progname[PROGNAME_SIZE];
2025-05-24T14:54:58.5916555Z # endif /* HAVE_PROGRAM_INVOCATION_SHORT_NAME */
2025-05-24T14:54:58.5916559Z 
2025-05-24T14:54:58.5916742Z const char *rep_getprogname(void)
2025-05-24T14:54:58.5916801Z {
2025-05-24T14:54:58.5916891Z #ifdef HAVE_PROGRAM_INVOCATION_SHORT_NAME
2025-05-24T14:54:58.5916974Z 	return program_invocation_short_name;
2025-05-24T14:54:58.5917067Z #else /* HAVE_PROGRAM_INVOCATION_SHORT_NAME */
2025-05-24T14:54:58.5917128Z 	FILE *fp = NULL;
2025-05-24T14:54:58.5917202Z 	char cmdline[4096] = {0};
2025-05-24T14:54:58.5917263Z 	char *p = NULL;
2025-05-24T14:54:58.5917340Z 	pid_t pid;
2025-05-24T14:54:58.5917462Z 	size_t nread;
2025-05-24T14:54:58.5917569Z 	int len;
2025-05-24T14:54:58.5917662Z 	int rc;
2025-05-24T14:54:58.5917668Z 
2025-05-24T14:54:58.5917786Z 	if (rep_progname[0] != '\0') {
2025-05-24T14:54:58.5917906Z 		return rep_progname;
2025-05-24T14:54:58.5917995Z 	}
2025-05-24T14:54:58.5918000Z 
2025-05-24T14:54:58.5918271Z 	len = snprintf(rep_progname, sizeof(rep_progname), "%s", "<unknown>");
2025-05-24T14:54:58.5918373Z 	if (len <= 0) {
2025-05-24T14:54:58.5918483Z 		return NULL;
2025-05-24T14:54:58.5918556Z 	}
2025-05-24T14:54:58.5918563Z 
2025-05-24T14:54:58.5918629Z 	pid = getpid();
2025-05-24T14:54:58.5918707Z 	if (pid <= 1 || pid == (pid_t)-1) {
2025-05-24T14:54:58.5918769Z 		return NULL;
2025-05-24T14:54:58.5918823Z 	}
2025-05-24T14:54:58.5918826Z 
2025-05-24T14:54:58.5918898Z 	len = snprintf(cmdline,
2025-05-24T14:54:58.5918965Z 		       sizeof(cmdline),
2025-05-24T14:54:58.5919056Z 		       "/proc/%u/cmdline",
2025-05-24T14:54:58.5919188Z 		       (unsigned int)pid);
2025-05-24T14:54:58.5919309Z 	if (len <= 0 || len == sizeof(cmdline)) {
2025-05-24T14:54:58.5919369Z 		return NULL;
2025-05-24T14:54:58.5919424Z 	}
2025-05-24T14:54:58.5919428Z 
2025-05-24T14:54:58.5919505Z 	fp = fopen(cmdline, "r");
2025-05-24T14:54:58.5919569Z 	if (fp == NULL) {
2025-05-24T14:54:58.5919631Z 		return NULL;
2025-05-24T14:54:58.5919688Z 	}
2025-05-24T14:54:58.5919691Z 
2025-05-24T14:54:58.5919798Z 	nread = fread(cmdline, 1, sizeof(cmdline) - 1, fp);
2025-05-24T14:54:58.5919801Z 
2025-05-24T14:54:58.5919873Z 	rc = fclose(fp);
2025-05-24T14:54:58.5919992Z 	if (rc != 0) {
2025-05-24T14:54:58.5920105Z 		return NULL;
2025-05-24T14:54:58.5920171Z 	}
2025-05-24T14:54:58.5920263Z 
2025-05-24T14:54:58.5920330Z 	if (nread == 0) {
2025-05-24T14:54:58.5920393Z 		return NULL;
2025-05-24T14:54:58.5920447Z 	}
2025-05-24T14:54:58.5920451Z 
2025-05-24T14:54:58.5920517Z 	cmdline[nread] = '\0';
2025-05-24T14:54:58.5920521Z 
2025-05-24T14:54:58.5920597Z 	p = strrchr(cmdline, '/');
2025-05-24T14:54:58.5920657Z 	if (p != NULL) {
2025-05-24T14:54:58.5920713Z 		p++;
2025-05-24T14:54:58.5920769Z 	} else {
2025-05-24T14:54:58.5920833Z 		p = cmdline;
2025-05-24T14:54:58.5920887Z 	}
2025-05-24T14:54:58.5920891Z 
2025-05-24T14:54:58.5920954Z 	len = strlen(p);
2025-05-24T14:54:58.5921030Z 	if (len > PROGNAME_SIZE) {
2025-05-24T14:54:58.5921107Z 		p[PROGNAME_SIZE - 1] = '\0';
2025-05-24T14:54:58.5921162Z 	}
2025-05-24T14:54:58.5921165Z 
2025-05-24T14:54:58.5921304Z 	(void)snprintf(rep_progname, sizeof(rep_progname), "%s", p);
2025-05-24T14:54:58.5921308Z 
2025-05-24T14:54:58.5921382Z 	return rep_progname;
2025-05-24T14:54:58.5921481Z #endif /* HAVE_PROGRAM_INVOCATION_SHORT_NAME */
2025-05-24T14:54:58.5921538Z }
2025-05-24T14:54:58.5921619Z #endif /* HAVE_GETPROGNAME */
2025-05-24T14:54:58.5921623Z 
2025-05-24T14:54:58.5921694Z #ifndef HAVE_COPY_FILE_RANGE
2025-05-24T14:54:58.5921778Z ssize_t rep_copy_file_range(int fd_in,
2025-05-24T14:54:58.5921842Z 			    loff_t *off_in,
2025-05-24T14:54:58.5921906Z 			    int fd_out,
2025-05-24T14:54:58.5921973Z 			    loff_t *off_out,
2025-05-24T14:54:58.5922031Z 			    size_t len,
2025-05-24T14:54:58.5922103Z 			    unsigned int flags)
2025-05-24T14:54:58.5922157Z {
2025-05-24T14:54:58.5922235Z # ifdef HAVE_SYSCALL_COPY_FILE_RANGE
2025-05-24T14:54:58.5922365Z 	return syscall(__NR_copy_file_range,
2025-05-24T14:54:58.5922425Z 		       fd_in,
2025-05-24T14:54:58.5922483Z 		       off_in,
2025-05-24T14:54:58.5922540Z 		       fd_out,
2025-05-24T14:54:58.5922602Z 		       off_out,
2025-05-24T14:54:58.5922658Z 		       len,
2025-05-24T14:54:58.5922793Z 		       flags);
2025-05-24T14:54:58.5922878Z # endif /* HAVE_SYSCALL_COPY_FILE_RANGE */
2025-05-24T14:54:58.5922946Z 	errno = ENOSYS;
2025-05-24T14:54:58.5923006Z 	return -1;
2025-05-24T14:54:58.5923061Z }
2025-05-24T14:54:58.5923137Z #endif /* HAVE_COPY_FILE_RANGE */
2025-05-24T14:54:58.5923141Z 
2025-05-24T14:54:58.5923206Z #ifndef HAVE_OPENAT2
2025-05-24T14:54:58.5923210Z 
2025-05-24T14:54:58.5923315Z /* fallback known wellknown __NR_openat2 values */
2025-05-24T14:54:58.5923381Z #ifndef __NR_openat2
2025-05-24T14:54:58.5923476Z # if defined(LINUX) && defined(HAVE_SYS_SYSCALL_H)
2025-05-24T14:54:58.5923541Z #  if defined(__i386__)
2025-05-24T14:54:58.5923611Z #   define __NR_openat2 437
2025-05-24T14:54:58.5923704Z #  elif defined(__x86_64__) && defined(__LP64__)
2025-05-24T14:54:58.5923784Z #   define __NR_openat2 437 /* 437 0x1B5 */
2025-05-24T14:54:58.5923873Z #  elif defined(__x86_64__) && defined(__ILP32__)
2025-05-24T14:54:58.5923992Z #   define __NR_openat2 1073742261 /* 1073742261 0x400001B5 */
2025-05-24T14:54:58.5924065Z #  elif defined(__aarch64__)
2025-05-24T14:54:58.5924133Z #   define __NR_openat2 437
2025-05-24T14:54:58.5924200Z #  elif defined(__arm__)
2025-05-24T14:54:58.5924271Z #   define __NR_openat2 437
2025-05-24T14:54:58.5924339Z #  elif defined(__sparc__)
2025-05-24T14:54:58.5924406Z #   define __NR_openat2 437
2025-05-24T14:54:58.5924467Z #  endif
2025-05-24T14:54:58.5924589Z # endif /* defined(LINUX) && defined(HAVE_SYS_SYSCALL_H) */
2025-05-24T14:54:58.5924656Z #endif /* !__NR_openat2 */
2025-05-24T14:54:58.5924659Z 
2025-05-24T14:54:58.5924723Z #ifdef DISABLE_OPATH
2025-05-24T14:54:58.5924781Z /*
2025-05-24T14:54:58.5924879Z  * systems without O_PATH also don't have openat2,
2025-05-24T14:54:58.5924974Z  * so make sure we at a realistic combination.
2025-05-24T14:54:58.5925033Z  */
2025-05-24T14:54:58.5925097Z #undef __NR_openat2
2025-05-24T14:54:58.5925166Z #endif /* DISABLE_OPATH */
2025-05-24T14:54:58.5925170Z 
2025-05-24T14:54:58.5925278Z long rep_openat2(int dirfd, const char *pathname,
2025-05-24T14:54:58.5925498Z 		 struct open_how *how, size_t size)
2025-05-24T14:54:58.5925555Z {
2025-05-24T14:54:58.5925693Z #ifdef __NR_openat2
2025-05-24T14:54:58.5925868Z #if _FILE_OFFSET_BITS == 64 && SIZE_MAX == 0xffffffffUL && defined(O_LARGEFILE)
2025-05-24T14:54:58.5925937Z 	struct open_how __how;
2025-05-24T14:54:58.5925941Z 
2025-05-24T14:54:58.5926033Z #if defined(O_PATH) && ! defined(DISABLE_OPATH)
2025-05-24T14:54:58.5926113Z 	if ((how->flags & O_PATH) == 0)
2025-05-24T14:54:58.5926170Z #endif
2025-05-24T14:54:58.5926224Z 	{
2025-05-24T14:54:58.5926294Z 		if (sizeof(__how) == size) {
2025-05-24T14:54:58.5926359Z 			__how = *how;
2025-05-24T14:54:58.5926365Z 
2025-05-24T14:54:58.5926434Z 			__how.flags |= O_LARGEFILE;
2025-05-24T14:54:58.5926493Z 			how = &__how;
2025-05-24T14:54:58.5926551Z 		}
2025-05-24T14:54:58.5926604Z 	}
2025-05-24T14:54:58.5926662Z #endif
2025-05-24T14:54:58.5926665Z 
2025-05-24T14:54:58.5926738Z 	return syscall(__NR_openat2,
2025-05-24T14:54:58.5926803Z 		       dirfd,
2025-05-24T14:54:58.5926864Z 		       pathname,
2025-05-24T14:54:58.5926920Z 		       how,
2025-05-24T14:54:58.5926981Z 		       size);
2025-05-24T14:54:58.5927035Z #else
2025-05-24T14:54:58.5927095Z 	errno = ENOSYS;
2025-05-24T14:54:58.5927156Z 	return -1;
2025-05-24T14:54:58.5927214Z #endif
2025-05-24T14:54:58.5927267Z }
2025-05-24T14:54:58.5927341Z #endif /* !HAVE_OPENAT2 */
2025-05-24T14:54:58.5927404Z -------------------
2025-05-24T14:54:58.5927484Z Content of lib/replace/snprintf.c:
2025-05-24T14:54:58.5927538Z /*
2025-05-24T14:54:58.5927696Z  * NOTE: If you change this file, please merge it into rsync, samba, etc.
2025-05-24T14:54:58.5927750Z  */
2025-05-24T14:54:58.5927818Z 
2025-05-24T14:54:58.5927871Z /*
2025-05-24T14:54:58.5927948Z  * Copyright Patrick Powell 1995
2025-05-24T14:54:58.5928125Z  * This code is based on code written by Patrick Powell (papowell@astart.com)
2025-05-24T14:54:58.5928274Z  * It may be used for any purpose as long as this notice remains intact
2025-05-24T14:54:58.5928456Z  * on all source code distributions
2025-05-24T14:54:58.5928516Z  */
2025-05-24T14:54:58.5928520Z 
2025-05-24T14:54:58.5928601Z /**************************************************************
2025-05-24T14:54:58.5928659Z  * Original:
2025-05-24T14:54:58.5928756Z  * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
2025-05-24T14:54:58.5928858Z  * A bombproof version of doprnt (dopr) included.
2025-05-24T14:54:58.5929003Z  * Sigh.  This sort of thing is always nasty do deal with.  Note that
2025-05-24T14:54:58.5929114Z  * the version here does not include floating point...
2025-05-24T14:54:58.5929170Z  *
2025-05-24T14:54:58.5929309Z  * snprintf() is used instead of sprintf() as it does limit checks
2025-05-24T14:54:58.5929418Z  * for string length.  This covers a nasty loophole.
2025-05-24T14:54:58.5929478Z  *
2025-05-24T14:54:58.5929614Z  * The other functions are there to prevent NULL pointers from
2025-05-24T14:54:58.5929685Z  * causing nasty effects.
2025-05-24T14:54:58.5929738Z  *
2025-05-24T14:54:58.5929806Z  * More Recently:
2025-05-24T14:54:58.5929920Z  *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
2025-05-24T14:54:58.5930057Z  *  This was ugly.  It is still ugly.  I opted out of floating point
2025-05-24T14:54:58.5930197Z  *  numbers, but the formatter understands just about everything
2025-05-24T14:54:58.5930343Z  *  from the normal C string format, at least as far as I can tell from
2025-05-24T14:54:58.5930425Z  *  the Solaris 2.5 printf(3S) man page.
2025-05-24T14:54:58.5930484Z  *
2025-05-24T14:54:58.5930603Z  *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
2025-05-24T14:54:58.5930742Z  *    Ok, added some minimal floating point support, which means this
2025-05-24T14:54:58.5930884Z  *    probably requires libm on most operating systems.  Don't yet
2025-05-24T14:54:58.5931018Z  *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
2025-05-24T14:54:58.5931155Z  *    was pretty badly broken, it just wasn't being exercised in ways
2025-05-24T14:54:58.5931295Z  *    which showed it, so that's been fixed.  Also, formatted the code
2025-05-24T14:54:58.5931435Z  *    to mutt conventions, and removed dead code left over from the
2025-05-24T14:54:58.5931640Z  *    original.  Also, there is now a builtin-test, just compile with:
2025-05-24T14:54:58.5931750Z  *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
2025-05-24T14:54:58.5931832Z  *    and run snprintf for results.
2025-05-24T14:54:58.5931886Z  *
2025-05-24T14:54:58.5932010Z  *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
2025-05-24T14:54:58.5932123Z  *    The PGP code was using unsigned hexadecimal formats.
2025-05-24T14:54:58.5932241Z  *    Unfortunately, unsigned formats simply didn't work.
2025-05-24T14:54:58.5932298Z  *
2025-05-24T14:54:58.5932411Z  *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
2025-05-24T14:54:58.5932571Z  *    The original code assumed that both snprintf() and vsnprintf() were
2025-05-24T14:54:58.5932722Z  *    missing.  Some systems only have snprintf() but not vsnprintf(), so
2025-05-24T14:54:58.5932861Z  *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
2025-05-24T14:54:58.5932920Z  *
2025-05-24T14:54:58.5933012Z  *  Andrew Tridgell (tridge@samba.org) Oct 1998
2025-05-24T14:54:58.5933083Z  *    fixed handling of %.0f
2025-05-24T14:54:58.5933161Z  *    added test for HAVE_LONG_DOUBLE
2025-05-24T14:54:58.5933218Z  *
2025-05-24T14:54:58.5933311Z  * tridge@samba.org, idra@samba.org, April 2001
2025-05-24T14:54:58.5933431Z  *    got rid of fcvt code (twas buggy and made testing harder)
2025-05-24T14:54:58.5933502Z  *    added C99 semantics
2025-05-24T14:54:58.5933556Z  *
2025-05-24T14:54:58.5933689Z  * date: 2002/12/19 19:56:31;  author: herb;  state: Exp;  lines: +2 -0
2025-05-24T14:54:58.5933897Z  * actually print args for %g and %e
2025-05-24T14:54:58.5934001Z  *
2025-05-24T14:54:58.5934231Z  * date: 2002/06/03 13:37:52;  author: jmcd;  state: Exp;  lines: +8 -0
2025-05-24T14:54:58.5934831Z  * Since includes.h isn't included here, VA_COPY has to be defined here.  I don't
2025-05-24T14:54:58.5935107Z  * see any include file that is guaranteed to be here, so I'm defining it
2025-05-24T14:54:58.5935204Z  * locally.  Fixes AIX and Solaris builds.
2025-05-24T14:54:58.5935260Z  *
2025-05-24T14:54:58.5935600Z  * date: 2002/06/03 03:07:24;  author: tridge;  state: Exp;  lines: +5 -13
2025-05-24T14:54:58.5935755Z  * put the ifdef for HAVE_VA_COPY in one place rather than in lots of
2025-05-24T14:54:58.5935813Z  * functions
2025-05-24T14:54:58.5935873Z  *
2025-05-24T14:54:58.5936088Z  * date: 2002/05/17 14:51:22;  author: jmcd;  state: Exp;  lines: +21 -4
2025-05-24T14:54:58.5936282Z  * Fix usage of va_list passed as an arg.  Use __va_copy before using it
2025-05-24T14:54:58.5936349Z  * when it exists.
2025-05-24T14:54:58.5936405Z  *
2025-05-24T14:54:58.5936538Z  * date: 2002/04/16 22:38:04;  author: idra;  state: Exp;  lines: +20 -14
2025-05-24T14:54:58.5936631Z  * Fix incorrect zpadlen handling in fmtfp.
2025-05-24T14:54:58.5936816Z  * Thanks to Ollie Oldham <ollie.oldham@metro-optix.com> for spotting it.
2025-05-24T14:54:58.5937011Z  * few mods to make it easier to compile the tests.
2025-05-24T14:54:58.5937131Z  * added the "Ollie" test to the floating point ones.
2025-05-24T14:54:58.5937186Z  *
2025-05-24T14:54:58.5937273Z  * Martin Pool (mbp@samba.org) April 2003
2025-05-24T14:54:58.5937428Z  *    Remove NO_CONFIG_H so that the test case can be built within a source
2025-05-24T14:54:58.5937499Z  *    tree with less trouble.
2025-05-24T14:54:58.5937593Z  *    Remove unnecessary SAFE_FREE() definition.
2025-05-24T14:54:58.5937654Z  *
2025-05-24T14:54:58.5937734Z  * Martin Pool (mbp@samba.org) May 2003
2025-05-24T14:54:58.5937881Z  *    Put in a prototype for dummy_snprintf() to quiet compiler warnings.
2025-05-24T14:54:58.5937939Z  *
2025-05-24T14:54:58.5938071Z  *    Move #endif to make sure VA_COPY, LDOUBLE, etc are defined even
2025-05-24T14:54:58.5938179Z  *    if the C library has some snprintf functions already.
2025-05-24T14:54:58.5938236Z  *
2025-05-24T14:54:58.5938324Z  * Darren Tucker (dtucker@zip.com.au) 2005
2025-05-24T14:54:58.5938459Z  *    Fix bug allowing read overruns of the source string with "%.*s"
2025-05-24T14:54:58.5938717Z  *    Usually harmless unless the read runs outside the process' allocation
2025-05-24T14:54:58.5938868Z  *    (eg if your malloc does guard pages) in which case it will segfault.
2025-05-24T14:54:58.5938960Z  *    From OpenSSH.  Also added test for same.
2025-05-24T14:54:58.5939016Z  *
2025-05-24T14:54:58.5939095Z  * Simo Sorce (idra@samba.org) Jan 2006
2025-05-24T14:54:58.5939149Z  *
2025-05-24T14:54:58.5939256Z  *    Add support for position independent parameters
2025-05-24T14:54:58.5939361Z  *    fix fmtstr now it conforms to sprintf wrt min.max
2025-05-24T14:54:58.5939417Z  *
2025-05-24T14:54:58.5939494Z  **************************************************************/
2025-05-24T14:54:58.5939499Z 
2025-05-24T14:54:58.5939566Z #include "replace.h"
2025-05-24T14:54:58.5939639Z #include "system/locale.h"
2025-05-24T14:54:58.5939646Z 
2025-05-24T14:54:58.5939783Z #ifdef TEST_SNPRINTF /* need math library headers for testing */
2025-05-24T14:54:58.5939789Z 
2025-05-24T14:54:58.5939935Z /* In test mode, we pretend that this system doesn't have any snprintf
2025-05-24T14:54:58.5940038Z  * functions, regardless of what config.h says. */
2025-05-24T14:54:58.5940104Z #  undef HAVE_SNPRINTF
2025-05-24T14:54:58.5940170Z #  undef HAVE_VSNPRINTF
2025-05-24T14:54:58.5940241Z #  undef HAVE_C99_VSNPRINTF
2025-05-24T14:54:58.5940310Z #  undef HAVE_ASPRINTF
2025-05-24T14:54:58.5940374Z #  undef HAVE_VASPRINTF
2025-05-24T14:54:58.5940437Z #  include <math.h>
2025-05-24T14:54:58.5940508Z #endif /* TEST_SNPRINTF */
2025-05-24T14:54:58.5940577Z 
2025-05-24T14:54:58.5940770Z #if defined(HAVE_SNPRINTF) && defined(HAVE_VSNPRINTF) && defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5940932Z /* only include stdio.h if we are not re-defining snprintf or vsnprintf */
2025-05-24T14:54:58.5941001Z #include <stdio.h>
2025-05-24T14:54:58.5941201Z  /* make the compiler happy with an empty file */
2025-05-24T14:54:58.5941280Z  void dummy_snprintf(void);
2025-05-24T14:54:58.5941356Z  void dummy_snprintf(void) {}
2025-05-24T14:54:58.5941434Z #endif /* HAVE_SNPRINTF, etc */
2025-05-24T14:54:58.5941438Z 
2025-05-24T14:54:58.5941574Z /* yes this really must be a ||. Don't muck with this (tridge) */
2025-05-24T14:54:58.5941699Z #if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.5941703Z 
2025-05-24T14:54:58.5941776Z #ifdef HAVE_LONG_DOUBLE
2025-05-24T14:54:58.5941847Z #define LDOUBLE long double
2025-05-24T14:54:58.5941906Z #else
2025-05-24T14:54:58.5941974Z #define LDOUBLE double
2025-05-24T14:54:58.5942029Z #endif
2025-05-24T14:54:58.5942033Z 
2025-05-24T14:54:58.5942096Z #ifdef HAVE_LONG_LONG
2025-05-24T14:54:58.5942161Z #define LLONG long long
2025-05-24T14:54:58.5942217Z #else
2025-05-24T14:54:58.5942279Z #define LLONG long
2025-05-24T14:54:58.5942333Z #endif
2025-05-24T14:54:58.5942336Z 
2025-05-24T14:54:58.5942403Z #ifndef VA_COPY
2025-05-24T14:54:58.5942467Z #ifdef HAVE_VA_COPY
2025-05-24T14:54:58.5942560Z #define VA_COPY(dest, src) va_copy(dest, src)
2025-05-24T14:54:58.5942617Z #else
2025-05-24T14:54:58.5942684Z #ifdef HAVE___VA_COPY
2025-05-24T14:54:58.5942778Z #define VA_COPY(dest, src) __va_copy(dest, src)
2025-05-24T14:54:58.5942833Z #else
2025-05-24T14:54:58.5942917Z #define VA_COPY(dest, src) (dest) = (src)
2025-05-24T14:54:58.5942970Z #endif
2025-05-24T14:54:58.5943022Z #endif
2025-05-24T14:54:58.5943026Z 
2025-05-24T14:54:58.5943078Z /*
2025-05-24T14:54:58.5943163Z  * dopr(): poor man's version of doprintf
2025-05-24T14:54:58.5943217Z  */
2025-05-24T14:54:58.5943220Z 
2025-05-24T14:54:58.5943290Z /* format read states */
2025-05-24T14:54:58.5943358Z #define DP_S_DEFAULT 0
2025-05-24T14:54:58.5943424Z #define DP_S_FLAGS   1
2025-05-24T14:54:58.5943487Z #define DP_S_MIN     2
2025-05-24T14:54:58.5943554Z #define DP_S_DOT     3
2025-05-24T14:54:58.5943618Z #define DP_S_MAX     4
2025-05-24T14:54:58.5943684Z #define DP_S_MOD     5
2025-05-24T14:54:58.5943746Z #define DP_S_CONV    6
2025-05-24T14:54:58.5943813Z #define DP_S_DONE    7
2025-05-24T14:54:58.5943867Z 
2025-05-24T14:54:58.5943940Z /* format flags - Bits */
2025-05-24T14:54:58.5944009Z #define DP_F_MINUS	(1 << 0)
2025-05-24T14:54:58.5944078Z #define DP_F_PLUS	(1 << 1)
2025-05-24T14:54:58.5944149Z #define DP_F_SPACE	(1 << 2)
2025-05-24T14:54:58.5944215Z #define DP_F_NUM	(1 << 3)
2025-05-24T14:54:58.5944281Z #define DP_F_ZERO	(1 << 4)
2025-05-24T14:54:58.5944350Z #define DP_F_UP		(1 << 5)
2025-05-24T14:54:58.5944425Z #define DP_F_UNSIGNED	(1 << 6)
2025-05-24T14:54:58.5944429Z 
2025-05-24T14:54:58.5944494Z /* Conversion Flags */
2025-05-24T14:54:58.5944562Z #define DP_C_CHAR    1
2025-05-24T14:54:58.5944629Z #define DP_C_SHORT   2
2025-05-24T14:54:58.5944691Z #define DP_C_LONG    3
2025-05-24T14:54:58.5944755Z #define DP_C_LDOUBLE 4
2025-05-24T14:54:58.5944821Z #define DP_C_LLONG   5
2025-05-24T14:54:58.5944884Z #define DP_C_SIZET   6
2025-05-24T14:54:58.5944888Z 
2025-05-24T14:54:58.5944952Z /* Chunk types */
2025-05-24T14:54:58.5945018Z #define CNK_FMT_STR 0
2025-05-24T14:54:58.5945082Z #define CNK_INT     1
2025-05-24T14:54:58.5945144Z #define CNK_OCTAL   2
2025-05-24T14:54:58.5945205Z #define CNK_UINT    3
2025-05-24T14:54:58.5945270Z #define CNK_HEX     4
2025-05-24T14:54:58.5945334Z #define CNK_FLOAT   5
2025-05-24T14:54:58.5945516Z #define CNK_CHAR    6
2025-05-24T14:54:58.5945579Z #define CNK_STRING  7
2025-05-24T14:54:58.5945644Z #define CNK_PTR     8
2025-05-24T14:54:58.5945705Z #define CNK_NUM     9
2025-05-24T14:54:58.5945769Z #define CNK_PRCNT   10
2025-05-24T14:54:58.5945773Z 
2025-05-24T14:54:58.5945853Z #define char_to_int(p) ((p)- '0')
2025-05-24T14:54:58.5946000Z #ifndef MAX
2025-05-24T14:54:58.5946083Z #define MAX(p,q) (((p) >= (q)) ? (p) : (q))
2025-05-24T14:54:58.5946144Z #endif
2025-05-24T14:54:58.5946147Z 
2025-05-24T14:54:58.5946210Z struct pr_chunk {
2025-05-24T14:54:58.5946284Z 	int type; /* chunk type */
2025-05-24T14:54:58.5946463Z 	int num; /* parameter number */
2025-05-24T14:54:58.5946525Z 	int min;
2025-05-24T14:54:58.5946579Z 	int max;
2025-05-24T14:54:58.5946639Z 	int flags;
2025-05-24T14:54:58.5946699Z 	int cflags;
2025-05-24T14:54:58.5946756Z 	int start;
2025-05-24T14:54:58.5946813Z 	int len;
2025-05-24T14:54:58.5946872Z 	LLONG value;
2025-05-24T14:54:58.5946938Z 	LDOUBLE fvalue;
2025-05-24T14:54:58.5947001Z 	char *strvalue;
2025-05-24T14:54:58.5947061Z 	void *pnum;
2025-05-24T14:54:58.5947130Z 	struct pr_chunk *min_star;
2025-05-24T14:54:58.5947202Z 	struct pr_chunk *max_star;
2025-05-24T14:54:58.5947269Z 	struct pr_chunk *next;
2025-05-24T14:54:58.5947323Z };
2025-05-24T14:54:58.5947327Z 
2025-05-24T14:54:58.5947394Z struct pr_chunk_x {
2025-05-24T14:54:58.5947461Z 	struct pr_chunk **chunks;
2025-05-24T14:54:58.5947517Z 	int num;
2025-05-24T14:54:58.5947572Z };
2025-05-24T14:54:58.5947578Z 
2025-05-24T14:54:58.5947724Z static int dopr(char *buffer, size_t maxlen, const char *format,
2025-05-24T14:54:58.5947790Z 		   va_list args_in);
2025-05-24T14:54:58.5947930Z static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
2025-05-24T14:54:58.5948027Z 		    char *value, int flags, int min, int max);
2025-05-24T14:54:58.5948161Z static void fmtint(char *buffer, size_t *currlen, size_t maxlen,
2025-05-24T14:54:58.5948271Z 		    LLONG value, int base, int min, int max, int flags);
2025-05-24T14:54:58.5948409Z static void fmtfp(char *buffer, size_t *currlen, size_t maxlen,
2025-05-24T14:54:58.5948505Z 		   LDOUBLE fvalue, int min, int max, int flags);
2025-05-24T14:54:58.5948680Z static void dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c);
2025-05-24T14:54:58.5948769Z static struct pr_chunk *new_chunk(void);
2025-05-24T14:54:58.5948892Z static int add_cnk_list_entry(struct pr_chunk_x **list,
2025-05-24T14:54:58.5948973Z 				int max_num, struct pr_chunk *chunk);
2025-05-24T14:54:58.5948976Z 
2025-05-24T14:54:58.5949152Z static int dopr(char *buffer, size_t maxlen, const char *format, va_list args_in)
2025-05-24T14:54:58.5949210Z {
2025-05-24T14:54:58.5949271Z 	char ch;
2025-05-24T14:54:58.5949331Z 	int state;
2025-05-24T14:54:58.5949393Z 	int pflag;
2025-05-24T14:54:58.5949518Z 	int pnum;
2025-05-24T14:54:58.5949577Z 	int pfirst;
2025-05-24T14:54:58.5949638Z 	size_t currlen;
2025-05-24T14:54:58.5949700Z 	va_list args;
2025-05-24T14:54:58.5949765Z 	const char *base;
2025-05-24T14:54:58.5949840Z 	struct pr_chunk *chunks = NULL;
2025-05-24T14:54:58.5949916Z 	struct pr_chunk *cnk = NULL;
2025-05-24T14:54:58.5949992Z 	struct pr_chunk_x *clist = NULL;
2025-05-24T14:54:58.5950052Z 	int max_pos;
2025-05-24T14:54:58.5950113Z 	int ret = -1;
2025-05-24T14:54:58.5950117Z 
2025-05-24T14:54:58.5950189Z 	VA_COPY(args, args_in);
2025-05-24T14:54:58.5950195Z 
2025-05-24T14:54:58.5950260Z 	state = DP_S_DEFAULT;
2025-05-24T14:54:58.5950318Z 	pfirst = 1;
2025-05-24T14:54:58.5950402Z 	pflag = 0;
2025-05-24T14:54:58.5950507Z 	pnum = 0;
2025-05-24T14:54:58.5950514Z 
2025-05-24T14:54:58.5950618Z 	max_pos = 0;
2025-05-24T14:54:58.5950721Z 	base = format;
2025-05-24T14:54:58.5950837Z 	ch = *format++;
2025-05-24T14:54:58.5950842Z 
2025-05-24T14:54:58.5950998Z 	/* retrieve the string structure as chunks */
2025-05-24T14:54:58.5951115Z 	while (state != DP_S_DONE) {
2025-05-24T14:54:58.5951347Z 		if (ch == '\0')
2025-05-24T14:54:58.5951453Z 			state = DP_S_DONE;
2025-05-24T14:54:58.5951458Z 
2025-05-24T14:54:58.5951559Z 		switch(state) {
2025-05-24T14:54:58.5951666Z 		case DP_S_DEFAULT:
2025-05-24T14:54:58.5951672Z 
2025-05-24T14:54:58.5951766Z 			if (cnk) {
2025-05-24T14:54:58.5951883Z 				cnk->next = new_chunk();
2025-05-24T14:54:58.5951961Z 				cnk = cnk->next;
2025-05-24T14:54:58.5952020Z 			} else {
2025-05-24T14:54:58.5952084Z 				cnk = new_chunk();
2025-05-24T14:54:58.5952208Z 			}
2025-05-24T14:54:58.5952275Z 			if (!cnk) goto done;
2025-05-24T14:54:58.5952349Z 			if (!chunks) chunks = cnk;
2025-05-24T14:54:58.5952353Z 
2025-05-24T14:54:58.5952411Z 			if (ch == '%') {
2025-05-24T14:54:58.5952475Z 				state = DP_S_FLAGS;
2025-05-24T14:54:58.5952621Z 				ch = *format++;
2025-05-24T14:54:58.5952724Z 			} else {
2025-05-24T14:54:58.5952844Z 				cnk->type = CNK_FMT_STR;
2025-05-24T14:54:58.5952931Z 				cnk->start = format - base -1;
2025-05-24T14:54:58.5953029Z 				while ((ch != '\0') && (ch != '%')) ch = *format++;
2025-05-24T14:54:58.5953121Z 				cnk->len = format - base - cnk->start -1;
2025-05-24T14:54:58.5953175Z 			}
2025-05-24T14:54:58.5953233Z 			break;
2025-05-24T14:54:58.5953296Z 		case DP_S_FLAGS:
2025-05-24T14:54:58.5953357Z 			switch (ch) {
2025-05-24T14:54:58.5953420Z 			case '-':
2025-05-24T14:54:58.5953540Z 				cnk->flags |= DP_F_MINUS;
2025-05-24T14:54:58.5953644Z 				ch = *format++;
2025-05-24T14:54:58.5953705Z 				break;
2025-05-24T14:54:58.5953767Z 			case '+':
2025-05-24T14:54:58.5953836Z 				cnk->flags |= DP_F_PLUS;
2025-05-24T14:54:58.5953895Z 				ch = *format++;
2025-05-24T14:54:58.5953951Z 				break;
2025-05-24T14:54:58.5954011Z 			case ' ':
2025-05-24T14:54:58.5954076Z 				cnk->flags |= DP_F_SPACE;
2025-05-24T14:54:58.5954135Z 				ch = *format++;
2025-05-24T14:54:58.5954195Z 				break;
2025-05-24T14:54:58.5954254Z 			case '#':
2025-05-24T14:54:58.5954322Z 				cnk->flags |= DP_F_NUM;
2025-05-24T14:54:58.5954383Z 				ch = *format++;
2025-05-24T14:54:58.5954444Z 				break;
2025-05-24T14:54:58.5954500Z 			case '0':
2025-05-24T14:54:58.5954567Z 				cnk->flags |= DP_F_ZERO;
2025-05-24T14:54:58.5954628Z 				ch = *format++;
2025-05-24T14:54:58.5954684Z 				break;
2025-05-24T14:54:58.5954742Z 			case 'I':
2025-05-24T14:54:58.5954842Z 				/* internationalization not supported yet */
2025-05-24T14:54:58.5954904Z 				ch = *format++;
2025-05-24T14:54:58.5954958Z 				break;
2025-05-24T14:54:58.5955014Z 			default:
2025-05-24T14:54:58.5955082Z 				state = DP_S_MIN;
2025-05-24T14:54:58.5955137Z 				break;
2025-05-24T14:54:58.5955191Z 			}
2025-05-24T14:54:58.5955246Z 			break;
2025-05-24T14:54:58.5955309Z 		case DP_S_MIN:
2025-05-24T14:54:58.5955574Z 			if (isdigit((unsigned char)ch)) {
2025-05-24T14:54:58.5955681Z 				cnk->min = 10 * cnk->min + char_to_int (ch);
2025-05-24T14:54:58.5955747Z 				ch = *format++;
2025-05-24T14:54:58.5955815Z 			} else if (ch == '$') {
2025-05-24T14:54:58.5955975Z 				if (!pfirst && !pflag) {
2025-05-24T14:54:58.5956080Z 					/* parameters must be all positioned or none */
2025-05-24T14:54:58.5956141Z 					goto done;
2025-05-24T14:54:58.5956198Z 				}
2025-05-24T14:54:58.5956260Z 				if (pfirst) {
2025-05-24T14:54:58.5956320Z 					pfirst = 0;
2025-05-24T14:54:58.5956381Z 					pflag = 1;
2025-05-24T14:54:58.5956438Z 				}
2025-05-24T14:54:58.5956508Z 				if (cnk->min == 0) /* what ?? */
2025-05-24T14:54:58.5956568Z 					goto done;
2025-05-24T14:54:58.5956634Z 				cnk->num = cnk->min;
2025-05-24T14:54:58.5956694Z 				cnk->min = 0;
2025-05-24T14:54:58.5956752Z 				ch = *format++;
2025-05-24T14:54:58.5956820Z 			} else if (ch == '*') {
2025-05-24T14:54:58.5956889Z 				if (pfirst) pfirst = 0;
2025-05-24T14:54:58.5956961Z 				cnk->min_star = new_chunk();
2025-05-24T14:54:58.5957055Z 				if (!cnk->min_star) /* out of memory :-( */
2025-05-24T14:54:58.5957117Z 					goto done;
2025-05-24T14:54:58.5957191Z 				cnk->min_star->type = CNK_INT;
2025-05-24T14:54:58.5957254Z 				if (pflag) {
2025-05-24T14:54:58.5957314Z 					int num;
2025-05-24T14:54:58.5957375Z 					ch = *format++;
2025-05-24T14:54:58.5957454Z 					if (!isdigit((unsigned char)ch)) {
2025-05-24T14:54:58.5957560Z 						/* parameters must be all positioned or none */
2025-05-24T14:54:58.5957618Z 						goto done;
2025-05-24T14:54:58.5957671Z 					}
2025-05-24T14:54:58.5957791Z 					for (num = 0; isdigit((unsigned char)ch); ch = *format++) {
2025-05-24T14:54:58.5957866Z 						num = 10 * num + char_to_int(ch);
2025-05-24T14:54:58.5957922Z 					}
2025-05-24T14:54:58.5958062Z 					cnk->min_star->num = num;
2025-05-24T14:54:58.5958132Z 					if (ch != '$') /* what ?? */
2025-05-24T14:54:58.5958190Z 						goto done;
2025-05-24T14:54:58.5958247Z 				} else {
2025-05-24T14:54:58.5958317Z 					cnk->min_star->num = ++pnum;
2025-05-24T14:54:58.5958374Z 				}
2025-05-24T14:54:58.5958620Z 				max_pos = add_cnk_list_entry(&clist, max_pos, cnk->min_star);
2025-05-24T14:54:58.5958710Z 				if (max_pos == 0) /* out of memory :-( */
2025-05-24T14:54:58.5958774Z 					goto done;
2025-05-24T14:54:58.5958837Z 				ch = *format++;
2025-05-24T14:54:58.5958904Z 				state = DP_S_DOT;
2025-05-24T14:54:58.5958959Z 			} else {
2025-05-24T14:54:58.5959032Z 				if (pfirst) pfirst = 0;
2025-05-24T14:54:58.5959095Z 				state = DP_S_DOT;
2025-05-24T14:54:58.5959149Z 			}
2025-05-24T14:54:58.5959208Z 			break;
2025-05-24T14:54:58.5959268Z 		case DP_S_DOT:
2025-05-24T14:54:58.5959331Z 			if (ch == '.') {
2025-05-24T14:54:58.5959390Z 				state = DP_S_MAX;
2025-05-24T14:54:58.5959452Z 				ch = *format++;
2025-05-24T14:54:58.5959509Z 			} else {
2025-05-24T14:54:58.5959568Z 				state = DP_S_MOD;
2025-05-24T14:54:58.5959623Z 			}
2025-05-24T14:54:58.5959679Z 			break;
2025-05-24T14:54:58.5959738Z 		case DP_S_MAX:
2025-05-24T14:54:58.5959814Z 			if (isdigit((unsigned char)ch)) {
2025-05-24T14:54:58.5959892Z 				if (cnk->max < 0)
2025-05-24T14:54:58.5960012Z 					cnk->max = 0;
2025-05-24T14:54:58.5960168Z 				cnk->max = 10 * cnk->max + char_to_int (ch);
2025-05-24T14:54:58.5960281Z 				ch = *format++;
2025-05-24T14:54:58.5960389Z 			} else if (ch == '$') {
2025-05-24T14:54:58.5960503Z 				if (!pfirst && !pflag) {
2025-05-24T14:54:58.5960671Z 					/* parameters must be all positioned or none */
2025-05-24T14:54:58.5960779Z 					goto done;
2025-05-24T14:54:58.5960869Z 				}
2025-05-24T14:54:58.5960985Z 				if (cnk->max <= 0) /* what ?? */
2025-05-24T14:54:58.5961090Z 					goto done;
2025-05-24T14:54:58.5961200Z 				cnk->num = cnk->max;
2025-05-24T14:54:58.5961301Z 				cnk->max = -1;
2025-05-24T14:54:58.5961397Z 				ch = *format++;
2025-05-24T14:54:58.5961511Z 			} else if (ch == '*') {
2025-05-24T14:54:58.5961628Z 				cnk->max_star = new_chunk();
2025-05-24T14:54:58.5961770Z 				if (!cnk->max_star) /* out of memory :-( */
2025-05-24T14:54:58.5961873Z 					goto done;
2025-05-24T14:54:58.5962039Z 				cnk->max_star->type = CNK_INT;
2025-05-24T14:54:58.5962147Z 				if (pflag) {
2025-05-24T14:54:58.5962239Z 					int num;
2025-05-24T14:54:58.5962356Z 					ch = *format++;
2025-05-24T14:54:58.5962569Z 					if (!isdigit((unsigned char)ch)) {
2025-05-24T14:54:58.5962746Z 						/* parameters must be all positioned or none */
2025-05-24T14:54:58.5962853Z 						goto done;
2025-05-24T14:54:58.5962945Z 					}
2025-05-24T14:54:58.5963146Z 					for (num = 0; isdigit((unsigned char)ch); ch = *format++) {
2025-05-24T14:54:58.5963270Z 						num = 10 * num + char_to_int(ch);
2025-05-24T14:54:58.5963366Z 					}
2025-05-24T14:54:58.5963485Z 					cnk->max_star->num = num;
2025-05-24T14:54:58.5963595Z 					if (ch != '$') /* what ?? */
2025-05-24T14:54:58.5963697Z 						goto done;
2025-05-24T14:54:58.5963792Z 				} else {
2025-05-24T14:54:58.5963909Z 					cnk->max_star->num = ++pnum;
2025-05-24T14:54:58.5964000Z 				}
2025-05-24T14:54:58.5964222Z 				max_pos = add_cnk_list_entry(&clist, max_pos, cnk->max_star);
2025-05-24T14:54:58.5964367Z 				if (max_pos == 0) /* out of memory :-( */
2025-05-24T14:54:58.5964465Z 					goto done;
2025-05-24T14:54:58.5964471Z 
2025-05-24T14:54:58.5964575Z 				ch = *format++;
2025-05-24T14:54:58.5964681Z 				state = DP_S_MOD;
2025-05-24T14:54:58.5964774Z 			} else {
2025-05-24T14:54:58.5964877Z 				state = DP_S_MOD;
2025-05-24T14:54:58.5964969Z 			}
2025-05-24T14:54:58.5965062Z 			break;
2025-05-24T14:54:58.5965171Z 		case DP_S_MOD:
2025-05-24T14:54:58.5965251Z 			switch (ch) {
2025-05-24T14:54:58.5965309Z 			case 'h':
2025-05-24T14:54:58.5965530Z 				cnk->cflags = DP_C_SHORT;
2025-05-24T14:54:58.5965593Z 				ch = *format++;
2025-05-24T14:54:58.5965657Z 				if (ch == 'h') {
2025-05-24T14:54:58.5965726Z 					cnk->cflags = DP_C_CHAR;
2025-05-24T14:54:58.5965877Z 					ch = *format++;
2025-05-24T14:54:58.5965932Z 				}
2025-05-24T14:54:58.5965992Z 				break;
2025-05-24T14:54:58.5966050Z 			case 'l':
2025-05-24T14:54:58.5966120Z 				cnk->cflags = DP_C_LONG;
2025-05-24T14:54:58.5966184Z 				ch = *format++;
2025-05-24T14:54:58.5966367Z 				if (ch == 'l') {	/* It's a long long */
2025-05-24T14:54:58.5966440Z 					cnk->cflags = DP_C_LLONG;
2025-05-24T14:54:58.5966499Z 					ch = *format++;
2025-05-24T14:54:58.5966563Z 				}
2025-05-24T14:54:58.5966618Z 				break;
2025-05-24T14:54:58.5966675Z 			case 'j':
2025-05-24T14:54:58.5966745Z 				cnk->cflags = DP_C_LLONG;
2025-05-24T14:54:58.5966805Z 				ch = *format++;
2025-05-24T14:54:58.5966861Z 				break;
2025-05-24T14:54:58.5966921Z 			case 'L':
2025-05-24T14:54:58.5966995Z 				cnk->cflags = DP_C_LDOUBLE;
2025-05-24T14:54:58.5967056Z 				ch = *format++;
2025-05-24T14:54:58.5967110Z 				break;
2025-05-24T14:54:58.5967168Z 			case 'z':
2025-05-24T14:54:58.5967234Z 				cnk->cflags = DP_C_SIZET;
2025-05-24T14:54:58.5967294Z 				ch = *format++;
2025-05-24T14:54:58.5967349Z 				break;
2025-05-24T14:54:58.5967410Z 			default:
2025-05-24T14:54:58.5967465Z 				break;
2025-05-24T14:54:58.5967521Z 			}
2025-05-24T14:54:58.5967584Z 			state = DP_S_CONV;
2025-05-24T14:54:58.5967680Z 			break;
2025-05-24T14:54:58.5967804Z 		case DP_S_CONV:
2025-05-24T14:54:58.5967919Z 			if (cnk->num == 0) cnk->num = ++pnum;
2025-05-24T14:54:58.5968030Z 			max_pos = add_cnk_list_entry(&clist, max_pos, cnk);
2025-05-24T14:54:58.5968118Z 			if (max_pos == 0) /* out of memory :-( */
2025-05-24T14:54:58.5968176Z 				goto done;
2025-05-24T14:54:58.5968180Z 
2025-05-24T14:54:58.5968245Z 			switch (ch) {
2025-05-24T14:54:58.5968301Z 			case 'd':
2025-05-24T14:54:58.5968357Z 			case 'i':
2025-05-24T14:54:58.5968422Z 				cnk->type = CNK_INT;
2025-05-24T14:54:58.5968491Z 				break;
2025-05-24T14:54:58.5968602Z 			case 'o':
2025-05-24T14:54:58.5968721Z 				cnk->type = CNK_OCTAL;
2025-05-24T14:54:58.5968803Z 				cnk->flags |= DP_F_UNSIGNED;
2025-05-24T14:54:58.5968864Z 				break;
2025-05-24T14:54:58.5968920Z 			case 'u':
2025-05-24T14:54:58.5968985Z 				cnk->type = CNK_UINT;
2025-05-24T14:54:58.5969057Z 				cnk->flags |= DP_F_UNSIGNED;
2025-05-24T14:54:58.5969113Z 				break;
2025-05-24T14:54:58.5969170Z 			case 'X':
2025-05-24T14:54:58.5969240Z 				cnk->flags |= DP_F_UP;
2025-05-24T14:54:58.5969300Z 			case 'x':
2025-05-24T14:54:58.5969367Z 				cnk->type = CNK_HEX;
2025-05-24T14:54:58.5969515Z 				cnk->flags |= DP_F_UNSIGNED;
2025-05-24T14:54:58.5969573Z 				break;
2025-05-24T14:54:58.5969631Z 			case 'A':
2025-05-24T14:54:58.5969714Z 				/* hex float not supported yet */
2025-05-24T14:54:58.5969771Z 			case 'E':
2025-05-24T14:54:58.5969833Z 			case 'G':
2025-05-24T14:54:58.5969890Z 			case 'F':
2025-05-24T14:54:58.5969956Z 				cnk->flags |= DP_F_UP;
2025-05-24T14:54:58.5970020Z 			case 'a':
2025-05-24T14:54:58.5970098Z 				/* hex float not supported yet */
2025-05-24T14:54:58.5970156Z 			case 'e':
2025-05-24T14:54:58.5970213Z 			case 'f':
2025-05-24T14:54:58.5970273Z 			case 'g':
2025-05-24T14:54:58.5970338Z 				cnk->type = CNK_FLOAT;
2025-05-24T14:54:58.5970392Z 				break;
2025-05-24T14:54:58.5970450Z 			case 'c':
2025-05-24T14:54:58.5970514Z 				cnk->type = CNK_CHAR;
2025-05-24T14:54:58.5970570Z 				break;
2025-05-24T14:54:58.5970626Z 			case 's':
2025-05-24T14:54:58.5970700Z 				cnk->type = CNK_STRING;
2025-05-24T14:54:58.5970756Z 				break;
2025-05-24T14:54:58.5970816Z 			case 'p':
2025-05-24T14:54:58.5970883Z 				cnk->type = CNK_PTR;
2025-05-24T14:54:58.5970960Z 				cnk->flags |= DP_F_UNSIGNED;
2025-05-24T14:54:58.5971015Z 				break;
2025-05-24T14:54:58.5971071Z 			case 'n':
2025-05-24T14:54:58.5971138Z 				cnk->type = CNK_NUM;
2025-05-24T14:54:58.5971194Z 				break;
2025-05-24T14:54:58.5971249Z 			case '%':
2025-05-24T14:54:58.5971316Z 				cnk->type = CNK_PRCNT;
2025-05-24T14:54:58.5971372Z 				break;
2025-05-24T14:54:58.5971427Z 			default:
2025-05-24T14:54:58.5971492Z 				/* Unknown, bail out*/
2025-05-24T14:54:58.5971552Z 				goto done;
2025-05-24T14:54:58.5971656Z 			}
2025-05-24T14:54:58.5971716Z 			ch = *format++;
2025-05-24T14:54:58.5971780Z 			state = DP_S_DEFAULT;
2025-05-24T14:54:58.5971840Z 			break;
2025-05-24T14:54:58.5971902Z 		case DP_S_DONE:
2025-05-24T14:54:58.5971957Z 			break;
2025-05-24T14:54:58.5972014Z 		default:
2025-05-24T14:54:58.5972149Z 			/* hmm? */
2025-05-24T14:54:58.5972245Z 			break; /* some picky compilers need this */
2025-05-24T14:54:58.5972300Z 		}
2025-05-24T14:54:58.5972359Z 	}
2025-05-24T14:54:58.5972363Z 
2025-05-24T14:54:58.5972443Z 	/* retrieve the format arguments */
2025-05-24T14:54:58.5972529Z 	for (pnum = 0; pnum < max_pos; pnum++) {
2025-05-24T14:54:58.5972591Z 		int i;
2025-05-24T14:54:58.5972594Z 
2025-05-24T14:54:58.5972668Z 		if (clist[pnum].num == 0) {
2025-05-24T14:54:58.5972768Z 			/* ignoring a parameter should not be permitted
2025-05-24T14:54:58.5972864Z 			 * all parameters must be matched at least once
2025-05-24T14:54:58.5972955Z 			 * BUT seem some system ignore this rule ...
2025-05-24T14:54:58.5973044Z 			 * at least my glibc based system does --SSS
2025-05-24T14:54:58.5973101Z 			 */
2025-05-24T14:54:58.5973172Z #ifdef DEBUG_SNPRINTF
2025-05-24T14:54:58.5973298Z 			printf("parameter at position %d not used\n", pnum+1);
2025-05-24T14:54:58.5973354Z #endif
2025-05-24T14:54:58.5973424Z 			/* eat the parameter */
2025-05-24T14:54:58.5973495Z 			va_arg (args, int);
2025-05-24T14:54:58.5973552Z 			continue;
2025-05-24T14:54:58.5973607Z 		}
2025-05-24T14:54:58.5973690Z 		for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5973832Z 			if (clist[pnum].chunks[0]->type != clist[pnum].chunks[i]->type) {
2025-05-24T14:54:58.5973894Z 				/* nooo no no!
2025-05-24T14:54:58.5973974Z 				 * all the references to a parameter
2025-05-24T14:54:58.5974047Z 				 * must be of the same type
2025-05-24T14:54:58.5974102Z 				 */
2025-05-24T14:54:58.5974161Z 				goto done;
2025-05-24T14:54:58.5974221Z 			}
2025-05-24T14:54:58.5974273Z 		}
2025-05-24T14:54:58.5974344Z 		cnk = clist[pnum].chunks[0];
2025-05-24T14:54:58.5974411Z 		switch (cnk->type) {
2025-05-24T14:54:58.5974473Z 		case CNK_INT:
2025-05-24T14:54:58.5974543Z 			if (cnk->cflags == DP_C_SHORT)
2025-05-24T14:54:58.5974617Z 				cnk->value = va_arg (args, int);
2025-05-24T14:54:58.5974696Z 			else if (cnk->cflags == DP_C_LONG)
2025-05-24T14:54:58.5974775Z 				cnk->value = va_arg (args, long int);
2025-05-24T14:54:58.5974852Z 			else if (cnk->cflags == DP_C_LLONG)
2025-05-24T14:54:58.5974976Z 				cnk->value = va_arg (args, LLONG);
2025-05-24T14:54:58.5975054Z 			else if (cnk->cflags == DP_C_SIZET)
2025-05-24T14:54:58.5975128Z 				cnk->value = va_arg (args, ssize_t);
2025-05-24T14:54:58.5975183Z 			else
2025-05-24T14:54:58.5975259Z 				cnk->value = va_arg (args, int);
2025-05-24T14:54:58.5975263Z 
2025-05-24T14:54:58.5975519Z 			for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5975647Z 				clist[pnum].chunks[i]->value = cnk->value;
2025-05-24T14:54:58.5975702Z 			}
2025-05-24T14:54:58.5975763Z 			break;
2025-05-24T14:54:58.5975766Z 
2025-05-24T14:54:58.5975830Z 		case CNK_OCTAL:
2025-05-24T14:54:58.5975890Z 		case CNK_UINT:
2025-05-24T14:54:58.5975951Z 		case CNK_HEX:
2025-05-24T14:54:58.5976023Z 			if (cnk->cflags == DP_C_SHORT)
2025-05-24T14:54:58.5976109Z 				cnk->value = va_arg (args, unsigned int);
2025-05-24T14:54:58.5976186Z 			else if (cnk->cflags == DP_C_LONG)
2025-05-24T14:54:58.5976343Z 				cnk->value = (unsigned long int)va_arg (args, unsigned long int);
2025-05-24T14:54:58.5976421Z 			else if (cnk->cflags == DP_C_LLONG)
2025-05-24T14:54:58.5976524Z 				cnk->value = (LLONG)va_arg (args, unsigned LLONG);
2025-05-24T14:54:58.5976602Z 			else if (cnk->cflags == DP_C_SIZET)
2025-05-24T14:54:58.5976688Z 				cnk->value = (size_t)va_arg (args, size_t);
2025-05-24T14:54:58.5976745Z 			else
2025-05-24T14:54:58.5976860Z 				cnk->value = (unsigned int)va_arg (args, unsigned int);
2025-05-24T14:54:58.5976864Z 
2025-05-24T14:54:58.5976943Z 			for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5977032Z 				clist[pnum].chunks[i]->value = cnk->value;
2025-05-24T14:54:58.5977165Z 			}
2025-05-24T14:54:58.5977226Z 			break;
2025-05-24T14:54:58.5977230Z 
2025-05-24T14:54:58.5977293Z 		case CNK_FLOAT:
2025-05-24T14:54:58.5977367Z 			if (cnk->cflags == DP_C_LDOUBLE)
2025-05-24T14:54:58.5977448Z 				cnk->fvalue = va_arg (args, LDOUBLE);
2025-05-24T14:54:58.5977505Z 			else
2025-05-24T14:54:58.5977684Z 				cnk->fvalue = va_arg (args, double);
2025-05-24T14:54:58.5977689Z 
2025-05-24T14:54:58.5977773Z 			for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5977865Z 				clist[pnum].chunks[i]->fvalue = cnk->fvalue;
2025-05-24T14:54:58.5977920Z 			}
2025-05-24T14:54:58.5977974Z 			break;
2025-05-24T14:54:58.5977978Z 
2025-05-24T14:54:58.5978041Z 		case CNK_CHAR:
2025-05-24T14:54:58.5978112Z 			cnk->value = va_arg (args, int);
2025-05-24T14:54:58.5978116Z 
2025-05-24T14:54:58.5978191Z 			for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5978281Z 				clist[pnum].chunks[i]->value = cnk->value;
2025-05-24T14:54:58.5978335Z 			}
2025-05-24T14:54:58.5978392Z 			break;
2025-05-24T14:54:58.5978395Z 
2025-05-24T14:54:58.5978457Z 		case CNK_STRING:
2025-05-24T14:54:58.5978537Z 			cnk->strvalue = va_arg (args, char *);
2025-05-24T14:54:58.5978626Z 			if (!cnk->strvalue) cnk->strvalue = "(NULL)";
2025-05-24T14:54:58.5978629Z 
2025-05-24T14:54:58.5978708Z 			for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5978833Z 				clist[pnum].chunks[i]->strvalue = cnk->strvalue;
2025-05-24T14:54:58.5978935Z 			}
2025-05-24T14:54:58.5979039Z 			break;
2025-05-24T14:54:58.5979044Z 
2025-05-24T14:54:58.5979150Z 		case CNK_PTR:
2025-05-24T14:54:58.5979279Z 			cnk->strvalue = va_arg (args, void *);
2025-05-24T14:54:58.5979405Z 			for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5979569Z 				clist[pnum].chunks[i]->strvalue = cnk->strvalue;
2025-05-24T14:54:58.5979664Z 			}
2025-05-24T14:54:58.5979761Z 			break;
2025-05-24T14:54:58.5979767Z 
2025-05-24T14:54:58.5979864Z 		case CNK_NUM:
2025-05-24T14:54:58.5979985Z 			if (cnk->cflags == DP_C_CHAR)
2025-05-24T14:54:58.5980114Z 				cnk->pnum = va_arg (args, char *);
2025-05-24T14:54:58.5980241Z 			else if (cnk->cflags == DP_C_SHORT)
2025-05-24T14:54:58.5980380Z 				cnk->pnum = va_arg (args, short int *);
2025-05-24T14:54:58.5980503Z 			else if (cnk->cflags == DP_C_LONG)
2025-05-24T14:54:58.5980635Z 				cnk->pnum = va_arg (args, long int *);
2025-05-24T14:54:58.5980759Z 			else if (cnk->cflags == DP_C_LLONG)
2025-05-24T14:54:58.5980888Z 				cnk->pnum = va_arg (args, LLONG *);
2025-05-24T14:54:58.5981110Z 			else if (cnk->cflags == DP_C_SIZET)
2025-05-24T14:54:58.5981190Z 				cnk->pnum = va_arg (args, ssize_t *);
2025-05-24T14:54:58.5981252Z 			else
2025-05-24T14:54:58.5981325Z 				cnk->pnum = va_arg (args, int *);
2025-05-24T14:54:58.5981329Z 
2025-05-24T14:54:58.5981405Z 			for (i = 1; i < clist[pnum].num; i++) {
2025-05-24T14:54:58.5981493Z 				clist[pnum].chunks[i]->pnum = cnk->pnum;
2025-05-24T14:54:58.5981550Z 			}
2025-05-24T14:54:58.5981606Z 			break;
2025-05-24T14:54:58.5981609Z 
2025-05-24T14:54:58.5981672Z 		case CNK_PRCNT:
2025-05-24T14:54:58.5981730Z 			break;
2025-05-24T14:54:58.5981734Z 
2025-05-24T14:54:58.5981800Z 		default:
2025-05-24T14:54:58.5981911Z 			/* what ?? */
2025-05-24T14:54:58.5982018Z 			goto done;
2025-05-24T14:54:58.5982086Z 		}
2025-05-24T14:54:58.5982141Z 	}
2025-05-24T14:54:58.5982239Z 	/* print out the actual string from chunks */
2025-05-24T14:54:58.5982306Z 	currlen = 0;
2025-05-24T14:54:58.5982366Z 	cnk = chunks;
2025-05-24T14:54:58.5982428Z 	while (cnk) {
2025-05-24T14:54:58.5982490Z 		int len, min, max;
2025-05-24T14:54:58.5982494Z 
2025-05-24T14:54:58.5982589Z 		if (cnk->min_star) min = cnk->min_star->value;
2025-05-24T14:54:58.5982666Z 		else min = cnk->min;
2025-05-24T14:54:58.5982832Z 		if (cnk->max_star) max = cnk->max_star->value;
2025-05-24T14:54:58.5982930Z 		else max = cnk->max;
2025-05-24T14:54:58.5982934Z 
2025-05-24T14:54:58.5983000Z 		switch (cnk->type) {
2025-05-24T14:54:58.5983004Z 
2025-05-24T14:54:58.5983065Z 		case CNK_FMT_STR:
2025-05-24T14:54:58.5983224Z 			if (maxlen != 0 && maxlen > currlen) {
2025-05-24T14:54:58.5983325Z 				if (maxlen > (currlen + cnk->len)) len = cnk->len;
2025-05-24T14:54:58.5983399Z 				else len = maxlen - currlen;
2025-05-24T14:54:58.5983402Z 
2025-05-24T14:54:58.5983514Z 				memcpy(&(buffer[currlen]), &(base[cnk->start]), len);
2025-05-24T14:54:58.5983647Z 			}
2025-05-24T14:54:58.5983716Z 			currlen += cnk->len;
2025-05-24T14:54:58.5983720Z 
2025-05-24T14:54:58.5983780Z 			break;
2025-05-24T14:54:58.5983784Z 
2025-05-24T14:54:58.5983845Z 		case CNK_INT:
2025-05-24T14:54:58.5983904Z 		case CNK_UINT:
2025-05-24T14:54:58.5984064Z 			fmtint (buffer, &currlen, maxlen, cnk->value, 10, min, max, cnk->flags);
2025-05-24T14:54:58.5984122Z 			break;
2025-05-24T14:54:58.5984125Z 
2025-05-24T14:54:58.5984184Z 		case CNK_OCTAL:
2025-05-24T14:54:58.5984333Z 			fmtint (buffer, &currlen, maxlen, cnk->value, 8, min, max, cnk->flags);
2025-05-24T14:54:58.5984389Z 			break;
2025-05-24T14:54:58.5984395Z 
2025-05-24T14:54:58.5984453Z 		case CNK_HEX:
2025-05-24T14:54:58.5984602Z 			fmtint (buffer, &currlen, maxlen, cnk->value, 16, min, max, cnk->flags);
2025-05-24T14:54:58.5984658Z 			break;
2025-05-24T14:54:58.5984662Z 
2025-05-24T14:54:58.5984725Z 		case CNK_FLOAT:
2025-05-24T14:54:58.5984871Z 			fmtfp (buffer, &currlen, maxlen, cnk->fvalue, min, max, cnk->flags);
2025-05-24T14:54:58.5984928Z 			break;
2025-05-24T14:54:58.5984932Z 
2025-05-24T14:54:58.5984994Z 		case CNK_CHAR:
2025-05-24T14:54:58.5985099Z 			dopr_outch (buffer, &currlen, maxlen, cnk->value);
2025-05-24T14:54:58.5985154Z 			break;
2025-05-24T14:54:58.5985157Z 
2025-05-24T14:54:58.5985222Z 		case CNK_STRING:
2025-05-24T14:54:58.5985285Z 			if (max == -1) {
2025-05-24T14:54:58.5985479Z 				max = strlen(cnk->strvalue);
2025-05-24T14:54:58.5985535Z 			}
2025-05-24T14:54:58.5985693Z 			fmtstr (buffer, &currlen, maxlen, cnk->strvalue, cnk->flags, min, max);
2025-05-24T14:54:58.5985749Z 			break;
2025-05-24T14:54:58.5985753Z 
2025-05-24T14:54:58.5985813Z 		case CNK_PTR:
2025-05-24T14:54:58.5985996Z 			fmtint (buffer, &currlen, maxlen, (long)(cnk->strvalue), 16, min, max, cnk->flags);
2025-05-24T14:54:58.5986052Z 			break;
2025-05-24T14:54:58.5986056Z 
2025-05-24T14:54:58.5986114Z 		case CNK_NUM:
2025-05-24T14:54:58.5986184Z 			if (cnk->cflags == DP_C_CHAR)
2025-05-24T14:54:58.5986271Z 				*((char *)(cnk->pnum)) = (char)currlen;
2025-05-24T14:54:58.5986347Z 			else if (cnk->cflags == DP_C_SHORT)
2025-05-24T14:54:58.5986443Z 				*((short int *)(cnk->pnum)) = (short int)currlen;
2025-05-24T14:54:58.5986599Z 			else if (cnk->cflags == DP_C_LONG)
2025-05-24T14:54:58.5986689Z 				*((long int *)(cnk->pnum)) = (long int)currlen;
2025-05-24T14:54:58.5986763Z 			else if (cnk->cflags == DP_C_LLONG)
2025-05-24T14:54:58.5986844Z 				*((LLONG *)(cnk->pnum)) = (LLONG)currlen;
2025-05-24T14:54:58.5986922Z 			else if (cnk->cflags == DP_C_SIZET)
2025-05-24T14:54:58.5987008Z 				*((ssize_t *)(cnk->pnum)) = (ssize_t)currlen;
2025-05-24T14:54:58.5987064Z 			else
2025-05-24T14:54:58.5987141Z 				*((int *)(cnk->pnum)) = (int)currlen;
2025-05-24T14:54:58.5987197Z 			break;
2025-05-24T14:54:58.5987200Z 
2025-05-24T14:54:58.5987263Z 		case CNK_PRCNT:
2025-05-24T14:54:58.5987356Z 			dopr_outch (buffer, &currlen, maxlen, '%');
2025-05-24T14:54:58.5987410Z 			break;
2025-05-24T14:54:58.5987413Z 
2025-05-24T14:54:58.5987469Z 		default:
2025-05-24T14:54:58.5987530Z 			/* what ?? */
2025-05-24T14:54:58.5987590Z 			goto done;
2025-05-24T14:54:58.5987644Z 		}
2025-05-24T14:54:58.5987707Z 		cnk = cnk->next;
2025-05-24T14:54:58.5987766Z 	}
2025-05-24T14:54:58.5987829Z 	if (maxlen != 0) {
2025-05-24T14:54:58.5987901Z 		if (currlen < maxlen - 1)
2025-05-24T14:54:58.5987971Z 			buffer[currlen] = '\0';
2025-05-24T14:54:58.5988041Z 		else if (maxlen > 0)
2025-05-24T14:54:58.5988112Z 			buffer[maxlen - 1] = '\0';
2025-05-24T14:54:58.5988167Z 	}
2025-05-24T14:54:58.5988230Z 	ret = currlen;
2025-05-24T14:54:58.5988233Z 
2025-05-24T14:54:58.5988287Z done:
2025-05-24T14:54:58.5988348Z 	va_end(args);
2025-05-24T14:54:58.5988352Z 
2025-05-24T14:54:58.5988481Z 	while (chunks) {
2025-05-24T14:54:58.5988551Z 		cnk = chunks->next;
2025-05-24T14:54:58.5988643Z 		if (chunks->min_star) free(chunks->min_star);
2025-05-24T14:54:58.5988730Z 		if (chunks->max_star) free(chunks->max_star);
2025-05-24T14:54:58.5988792Z 		free(chunks);
2025-05-24T14:54:58.5988852Z 		chunks = cnk;
2025-05-24T14:54:58.5989011Z 	}
2025-05-24T14:54:58.5989119Z 	if (clist) {
2025-05-24T14:54:58.5989281Z 		for (pnum = 0; pnum < max_pos; pnum++) {
2025-05-24T14:54:58.5989391Z 			if (clist[pnum].chunks) free(clist[pnum].chunks);
2025-05-24T14:54:58.5989446Z 		}
2025-05-24T14:54:58.5989509Z 		free(clist);
2025-05-24T14:54:58.5989567Z 	}
2025-05-24T14:54:58.5989643Z 	return ret;
2025-05-24T14:54:58.5989729Z }
2025-05-24T14:54:58.5989734Z 
2025-05-24T14:54:58.5989969Z static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
2025-05-24T14:54:58.5990104Z 		    char *value, int flags, int min, int max)
2025-05-24T14:54:58.5990185Z {
2025-05-24T14:54:58.5990327Z 	int padlen, strln;     /* amount to pad */
2025-05-24T14:54:58.5990429Z 	int cnt = 0;
2025-05-24T14:54:58.5990435Z 
2025-05-24T14:54:58.5990548Z #ifdef DEBUG_SNPRINTF
2025-05-24T14:54:58.5990725Z 	printf("fmtstr min=%d max=%d s=[%s]\n", min, max, value);
2025-05-24T14:54:58.5990785Z #endif
2025-05-24T14:54:58.5990848Z 	if (value == 0) {
2025-05-24T14:54:58.5990912Z 		value = "<NULL>";
2025-05-24T14:54:58.5990969Z 	}
2025-05-24T14:54:58.5990973Z 
2025-05-24T14:54:58.5991107Z 	for (strln = 0; strln < max && value[strln]; ++strln); /* strlen */
2025-05-24T14:54:58.5991175Z 	padlen = min - strln;
2025-05-24T14:54:58.5991240Z 	if (padlen < 0)
2025-05-24T14:54:58.5991337Z 		padlen = 0;
2025-05-24T14:54:58.5991455Z 	if (flags & DP_F_MINUS)
2025-05-24T14:54:58.5991553Z 		padlen = -padlen; /* Left Justify */
2025-05-24T14:54:58.5991557Z 
2025-05-24T14:54:58.5991626Z 	while (padlen > 0) {
2025-05-24T14:54:58.5991716Z 		dopr_outch (buffer, currlen, maxlen, ' ');
2025-05-24T14:54:58.5991779Z 		--padlen;
2025-05-24T14:54:58.5991835Z 	}
2025-05-24T14:54:58.5991908Z 	while (*value && (cnt < max)) {
2025-05-24T14:54:58.5992008Z 		dopr_outch (buffer, currlen, maxlen, *value++);
2025-05-24T14:54:58.5992068Z 		++cnt;
2025-05-24T14:54:58.5992127Z 	}
2025-05-24T14:54:58.5992193Z 	while (padlen < 0) {
2025-05-24T14:54:58.5992279Z 		dopr_outch (buffer, currlen, maxlen, ' ');
2025-05-24T14:54:58.5992341Z 		++padlen;
2025-05-24T14:54:58.5992395Z 	}
2025-05-24T14:54:58.5992449Z }
2025-05-24T14:54:58.5992526Z 
2025-05-24T14:54:58.5992639Z /* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
2025-05-24T14:54:58.5992643Z 
2025-05-24T14:54:58.5992787Z static void fmtint(char *buffer, size_t *currlen, size_t maxlen,
2025-05-24T14:54:58.5992895Z 		    LLONG value, int base, int min, int max, int flags)
2025-05-24T14:54:58.5992948Z {
2025-05-24T14:54:58.5993016Z 	int signvalue = 0;
2025-05-24T14:54:58.5993086Z 	unsigned LLONG uvalue;
2025-05-24T14:54:58.5993216Z 	char convert[22+1]; /* 64-bit value in octal: 22 digits + \0 */
2025-05-24T14:54:58.5993277Z 	int place = 0;
2025-05-24T14:54:58.5993370Z 	int spadlen = 0; /* amount to space pad */
2025-05-24T14:54:58.5993452Z 	int zpadlen = 0; /* amount to zero pad */
2025-05-24T14:54:58.5993514Z 	int caps = 0;
2025-05-24T14:54:58.5993518Z 
2025-05-24T14:54:58.5993581Z 	if (max < 0)
2025-05-24T14:54:58.5993637Z 		max = 0;
2025-05-24T14:54:58.5993641Z 
2025-05-24T14:54:58.5993705Z 	uvalue = value;
2025-05-24T14:54:58.5993709Z 
2025-05-24T14:54:58.5993787Z 	if(!(flags & DP_F_UNSIGNED)) {
2025-05-24T14:54:58.5993852Z 		if( value < 0 ) {
2025-05-24T14:54:58.5993914Z 			signvalue = '-';
2025-05-24T14:54:58.5993977Z 			uvalue = -value;
2025-05-24T14:54:58.5994037Z 		} else {
2025-05-24T14:54:58.5994128Z 			if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
2025-05-24T14:54:58.5994193Z 				signvalue = '+';
2025-05-24T14:54:58.5994266Z 			else if (flags & DP_F_SPACE)
2025-05-24T14:54:58.5994328Z 				signvalue = ' ';
2025-05-24T14:54:58.5994383Z 		}
2025-05-24T14:54:58.5994437Z 	}
2025-05-24T14:54:58.5994441Z 
2025-05-24T14:54:58.5994586Z 	if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
2025-05-24T14:54:58.5994638Z 
2025-05-24T14:54:58.5994696Z 	do {
2025-05-24T14:54:58.5994761Z 		convert[place++] =
2025-05-24T14:54:58.5994847Z 			(caps? "0123456789ABCDEF":"0123456789abcdef")
2025-05-24T14:54:58.5994918Z 			[uvalue % (unsigned)base  ];
2025-05-24T14:54:58.5995089Z 		uvalue = (uvalue / (unsigned)base );
2025-05-24T14:54:58.5995180Z 	} while(uvalue && (place < sizeof(convert)));
2025-05-24T14:54:58.5995267Z 	if (place == sizeof(convert)) place--;
2025-05-24T14:54:58.5995331Z 	convert[place] = 0;
2025-05-24T14:54:58.5995485Z 
2025-05-24T14:54:58.5995614Z 	zpadlen = max - place;
2025-05-24T14:54:58.5995751Z 	spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);
2025-05-24T14:54:58.5995826Z 	if (zpadlen < 0) zpadlen = 0;
2025-05-24T14:54:58.5995895Z 	if (spadlen < 0) spadlen = 0;
2025-05-24T14:54:58.5995972Z 	if (flags & DP_F_ZERO) {
2025-05-24T14:54:58.5996055Z 		zpadlen = MAX(zpadlen, spadlen);
2025-05-24T14:54:58.5996122Z 		spadlen = 0;
2025-05-24T14:54:58.5996178Z 	}
2025-05-24T14:54:58.5996253Z 	if (flags & DP_F_MINUS)
2025-05-24T14:54:58.5996339Z 		spadlen = -spadlen; /* Left Justifty */
2025-05-24T14:54:58.5996343Z 
2025-05-24T14:54:58.5996409Z #ifdef DEBUG_SNPRINTF
2025-05-24T14:54:58.5996546Z 	printf("zpad: %d, spad: %d, min: %d, max: %d, place: %d\n",
2025-05-24T14:54:58.5996629Z 	       zpadlen, spadlen, min, max, place);
2025-05-24T14:54:58.5996687Z #endif
2025-05-24T14:54:58.5996692Z 
2025-05-24T14:54:58.5996753Z 	/* Spaces */
2025-05-24T14:54:58.5996825Z 	while (spadlen > 0) {
2025-05-24T14:54:58.5996912Z 		dopr_outch (buffer, currlen, maxlen, ' ');
2025-05-24T14:54:58.5996974Z 		--spadlen;
2025-05-24T14:54:58.5997034Z 	}
2025-05-24T14:54:58.5997037Z 
2025-05-24T14:54:58.5997096Z 	/* Sign */
2025-05-24T14:54:58.5997158Z 	if (signvalue)
2025-05-24T14:54:58.5997260Z 		dopr_outch (buffer, currlen, maxlen, signvalue);
2025-05-24T14:54:58.5997269Z 
2025-05-24T14:54:58.5997328Z 	/* Zeros */
2025-05-24T14:54:58.5997393Z 	if (zpadlen > 0) {
2025-05-24T14:54:58.5997462Z 		while (zpadlen > 0) {
2025-05-24T14:54:58.5997556Z 			dopr_outch (buffer, currlen, maxlen, '0');
2025-05-24T14:54:58.5997622Z 			--zpadlen;
2025-05-24T14:54:58.5997678Z 		}
2025-05-24T14:54:58.5997742Z 	}
2025-05-24T14:54:58.5997746Z 
2025-05-24T14:54:58.5997804Z 	/* Digits */
2025-05-24T14:54:58.5997873Z 	while (place > 0)
2025-05-24T14:54:58.5997991Z 		dopr_outch (buffer, currlen, maxlen, convert[--place]);
2025-05-24T14:54:58.5998078Z 
2025-05-24T14:54:58.5998163Z 	/* Left Justified spaces */
2025-05-24T14:54:58.5998231Z 	while (spadlen < 0) {
2025-05-24T14:54:58.5998319Z 		dopr_outch (buffer, currlen, maxlen, ' ');
2025-05-24T14:54:58.5998382Z 		++spadlen;
2025-05-24T14:54:58.5998438Z 	}
2025-05-24T14:54:58.5998492Z }
2025-05-24T14:54:58.5998496Z 
2025-05-24T14:54:58.5998583Z static LDOUBLE abs_val(LDOUBLE value)
2025-05-24T14:54:58.5998642Z {
2025-05-24T14:54:58.5998712Z 	LDOUBLE result = value;
2025-05-24T14:54:58.5998716Z 
2025-05-24T14:54:58.5998775Z 	if (value < 0)
2025-05-24T14:54:58.5998847Z 		result = -value;
2025-05-24T14:54:58.5998850Z 
2025-05-24T14:54:58.5998911Z 	return result;
2025-05-24T14:54:58.5998966Z }
2025-05-24T14:54:58.5998969Z 
2025-05-24T14:54:58.5999049Z static LDOUBLE POW10(int exp)
2025-05-24T14:54:58.5999104Z {
2025-05-24T14:54:58.5999170Z 	LDOUBLE result = 1;
2025-05-24T14:54:58.5999177Z 
2025-05-24T14:54:58.5999237Z 	while (exp) {
2025-05-24T14:54:58.5999302Z 		result *= 10;
2025-05-24T14:54:58.5999364Z 		exp--;
2025-05-24T14:54:58.5999418Z 	}
2025-05-24T14:54:58.5999421Z 
2025-05-24T14:54:58.5999486Z 	return result;
2025-05-24T14:54:58.5999544Z }
2025-05-24T14:54:58.5999547Z 
2025-05-24T14:54:58.5999623Z static LLONG ROUND(LDOUBLE value)
2025-05-24T14:54:58.5999678Z {
2025-05-24T14:54:58.5999743Z 	LLONG intpart;
2025-05-24T14:54:58.5999747Z 
2025-05-24T14:54:58.5999814Z 	intpart = (LLONG)value;
2025-05-24T14:54:58.5999886Z 	value = value - intpart;
2025-05-24T14:54:58.5999960Z 	if (value >= 0.5) intpart++;
2025-05-24T14:54:58.6000026Z 
2025-05-24T14:54:58.6000094Z 	return intpart;
2025-05-24T14:54:58.6000152Z }
2025-05-24T14:54:58.6000155Z 
2025-05-24T14:54:58.6000314Z /* a replacement for modf that doesn't need the math library. Should
2025-05-24T14:54:58.6000387Z    be portable, but slow */
2025-05-24T14:54:58.6000584Z static double my_modf(double x0, double *iptr)
2025-05-24T14:54:58.6000642Z {
2025-05-24T14:54:58.6000707Z 	int i;
2025-05-24T14:54:58.6000766Z 	LLONG l=0;
2025-05-24T14:54:58.6000829Z 	double x = x0;
2025-05-24T14:54:58.6000897Z 	double f = 1.0;
2025-05-24T14:54:58.6000901Z 
2025-05-24T14:54:58.6000965Z 	for (i=0;i<100;i++) {
2025-05-24T14:54:58.6001024Z 		l = (long)x;
2025-05-24T14:54:58.6001098Z 		if (l <= (x+1) && l >= (x-1)) break;
2025-05-24T14:54:58.6001163Z 		x *= 0.1;
2025-05-24T14:54:58.6001223Z 		f *= 10.0;
2025-05-24T14:54:58.6001278Z 	}
2025-05-24T14:54:58.6001281Z 
2025-05-24T14:54:58.6001345Z 	if (i == 100) {
2025-05-24T14:54:58.6001489Z 		/* yikes! the number is beyond what we can handle. What do we do? */
2025-05-24T14:54:58.6001553Z 		(*iptr) = 0;
2025-05-24T14:54:58.6001613Z 		return 0;
2025-05-24T14:54:58.6001676Z 	}
2025-05-24T14:54:58.6001680Z 
2025-05-24T14:54:58.6001738Z 	if (i != 0) {
2025-05-24T14:54:58.6001800Z 		double i2;
2025-05-24T14:54:58.6001864Z 		double ret;
2025-05-24T14:54:58.6001868Z 
2025-05-24T14:54:58.6001942Z 		ret = my_modf(x0-l*f, &i2);
2025-05-24T14:54:58.6002007Z 		(*iptr) = l*f + i2;
2025-05-24T14:54:58.6002067Z 		return ret;
2025-05-24T14:54:58.6002133Z 	}
2025-05-24T14:54:58.6002136Z 
2025-05-24T14:54:58.6002196Z 	(*iptr) = l;
2025-05-24T14:54:58.6002263Z 	return x - (*iptr);
2025-05-24T14:54:58.6002326Z }
2025-05-24T14:54:58.6002329Z 
2025-05-24T14:54:58.6002332Z 
2025-05-24T14:54:58.6002473Z static void fmtfp (char *buffer, size_t *currlen, size_t maxlen,
2025-05-24T14:54:58.6002570Z 		   LDOUBLE fvalue, int min, int max, int flags)
2025-05-24T14:54:58.6002633Z {
2025-05-24T14:54:58.6002700Z 	int signvalue = 0;
2025-05-24T14:54:58.6002763Z 	double ufvalue;
2025-05-24T14:54:58.6002831Z 	char iconvert[311];
2025-05-24T14:54:58.6002901Z 	char fconvert[311];
2025-05-24T14:54:58.6002963Z 	int iplace = 0;
2025-05-24T14:54:58.6003028Z 	int fplace = 0;
2025-05-24T14:54:58.6003228Z 	int padlen = 0; /* amount to pad */
2025-05-24T14:54:58.6003329Z 	int zpadlen = 0;
2025-05-24T14:54:58.6003425Z 	int caps = 0;
2025-05-24T14:54:58.6003521Z 	int idx;
2025-05-24T14:54:58.6003757Z 	double intpart;
2025-05-24T14:54:58.6003872Z 	double fracpart;
2025-05-24T14:54:58.6004037Z 	double temp;
2025-05-24T14:54:58.6004042Z 
2025-05-24T14:54:58.6004169Z 	/*
2025-05-24T14:54:58.6004349Z 	 * AIX manpage says the default is 0, but Solaris says the default
2025-05-24T14:54:58.6004451Z 	 * is 6, and sprintf on AIX defaults to 6
2025-05-24T14:54:58.6004590Z 	 */
2025-05-24T14:54:58.6004760Z 	if (max < 0)
2025-05-24T14:54:58.6004852Z 		max = 6;
2025-05-24T14:54:58.6004855Z 
2025-05-24T14:54:58.6004961Z 	ufvalue = abs_val (fvalue);
2025-05-24T14:54:58.6004966Z 
2025-05-24T14:54:58.6005102Z 	if (fvalue < 0) {
2025-05-24T14:54:58.6005187Z 		signvalue = '-';
2025-05-24T14:54:58.6005319Z 	} else {
2025-05-24T14:54:58.6005645Z 		if (flags & DP_F_PLUS) { /* Do a sign (+/i) */
2025-05-24T14:54:58.6005747Z 			signvalue = '+';
2025-05-24T14:54:58.6005839Z 		} else {
2025-05-24T14:54:58.6005945Z 			if (flags & DP_F_SPACE)
2025-05-24T14:54:58.6006067Z 				signvalue = ' ';
2025-05-24T14:54:58.6006220Z 		}
2025-05-24T14:54:58.6006325Z 	}
2025-05-24T14:54:58.6006331Z 
2025-05-24T14:54:58.6006480Z #if 0
2025-05-24T14:54:58.6006770Z 	if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
2025-05-24T14:54:58.6006865Z #endif
2025-05-24T14:54:58.6006870Z 
2025-05-24T14:54:58.6006961Z #if 0
2025-05-24T14:54:58.6007206Z 	 if (max == 0) ufvalue += 0.5; /* if max = 0 we must round */
2025-05-24T14:54:58.6007325Z #endif
2025-05-24T14:54:58.6007332Z 
2025-05-24T14:54:58.6007494Z 	/*
2025-05-24T14:54:58.6007761Z 	 * Sorry, we only support 9 digits past the decimal because of our
2025-05-24T14:54:58.6007867Z 	 * conversion method
2025-05-24T14:54:58.6008073Z 	 */
2025-05-24T14:54:58.6008250Z 	if (max > 9)
2025-05-24T14:54:58.6008368Z 		max = 9;
2025-05-24T14:54:58.6008373Z 
2025-05-24T14:54:58.6008539Z 	/* We "cheat" by converting the fractional part to integer by
2025-05-24T14:54:58.6008653Z 	 * multiplying by a factor of 10
2025-05-24T14:54:58.6008906Z 	 */
2025-05-24T14:54:58.6008910Z 
2025-05-24T14:54:58.6009012Z 	temp = ufvalue;
2025-05-24T14:54:58.6009102Z 	my_modf(temp, &intpart);
2025-05-24T14:54:58.6009108Z 
2025-05-24T14:54:58.6009357Z 	fracpart = ROUND((POW10(max)) * (ufvalue - intpart));
2025-05-24T14:54:58.6009362Z 
2025-05-24T14:54:58.6009471Z 	if (fracpart >= POW10(max)) {
2025-05-24T14:54:58.6009566Z 		intpart++;
2025-05-24T14:54:58.6009731Z 		fracpart -= POW10(max);
2025-05-24T14:54:58.6009819Z 	}
2025-05-24T14:54:58.6009823Z 
2025-05-24T14:54:58.6009826Z 
2025-05-24T14:54:58.6009919Z 	/* Convert integer part */
2025-05-24T14:54:58.6010104Z 	do {
2025-05-24T14:54:58.6010208Z 		temp = intpart*0.1;
2025-05-24T14:54:58.6010316Z 		my_modf(temp, &intpart);
2025-05-24T14:54:58.6010452Z 		idx = (int) ((temp -intpart +0.05)* 10.0);
2025-05-24T14:54:58.6010638Z 		/* idx = (int) (((double)(temp*0.1) -intpart +0.05) *10.0); */
2025-05-24T14:54:58.6010754Z 		/* printf ("%llf, %f, %x\n", temp, intpart, idx); */
2025-05-24T14:54:58.6010900Z 		iconvert[iplace++] =
2025-05-24T14:54:58.6011079Z 			(caps? "0123456789ABCDEF":"0123456789abcdef")[idx];
2025-05-24T14:54:58.6011209Z 	} while (intpart && (iplace < 311));
2025-05-24T14:54:58.6011317Z 	if (iplace == 311) iplace--;
2025-05-24T14:54:58.6011417Z 	iconvert[iplace] = 0;
2025-05-24T14:54:58.6011459Z 
2025-05-24T14:54:58.6011551Z 	/* Convert fractional part */
2025-05-24T14:54:58.6011688Z 	if (fracpart)
2025-05-24T14:54:58.6011791Z 	{
2025-05-24T14:54:58.6011936Z 		do {
2025-05-24T14:54:58.6012039Z 			temp = fracpart*0.1;
2025-05-24T14:54:58.6012143Z 			my_modf(temp, &fracpart);
2025-05-24T14:54:58.6012289Z 			idx = (int) ((temp -fracpart +0.05)* 10.0);
2025-05-24T14:54:58.6012463Z 			/* idx = (int) ((((temp/10) -fracpart) +0.05) *10); */
2025-05-24T14:54:58.6012620Z 			/* printf ("%lf, %lf, %ld\n", temp, fracpart, idx ); */
2025-05-24T14:54:58.6012737Z 			fconvert[fplace++] =
2025-05-24T14:54:58.6012898Z 			(caps? "0123456789ABCDEF":"0123456789abcdef")[idx];
2025-05-24T14:54:58.6013013Z 		} while(fracpart && (fplace < 311));
2025-05-24T14:54:58.6013118Z 		if (fplace == 311) fplace--;
2025-05-24T14:54:58.6013267Z 	}
2025-05-24T14:54:58.6013471Z 	fconvert[fplace] = 0;
2025-05-24T14:54:58.6013476Z 
2025-05-24T14:54:58.6013650Z 	/* -1 for decimal point, another -1 if we are printing a sign */
2025-05-24T14:54:58.6013838Z 	padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);
2025-05-24T14:54:58.6013942Z 	zpadlen = max - fplace;
2025-05-24T14:54:58.6014048Z 	if (zpadlen < 0) zpadlen = 0;
2025-05-24T14:54:58.6014129Z 	if (padlen < 0)
2025-05-24T14:54:58.6014337Z 		padlen = 0;
2025-05-24T14:54:58.6014437Z 	if (flags & DP_F_MINUS)
2025-05-24T14:54:58.6014558Z 		padlen = -padlen; /* Left Justifty */
2025-05-24T14:54:58.6014565Z 
2025-05-24T14:54:58.6014720Z 	if ((flags & DP_F_ZERO) && (padlen > 0)) {
2025-05-24T14:54:58.6014820Z 		if (signvalue) {
2025-05-24T14:54:58.6014940Z 			dopr_outch (buffer, currlen, maxlen, signvalue);
2025-05-24T14:54:58.6015147Z 			--padlen;
2025-05-24T14:54:58.6015242Z 			signvalue = 0;
2025-05-24T14:54:58.6015333Z 		}
2025-05-24T14:54:58.6015663Z 		while (padlen > 0) {
2025-05-24T14:54:58.6015833Z 			dopr_outch (buffer, currlen, maxlen, '0');
2025-05-24T14:54:58.6015919Z 			--padlen;
2025-05-24T14:54:58.6016082Z 		}
2025-05-24T14:54:58.6016224Z 	}
2025-05-24T14:54:58.6016326Z 	while (padlen > 0) {
2025-05-24T14:54:58.6016450Z 		dopr_outch (buffer, currlen, maxlen, ' ');
2025-05-24T14:54:58.6016545Z 		--padlen;
2025-05-24T14:54:58.6016657Z 	}
2025-05-24T14:54:58.6016814Z 	if (signvalue)
2025-05-24T14:54:58.6016966Z 		dopr_outch (buffer, currlen, maxlen, signvalue);
2025-05-24T14:54:58.6016970Z 
2025-05-24T14:54:58.6017105Z 	while (iplace > 0)
2025-05-24T14:54:58.6017350Z 		dopr_outch (buffer, currlen, maxlen, iconvert[--iplace]);
2025-05-24T14:54:58.6017354Z 
2025-05-24T14:54:58.6017455Z #ifdef DEBUG_SNPRINTF
2025-05-24T14:54:58.6017748Z 	printf("fmtfp: fplace=%d zpadlen=%d\n", fplace, zpadlen);
2025-05-24T14:54:58.6017952Z #endif
2025-05-24T14:54:58.6017957Z 
2025-05-24T14:54:58.6018065Z 	/*
2025-05-24T14:54:58.6018423Z 	 * Decimal point.  This should probably use locale to find the correct
2025-05-24T14:54:58.6018667Z 	 * char to print out.
2025-05-24T14:54:58.6018782Z 	 */
2025-05-24T14:54:58.6018882Z 	if (max > 0) {
2025-05-24T14:54:58.6019082Z 		dopr_outch (buffer, currlen, maxlen, '.');
2025-05-24T14:54:58.6019087Z 
2025-05-24T14:54:58.6019208Z 		while (zpadlen > 0) {
2025-05-24T14:54:58.6019331Z 			dopr_outch (buffer, currlen, maxlen, '0');
2025-05-24T14:54:58.6019431Z 			--zpadlen;
2025-05-24T14:54:58.6019571Z 		}
2025-05-24T14:54:58.6019575Z 
2025-05-24T14:54:58.6019672Z 		while (fplace > 0)
2025-05-24T14:54:58.6019818Z 			dopr_outch (buffer, currlen, maxlen, fconvert[--fplace]);
2025-05-24T14:54:58.6020007Z 	}
2025-05-24T14:54:58.6020011Z 
2025-05-24T14:54:58.6020113Z 	while (padlen < 0) {
2025-05-24T14:54:58.6020234Z 		dopr_outch (buffer, currlen, maxlen, ' ');
2025-05-24T14:54:58.6020381Z 		++padlen;
2025-05-24T14:54:58.6020468Z 	}
2025-05-24T14:54:58.6020540Z }
2025-05-24T14:54:58.6020545Z 
2025-05-24T14:54:58.6020797Z static void dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c)
2025-05-24T14:54:58.6020940Z {
2025-05-24T14:54:58.6021061Z 	if (*currlen < maxlen) {
2025-05-24T14:54:58.6021162Z 		buffer[(*currlen)] = c;
2025-05-24T14:54:58.6021285Z 	}
2025-05-24T14:54:58.6021366Z 	(*currlen)++;
2025-05-24T14:54:58.6021492Z }
2025-05-24T14:54:58.6021496Z 
2025-05-24T14:54:58.6021669Z static struct pr_chunk *new_chunk(void) {
2025-05-24T14:54:58.6021886Z 	struct pr_chunk *new_c = (struct pr_chunk *)malloc(sizeof(struct pr_chunk));
2025-05-24T14:54:58.6021890Z 
2025-05-24T14:54:58.6021985Z 	if (!new_c)
2025-05-24T14:54:58.6022079Z 		return NULL;
2025-05-24T14:54:58.6022085Z 
2025-05-24T14:54:58.6022204Z 	new_c->type = 0;
2025-05-24T14:54:58.6022341Z 	new_c->num = 0;
2025-05-24T14:54:58.6022451Z 	new_c->min = 0;
2025-05-24T14:54:58.6022606Z 	new_c->min_star = NULL;
2025-05-24T14:54:58.6022699Z 	new_c->max = -1;
2025-05-24T14:54:58.6022802Z 	new_c->max_star = NULL;
2025-05-24T14:54:58.6022900Z 	new_c->flags = 0;
2025-05-24T14:54:58.6023056Z 	new_c->cflags = 0;
2025-05-24T14:54:58.6023163Z 	new_c->start = 0;
2025-05-24T14:54:58.6023349Z 	new_c->len = 0;
2025-05-24T14:54:58.6023478Z 	new_c->value = 0;
2025-05-24T14:54:58.6023573Z 	new_c->fvalue = 0;
2025-05-24T14:54:58.6023670Z 	new_c->strvalue = NULL;
2025-05-24T14:54:58.6023753Z 	new_c->pnum = NULL;
2025-05-24T14:54:58.6023962Z 	new_c->next = NULL;
2025-05-24T14:54:58.6023966Z 
2025-05-24T14:54:58.6024065Z 	return new_c;
2025-05-24T14:54:58.6024152Z }
2025-05-24T14:54:58.6024156Z 
2025-05-24T14:54:58.6024349Z static int add_cnk_list_entry(struct pr_chunk_x **list,
2025-05-24T14:54:58.6024468Z 				int max_num, struct pr_chunk *chunk) {
2025-05-24T14:54:58.6024556Z 	struct pr_chunk_x *l;
2025-05-24T14:54:58.6024763Z 	struct pr_chunk **c;
2025-05-24T14:54:58.6024854Z 	int max;
2025-05-24T14:54:58.6024945Z 	int cnum;
2025-05-24T14:54:58.6025039Z 	int i, pos;
2025-05-24T14:54:58.6025043Z 
2025-05-24T14:54:58.6025184Z 	if (chunk->num > max_num) {
2025-05-24T14:54:58.6025267Z 		max = chunk->num;
2025-05-24T14:54:58.6025271Z 
2025-05-24T14:54:58.6025584Z 		if (*list == NULL) {
2025-05-24T14:54:58.6025817Z 			l = (struct pr_chunk_x *)malloc(sizeof(struct pr_chunk_x) * max);
2025-05-24T14:54:58.6025912Z 			pos = 0;
2025-05-24T14:54:58.6026002Z 		} else {
2025-05-24T14:54:58.6026218Z 			l = (struct pr_chunk_x *)realloc(*list, sizeof(struct pr_chunk_x) * max);
2025-05-24T14:54:58.6026296Z 			pos = max_num;
2025-05-24T14:54:58.6026450Z 		}
2025-05-24T14:54:58.6026560Z 		if (l == NULL) {
2025-05-24T14:54:58.6026701Z 			for (i = 0; i < max; i++) {
2025-05-24T14:54:58.6026828Z 				if ((*list)[i].chunks) free((*list)[i].chunks);
2025-05-24T14:54:58.6026996Z 			}
2025-05-24T14:54:58.6027125Z 			return 0;
2025-05-24T14:54:58.6027263Z 		}
2025-05-24T14:54:58.6027383Z 		for (i = pos; i < max; i++) {
2025-05-24T14:54:58.6027480Z 			l[i].chunks = NULL;
2025-05-24T14:54:58.6027606Z 			l[i].num = 0;
2025-05-24T14:54:58.6027691Z 		}
2025-05-24T14:54:58.6027900Z 	} else {
2025-05-24T14:54:58.6028059Z 		l = *list;
2025-05-24T14:54:58.6028169Z 		max = max_num;
2025-05-24T14:54:58.6028261Z 	}
2025-05-24T14:54:58.6028265Z 
2025-05-24T14:54:58.6028362Z 	i = chunk->num - 1;
2025-05-24T14:54:58.6028510Z 	cnum = l[i].num + 1;
2025-05-24T14:54:58.6028610Z 	if (l[i].chunks == NULL) {
2025-05-24T14:54:58.6028760Z 		c = (struct pr_chunk **)malloc(sizeof(struct pr_chunk *) * cnum);
2025-05-24T14:54:58.6028947Z 	} else {
2025-05-24T14:54:58.6029149Z 		c = (struct pr_chunk **)realloc(l[i].chunks, sizeof(struct pr_chunk *) * cnum);
2025-05-24T14:54:58.6029238Z 	}
2025-05-24T14:54:58.6029382Z 	if (c == NULL) {
2025-05-24T14:54:58.6029484Z 		for (i = 0; i < max; i++) {
2025-05-24T14:54:58.6029582Z 			if (l[i].chunks) free(l[i].chunks);
2025-05-24T14:54:58.6029712Z 		}
2025-05-24T14:54:58.6029855Z 		return 0;
2025-05-24T14:54:58.6029958Z 	}
2025-05-24T14:54:58.6030055Z 	c[l[i].num] = chunk;
2025-05-24T14:54:58.6030149Z 	l[i].chunks = c;
2025-05-24T14:54:58.6030263Z 	l[i].num = cnum;
2025-05-24T14:54:58.6030271Z 
2025-05-24T14:54:58.6030403Z 	*list = l;
2025-05-24T14:54:58.6030511Z 	return max;
2025-05-24T14:54:58.6030655Z }
2025-05-24T14:54:58.6030658Z 
2025-05-24T14:54:58.6030859Z  int rep_vsnprintf (char *str, size_t count, const char *fmt, va_list args)
2025-05-24T14:54:58.6030948Z {
2025-05-24T14:54:58.6031079Z 	return dopr(str, count, fmt, args);
2025-05-24T14:54:58.6031206Z }
2025-05-24T14:54:58.6031312Z #endif
2025-05-24T14:54:58.6031317Z 
2025-05-24T14:54:58.6031535Z /* yes this really must be a ||. Don't muck with this (tridge)
2025-05-24T14:54:58.6031626Z  *
2025-05-24T14:54:58.6031802Z  * The logic for these two is that we need our own definition if the
2025-05-24T14:54:58.6031982Z  * OS *either* has no definition of *sprintf, or if it does have one
2025-05-24T14:54:58.6032219Z  * that doesn't work properly according to the autoconf test.
2025-05-24T14:54:58.6032322Z  */
2025-05-24T14:54:58.6032502Z #if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6032704Z  int rep_snprintf(char *str,size_t count,const char *fmt,...)
2025-05-24T14:54:58.6032793Z {
2025-05-24T14:54:58.6032956Z 	size_t ret;
2025-05-24T14:54:58.6033034Z 	va_list ap;
2025-05-24T14:54:58.6033120Z 
2025-05-24T14:54:58.6033254Z 	va_start(ap, fmt);
2025-05-24T14:54:58.6033369Z 	ret = vsnprintf(str, count, fmt, ap);
2025-05-24T14:54:58.6033462Z 	va_end(ap);
2025-05-24T14:54:58.6033591Z 	return ret;
2025-05-24T14:54:58.6033679Z }
2025-05-24T14:54:58.6033753Z #endif
2025-05-24T14:54:58.6033757Z 
2025-05-24T14:54:58.6033975Z #ifndef HAVE_C99_VSNPRINTF
2025-05-24T14:54:58.6034090Z  int rep_printf(const char *fmt, ...)
2025-05-24T14:54:58.6034177Z {
2025-05-24T14:54:58.6034270Z 	va_list ap;
2025-05-24T14:54:58.6034397Z 	int ret;
2025-05-24T14:54:58.6034471Z 	char *s;
2025-05-24T14:54:58.6034475Z 
2025-05-24T14:54:58.6034624Z 	s = NULL;
2025-05-24T14:54:58.6034775Z 	va_start(ap, fmt);
2025-05-24T14:54:58.6034881Z 	ret = vasprintf(&s, fmt, ap);
2025-05-24T14:54:58.6034973Z 	va_end(ap);
2025-05-24T14:54:58.6034980Z 
2025-05-24T14:54:58.6035070Z 	if (s) {
2025-05-24T14:54:58.6035196Z 		fwrite(s, 1, strlen(s), stdout);
2025-05-24T14:54:58.6035514Z 	}
2025-05-24T14:54:58.6035697Z 	free(s);
2025-05-24T14:54:58.6035702Z 
2025-05-24T14:54:58.6035837Z 	return ret;
2025-05-24T14:54:58.6035931Z }
2025-05-24T14:54:58.6036021Z #endif
2025-05-24T14:54:58.6036025Z 
2025-05-24T14:54:58.6036171Z #ifndef HAVE_C99_VSNPRINTF
2025-05-24T14:54:58.6036373Z  int rep_fprintf(FILE *stream, const char *fmt, ...)
2025-05-24T14:54:58.6036478Z {
2025-05-24T14:54:58.6036569Z 	va_list ap;
2025-05-24T14:54:58.6036695Z 	int ret;
2025-05-24T14:54:58.6036785Z 	char *s;
2025-05-24T14:54:58.6036789Z 
2025-05-24T14:54:58.6036984Z 	s = NULL;
2025-05-24T14:54:58.6037149Z 	va_start(ap, fmt);
2025-05-24T14:54:58.6037272Z 	ret = vasprintf(&s, fmt, ap);
2025-05-24T14:54:58.6037367Z 	va_end(ap);
2025-05-24T14:54:58.6037371Z 
2025-05-24T14:54:58.6037460Z 	if (s) {
2025-05-24T14:54:58.6037620Z 		fwrite(s, 1, strlen(s), stream);
2025-05-24T14:54:58.6037709Z 	}
2025-05-24T14:54:58.6037889Z 	free(s);
2025-05-24T14:54:58.6037894Z 
2025-05-24T14:54:58.6038089Z 	return ret;
2025-05-24T14:54:58.6038180Z }
2025-05-24T14:54:58.6038268Z #endif
2025-05-24T14:54:58.6038272Z 
2025-05-24T14:54:58.6038414Z #endif
2025-05-24T14:54:58.6038418Z 
2025-05-24T14:54:58.6038584Z #if !defined(HAVE_VASPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6038736Z  int rep_vasprintf(char **ptr, const char *format, va_list ap)
2025-05-24T14:54:58.6038866Z {
2025-05-24T14:54:58.6039010Z 	int ret;
2025-05-24T14:54:58.6039120Z 	va_list ap2;
2025-05-24T14:54:58.6039124Z 
2025-05-24T14:54:58.6039223Z 	VA_COPY(ap2, ap);
2025-05-24T14:54:58.6039376Z 	ret = vsnprintf(NULL, 0, format, ap2);
2025-05-24T14:54:58.6039455Z 	va_end(ap2);
2025-05-24T14:54:58.6039599Z 	if (ret < 0) return ret;
2025-05-24T14:54:58.6039604Z 
2025-05-24T14:54:58.6039765Z 	(*ptr) = (char *)malloc(ret+1);
2025-05-24T14:54:58.6039885Z 	if (!*ptr) return -1;
2025-05-24T14:54:58.6039889Z 
2025-05-24T14:54:58.6039990Z 	VA_COPY(ap2, ap);
2025-05-24T14:54:58.6040112Z 	ret = vsnprintf(*ptr, ret+1, format, ap2);
2025-05-24T14:54:58.6040228Z 	va_end(ap2);
2025-05-24T14:54:58.6040231Z 
2025-05-24T14:54:58.6040367Z 	return ret;
2025-05-24T14:54:58.6040471Z }
2025-05-24T14:54:58.6040615Z #endif
2025-05-24T14:54:58.6040618Z 
2025-05-24T14:54:58.6040777Z #if !defined(HAVE_ASPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6040922Z  int rep_asprintf(char **ptr, const char *format, ...)
2025-05-24T14:54:58.6041032Z {
2025-05-24T14:54:58.6041166Z 	va_list ap;
2025-05-24T14:54:58.6041270Z 	int ret;
2025-05-24T14:54:58.6041274Z 
2025-05-24T14:54:58.6041383Z 	*ptr = NULL;
2025-05-24T14:54:58.6041523Z 	va_start(ap, format);
2025-05-24T14:54:58.6041634Z 	ret = vasprintf(ptr, format, ap);
2025-05-24T14:54:58.6041724Z 	va_end(ap);
2025-05-24T14:54:58.6041728Z 
2025-05-24T14:54:58.6041881Z 	return ret;
2025-05-24T14:54:58.6042000Z }
2025-05-24T14:54:58.6042086Z #endif
2025-05-24T14:54:58.6042089Z 
2025-05-24T14:54:58.6042228Z #ifdef TEST_SNPRINTF
2025-05-24T14:54:58.6042233Z 
2025-05-24T14:54:58.6042356Z  int sprintf(char *str,const char *fmt,...);
2025-05-24T14:54:58.6042534Z  int printf(const char *fmt,...);
2025-05-24T14:54:58.6042538Z 
2025-05-24T14:54:58.6042618Z  int main (void)
2025-05-24T14:54:58.6042816Z {
2025-05-24T14:54:58.6042909Z 	char buf1[1024];
2025-05-24T14:54:58.6043004Z 	char buf2[1024];
2025-05-24T14:54:58.6043130Z 	char *buf3;
2025-05-24T14:54:58.6043225Z 	char *fp_fmt[] = {
2025-05-24T14:54:58.6043300Z 		"%1.1f",
2025-05-24T14:54:58.6043456Z 		"%-1.5f",
2025-05-24T14:54:58.6043596Z 		"%1.5f",
2025-05-24T14:54:58.6043685Z 		"%123.9f",
2025-05-24T14:54:58.6043773Z 		"%10.5f",
2025-05-24T14:54:58.6043897Z 		"% 10.5f",
2025-05-24T14:54:58.6043951Z 		"%+22.9f",
2025-05-24T14:54:58.6049731Z 		"%+4.9f",
2025-05-24T14:54:58.6049821Z 		"%01.3f",
2025-05-24T14:54:58.6049882Z 		"%4f",
2025-05-24T14:54:58.6049940Z 		"%3.1f",
2025-05-24T14:54:58.6050003Z 		"%3.2f",
2025-05-24T14:54:58.6050064Z 		"%.0f",
2025-05-24T14:54:58.6050127Z 		"%f",
2025-05-24T14:54:58.6050188Z 		"%-8.8f",
2025-05-24T14:54:58.6050243Z 		"%-9.9f",
2025-05-24T14:54:58.6050304Z 		NULL
2025-05-24T14:54:58.6050360Z 	};
2025-05-24T14:54:58.6050568Z 	double fp_nums[] = { 6442452944.1234, -1.5, 134.21, 91340.2, 341.1234, 203.9, 0.96, 0.996,
2025-05-24T14:54:58.6050648Z 			     0.9996, 1.996, 4.136, 5.030201, 0.00205,
2025-05-24T14:54:58.6050722Z 			     /* END LIST */ 0};
2025-05-24T14:54:58.6050791Z 	char *int_fmt[] = {
2025-05-24T14:54:58.6050849Z 		"%-1.5d",
2025-05-24T14:54:58.6050906Z 		"%1.5d",
2025-05-24T14:54:58.6050962Z 		"%123.9d",
2025-05-24T14:54:58.6051022Z 		"%5.5d",
2025-05-24T14:54:58.6051081Z 		"%10.5d",
2025-05-24T14:54:58.6051253Z 		"% 10.5d",
2025-05-24T14:54:58.6051317Z 		"%+22.33d",
2025-05-24T14:54:58.6051374Z 		"%01.3d",
2025-05-24T14:54:58.6051432Z 		"%4d",
2025-05-24T14:54:58.6051488Z 		"%d",
2025-05-24T14:54:58.6051550Z 		NULL
2025-05-24T14:54:58.6051605Z 	};
2025-05-24T14:54:58.6051842Z 	long int_nums[] = { -1, 134, 91340, 341, 0203, 1234567890, 0};
2025-05-24T14:54:58.6051915Z 	char *str_fmt[] = {
2025-05-24T14:54:58.6051981Z 		"%10.5s",
2025-05-24T14:54:58.6052042Z 		"%-10.5s",
2025-05-24T14:54:58.6052102Z 		"%5.10s",
2025-05-24T14:54:58.6052164Z 		"%-5.10s",
2025-05-24T14:54:58.6052222Z 		"%10.1s",
2025-05-24T14:54:58.6052278Z 		"%0.10s",
2025-05-24T14:54:58.6052333Z 		"%10.0s",
2025-05-24T14:54:58.6052392Z 		"%1.10s",
2025-05-24T14:54:58.6052448Z 		"%s",
2025-05-24T14:54:58.6052506Z 		"%.1s",
2025-05-24T14:54:58.6052566Z 		"%.10s",
2025-05-24T14:54:58.6052623Z 		"%10s",
2025-05-24T14:54:58.6052679Z 		NULL
2025-05-24T14:54:58.6052734Z 	};
2025-05-24T14:54:58.6052871Z 	char *str_vals[] = {"hello", "a", "", "a longer string", NULL};
2025-05-24T14:54:58.6052943Z #ifdef HAVE_LONG_LONG
2025-05-24T14:54:58.6053008Z 	char *ll_fmt[] = {
2025-05-24T14:54:58.6053065Z 		"%llu",
2025-05-24T14:54:58.6053126Z 		NULL
2025-05-24T14:54:58.6053181Z 	};
2025-05-24T14:54:58.6053322Z 	LLONG ll_nums[] = { 134, 91340, 341, 0203, 1234567890, 128006186140000000LL, 0};
2025-05-24T14:54:58.6053387Z #endif
2025-05-24T14:54:58.6053446Z 	int x, y;
2025-05-24T14:54:58.6053508Z 	int fail = 0;
2025-05-24T14:54:58.6053569Z 	int num = 0;
2025-05-24T14:54:58.6053632Z 	int l1, l2;
2025-05-24T14:54:58.6053696Z 	char *ss_fmt[] = {
2025-05-24T14:54:58.6053754Z 		"%zd",
2025-05-24T14:54:58.6053817Z 		"%zu",
2025-05-24T14:54:58.6053874Z 		NULL
2025-05-24T14:54:58.6053927Z 	};
2025-05-24T14:54:58.6054044Z 	size_t ss_nums[] = {134, 91340, 123456789, 0203, 1234567890, 0};
2025-05-24T14:54:58.6054050Z 
2025-05-24T14:54:58.6054227Z 	printf ("Testing snprintf format codes against system sprintf...\n");
2025-05-24T14:54:58.6054232Z 
2025-05-24T14:54:58.6054307Z 	for (x = 0; fp_fmt[x] ; x++) {
2025-05-24T14:54:58.6054386Z 		for (y = 0; fp_nums[y] != 0 ; y++) {
2025-05-24T14:54:58.6054461Z 			buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6054584Z 			l1 = snprintf(buf1, sizeof(buf1), fp_fmt[x], fp_nums[y]);
2025-05-24T14:54:58.6054674Z 			l2 = sprintf (buf2, fp_fmt[x], fp_nums[y]);
2025-05-24T14:54:58.6054751Z 			buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6054833Z 			if (strcmp (buf1, buf2) || (l1 != l2)) {
2025-05-24T14:54:58.6055128Z 				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6055208Z 				       fp_fmt[x], l1, buf1, l2, buf2);
2025-05-24T14:54:58.6055272Z 				fail++;
2025-05-24T14:54:58.6055328Z 			}
2025-05-24T14:54:58.6055631Z 			num++;
2025-05-24T14:54:58.6055702Z 		}
2025-05-24T14:54:58.6055758Z 	}
2025-05-24T14:54:58.6055762Z 
2025-05-24T14:54:58.6055837Z 	for (x = 0; int_fmt[x] ; x++) {
2025-05-24T14:54:58.6055912Z 		for (y = 0; int_nums[y] != 0 ; y++) {
2025-05-24T14:54:58.6055987Z 			buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6056112Z 			l1 = snprintf(buf1, sizeof(buf1), int_fmt[x], int_nums[y]);
2025-05-24T14:54:58.6056201Z 			l2 = sprintf (buf2, int_fmt[x], int_nums[y]);
2025-05-24T14:54:58.6056275Z 			buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6056355Z 			if (strcmp (buf1, buf2) || (l1 != l2)) {
2025-05-24T14:54:58.6056573Z 				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6056656Z 				       int_fmt[x], l1, buf1, l2, buf2);
2025-05-24T14:54:58.6056715Z 				fail++;
2025-05-24T14:54:58.6056771Z 			}
2025-05-24T14:54:58.6056829Z 			num++;
2025-05-24T14:54:58.6056888Z 		}
2025-05-24T14:54:58.6056943Z 	}
2025-05-24T14:54:58.6056947Z 
2025-05-24T14:54:58.6057018Z 	for (x = 0; str_fmt[x] ; x++) {
2025-05-24T14:54:58.6057093Z 		for (y = 0; str_vals[y] != 0 ; y++) {
2025-05-24T14:54:58.6057160Z 			buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6057280Z 			l1 = snprintf(buf1, sizeof(buf1), str_fmt[x], str_vals[y]);
2025-05-24T14:54:58.6057449Z 			l2 = sprintf (buf2, str_fmt[x], str_vals[y]);
2025-05-24T14:54:58.6057523Z 			buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6057600Z 			if (strcmp (buf1, buf2) || (l1 != l2)) {
2025-05-24T14:54:58.6057902Z 				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6057985Z 				       str_fmt[x], l1, buf1, l2, buf2);
2025-05-24T14:54:58.6058043Z 				fail++;
2025-05-24T14:54:58.6058102Z 			}
2025-05-24T14:54:58.6058159Z 			num++;
2025-05-24T14:54:58.6058218Z 		}
2025-05-24T14:54:58.6058273Z 	}
2025-05-24T14:54:58.6058277Z 
2025-05-24T14:54:58.6058345Z #ifdef HAVE_LONG_LONG
2025-05-24T14:54:58.6058419Z 	for (x = 0; ll_fmt[x] ; x++) {
2025-05-24T14:54:58.6058492Z 		for (y = 0; ll_nums[y] != 0 ; y++) {
2025-05-24T14:54:58.6058556Z 			buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6058669Z 			l1 = snprintf(buf1, sizeof(buf1), ll_fmt[x], ll_nums[y]);
2025-05-24T14:54:58.6058761Z 			l2 = sprintf (buf2, ll_fmt[x], ll_nums[y]);
2025-05-24T14:54:58.6058829Z 			buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6058906Z 			if (strcmp (buf1, buf2) || (l1 != l2)) {
2025-05-24T14:54:58.6059120Z 				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6059196Z 				       ll_fmt[x], l1, buf1, l2, buf2);
2025-05-24T14:54:58.6059255Z 				fail++;
2025-05-24T14:54:58.6059313Z 			}
2025-05-24T14:54:58.6059377Z 			num++;
2025-05-24T14:54:58.6059433Z 		}
2025-05-24T14:54:58.6059488Z 	}
2025-05-24T14:54:58.6059548Z #endif
2025-05-24T14:54:58.6059551Z 
2025-05-24T14:54:58.6059616Z #define BUFSZ 2048
2025-05-24T14:54:58.6059621Z 
2025-05-24T14:54:58.6059687Z 	buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6059768Z 	if ((buf3 = malloc(BUFSZ)) == NULL) {
2025-05-24T14:54:58.6059826Z 		fail++;
2025-05-24T14:54:58.6059882Z 	} else {
2025-05-24T14:54:58.6059940Z 		num++;
2025-05-24T14:54:58.6060014Z 		memset(buf3, 'a', BUFSZ);
2025-05-24T14:54:58.6060107Z 		snprintf(buf1, sizeof(buf1), "%.*s", 1, buf3);
2025-05-24T14:54:58.6060171Z 		buf1[1023] = '\0';
2025-05-24T14:54:58.6060248Z 		if (strcmp(buf1, "a") != 0) {
2025-05-24T14:54:58.6060365Z 			printf("length limit buf1 '%s' expected 'a'\n", buf1);
2025-05-24T14:54:58.6060424Z 			fail++;
2025-05-24T14:54:58.6060479Z 		}
2025-05-24T14:54:58.6060542Z         }
2025-05-24T14:54:58.6060549Z 
2025-05-24T14:54:58.6060613Z 	buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6060784Z 	l1 = snprintf(buf1, sizeof(buf1), "%4$*1$d %2$s %3$*1$.*1$f", 3, "pos test", 12.3456, 9);
2025-05-24T14:54:58.6060987Z 	l2 = sprintf(buf2, "%4$*1$d %2$s %3$*1$.*1$f", 3, "pos test", 12.3456, 9);
2025-05-24T14:54:58.6061059Z 	buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6061136Z 	if (strcmp(buf1, buf2) || (l1 != l2)) {
2025-05-24T14:54:58.6061343Z 		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6061433Z 				"%4$*1$d %2$s %3$*1$.*1$f", l1, buf1, l2, buf2);
2025-05-24T14:54:58.6061490Z 		fail++;
2025-05-24T14:54:58.6061547Z 	}
2025-05-24T14:54:58.6061551Z 
2025-05-24T14:54:58.6061619Z 	buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6061779Z 	l1 = snprintf(buf1, sizeof(buf1), "%4$*4$d %2$s %3$*4$.*4$f", 3, "pos test", 12.3456, 9);
2025-05-24T14:54:58.6061907Z 	l2 = sprintf(buf2, "%4$*4$d %2$s %3$*4$.*4$f", 3, "pos test", 12.3456, 9);
2025-05-24T14:54:58.6062017Z 	buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6062088Z 	if (strcmp(buf1, buf2)) {
2025-05-24T14:54:58.6062293Z 		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6062371Z 				"%4$*1$d %2$s %3$*1$.*1$f", l1, buf1, l2, buf2);
2025-05-24T14:54:58.6062432Z 		fail++;
2025-05-24T14:54:58.6062486Z 	}
2025-05-24T14:54:58.6062489Z 
2025-05-24T14:54:58.6062561Z 	for (x = 0; ss_fmt[x] ; x++) {
2025-05-24T14:54:58.6062637Z 		for (y = 0; ss_nums[y] != 0 ; y++) {
2025-05-24T14:54:58.6062706Z 			buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6062818Z 			l1 = snprintf(buf1, sizeof(buf1), ss_fmt[x], ss_nums[y]);
2025-05-24T14:54:58.6062958Z 			l2 = sprintf (buf2, ss_fmt[x], ss_nums[y]);
2025-05-24T14:54:58.6063025Z 			buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6063104Z 			if (strcmp (buf1, buf2) || (l1 != l2)) {
2025-05-24T14:54:58.6063378Z 				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6063458Z 				       ss_fmt[x], l1, buf1, l2, buf2);
2025-05-24T14:54:58.6063516Z 				fail++;
2025-05-24T14:54:58.6063573Z 			}
2025-05-24T14:54:58.6063634Z 			num++;
2025-05-24T14:54:58.6063688Z 		}
2025-05-24T14:54:58.6063743Z 	}
2025-05-24T14:54:58.6063800Z #if 0
2025-05-24T14:54:58.6063871Z 	buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6063999Z 	l1 = snprintf(buf1, sizeof(buf1), "%lld", (LLONG)1234567890);
2025-05-24T14:54:58.6064087Z 	l2 = sprintf(buf2, "%lld", (LLONG)1234567890);
2025-05-24T14:54:58.6064160Z 	buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6064229Z 	if (strcmp(buf1, buf2)) {
2025-05-24T14:54:58.6064437Z 		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6064511Z 				"%lld", l1, buf1, l2, buf2);
2025-05-24T14:54:58.6064573Z 		fail++;
2025-05-24T14:54:58.6064628Z 	}
2025-05-24T14:54:58.6064632Z 
2025-05-24T14:54:58.6064695Z 	buf1[0] = buf2[0] = '\0';
2025-05-24T14:54:58.6064854Z 	l1 = snprintf(buf1, sizeof(buf1), "%Lf", (LDOUBLE)890.1234567890123);
2025-05-24T14:54:58.6064959Z 	l2 = sprintf(buf2, "%Lf", (LDOUBLE)890.1234567890123);
2025-05-24T14:54:58.6065027Z 	buf1[1023] = buf2[1023] = '\0';
2025-05-24T14:54:58.6065097Z 	if (strcmp(buf1, buf2)) {
2025-05-24T14:54:58.6065313Z 		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
2025-05-24T14:54:58.6065500Z 				"%Lf", l1, buf1, l2, buf2);
2025-05-24T14:54:58.6065559Z 		fail++;
2025-05-24T14:54:58.6065624Z 	}
2025-05-24T14:54:58.6065681Z #endif
2025-05-24T14:54:58.6065786Z 	printf ("%d tests failed out of %d.\n", fail, num);
2025-05-24T14:54:58.6065790Z 
2025-05-24T14:54:58.6065897Z 	printf("seeing how many digits we support\n");
2025-05-24T14:54:58.6065952Z 	{
2025-05-24T14:54:58.6066050Z 		double v0 = 0.12345678901234567890123456789012345678901;
2025-05-24T14:54:58.6066130Z 		for (x=0; x<100; x++) {
2025-05-24T14:54:58.6066210Z 			double p = pow(10, x);
2025-05-24T14:54:58.6066281Z 			double r = v0*p;
2025-05-24T14:54:58.6066370Z 			snprintf(buf1, sizeof(buf1), "%1.1f", r);
2025-05-24T14:54:58.6066447Z 			sprintf(buf2,                "%1.1f", r);
2025-05-24T14:54:58.6066599Z 			if (strcmp(buf1, buf2)) {
2025-05-24T14:54:58.6066701Z 				printf("we seem to support %d digits\n", x-1);
2025-05-24T14:54:58.6066759Z 				break;
2025-05-24T14:54:58.6066812Z 			}
2025-05-24T14:54:58.6066879Z 		}
2025-05-24T14:54:58.6066933Z 	}
2025-05-24T14:54:58.6066936Z 
2025-05-24T14:54:58.6066996Z 	return 0;
2025-05-24T14:54:58.6067056Z }
2025-05-24T14:54:58.6067128Z #endif /* TEST_SNPRINTF */
2025-05-24T14:54:58.6067189Z -------------------
2025-05-24T14:54:58.6067265Z Content of lib/replace/socket.c:
2025-05-24T14:54:58.6067326Z /*
2025-05-24T14:54:58.6067403Z  * Unix SMB/CIFS implementation.
2025-05-24T14:54:58.6067458Z  *
2025-05-24T14:54:58.6067554Z  * Dummy replacements for socket functions.
2025-05-24T14:54:58.6067608Z  *
2025-05-24T14:54:58.6067719Z  * Copyright (C) Michael Adam <obnox@samba.org> 2008
2025-05-24T14:54:58.6067779Z  *
2025-05-24T14:54:58.6067910Z  *   ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.6068044Z  *   ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.6068108Z  *   ** under the LGPL
2025-05-24T14:54:58.6068169Z  *
2025-05-24T14:54:58.6068307Z  * This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.6068438Z  * modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.6068575Z  * License as published by the Free Software Foundation; either
2025-05-24T14:54:58.6068719Z  * version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.6068775Z  *
2025-05-24T14:54:58.6068980Z  * This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.6069124Z  * but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.6069284Z  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.6069507Z  * Library General Public License for more details.
2025-05-24T14:54:58.6069570Z  *
2025-05-24T14:54:58.6069723Z  * You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.6069919Z  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.6069973Z  */
2025-05-24T14:54:58.6069977Z 
2025-05-24T14:54:58.6070049Z #include "replace.h"
2025-05-24T14:54:58.6070123Z #include "system/network.h"
2025-05-24T14:54:58.6070127Z 
2025-05-24T14:54:58.6070310Z int rep_connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen)
2025-05-24T14:54:58.6070370Z {
2025-05-24T14:54:58.6070432Z 	errno = ENOSYS;
2025-05-24T14:54:58.6070494Z 	return -1;
2025-05-24T14:54:58.6070552Z }
2025-05-24T14:54:58.6070561Z 
2025-05-24T14:54:58.6070674Z struct hostent *rep_gethostbyname(const char *name)
2025-05-24T14:54:58.6070729Z {
2025-05-24T14:54:58.6070793Z 	errno = ENOSYS;
2025-05-24T14:54:58.6070860Z 	return NULL;
2025-05-24T14:54:58.6070914Z }
2025-05-24T14:54:58.6070977Z -------------------
2025-05-24T14:54:58.6071064Z Content of lib/replace/socketpair.c:
2025-05-24T14:54:58.6071125Z /*
2025-05-24T14:54:58.6071203Z  * Unix SMB/CIFS implementation.
2025-05-24T14:54:58.6071293Z  * replacement routines for broken systems
2025-05-24T14:54:58.6071415Z  * Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2006
2025-05-24T14:54:58.6071522Z  * Copyright (C) Michael Adam <obnox@samba.org> 2008
2025-05-24T14:54:58.6071577Z  *
2025-05-24T14:54:58.6071704Z  *  ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.6071836Z  *  ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.6071901Z  *  ** under the LGPL
2025-05-24T14:54:58.6071958Z  *
2025-05-24T14:54:58.6072103Z  * This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.6072227Z  * modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.6072362Z  * License as published by the Free Software Foundation; either
2025-05-24T14:54:58.6072502Z  * version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.6072559Z  *
2025-05-24T14:54:58.6072748Z  * This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.6072887Z  * but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.6073054Z  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.6073154Z  * Lesser General Public License for more details.
2025-05-24T14:54:58.6073210Z  *
2025-05-24T14:54:58.6073357Z  * You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.6073537Z  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.6073593Z  */
2025-05-24T14:54:58.6073597Z 
2025-05-24T14:54:58.6073669Z #include "replace.h"
2025-05-24T14:54:58.6073742Z #include "system/network.h"
2025-05-24T14:54:58.6073746Z 
2025-05-24T14:54:58.6073879Z int rep_socketpair(int d, int type, int protocol, int sv[2])
2025-05-24T14:54:58.6073936Z {
2025-05-24T14:54:58.6074007Z 	if (d != AF_UNIX) {
2025-05-24T14:54:58.6074079Z 		errno = EAFNOSUPPORT;
2025-05-24T14:54:58.6074143Z 		return -1;
2025-05-24T14:54:58.6074201Z 	}
2025-05-24T14:54:58.6074205Z 
2025-05-24T14:54:58.6074270Z 	if (protocol != 0) {
2025-05-24T14:54:58.6074345Z 		errno = EPROTONOSUPPORT;
2025-05-24T14:54:58.6074404Z 		return -1;
2025-05-24T14:54:58.6074463Z 	}
2025-05-24T14:54:58.6074466Z 
2025-05-24T14:54:58.6074535Z 	if (type != SOCK_STREAM) {
2025-05-24T14:54:58.6074602Z 		errno = EOPNOTSUPP;
2025-05-24T14:54:58.6074666Z 		return -1;
2025-05-24T14:54:58.6074721Z 	}
2025-05-24T14:54:58.6074725Z 
2025-05-24T14:54:58.6074791Z 	return pipe(sv);
2025-05-24T14:54:58.6074894Z }
2025-05-24T14:54:58.6074958Z -------------------
2025-05-24T14:54:58.6075043Z Content of lib/replace/strptime.c:
2025-05-24T14:54:58.6075173Z /* Convert a string representation of time to a time value.
2025-05-24T14:54:58.6075329Z    Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
2025-05-24T14:54:58.6075775Z    This file is part of the GNU C Library.
2025-05-24T14:54:58.6075925Z    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
2025-05-24T14:54:58.6075931Z 
2025-05-24T14:54:58.6076082Z    The GNU C Library is free software; you can redistribute it and/or
2025-05-24T14:54:58.6076237Z    modify it under the terms of the GNU Lesser General Public License as
2025-05-24T14:54:58.6076382Z    published by the Free Software Foundation; either version 3 of the
2025-05-24T14:54:58.6076488Z    License, or (at your option) any later version.
2025-05-24T14:54:58.6076493Z 
2025-05-24T14:54:58.6076646Z    The GNU C Library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.6076786Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.6076944Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.6077050Z    Library General Public License for more details.
2025-05-24T14:54:58.6077054Z 
2025-05-24T14:54:58.6077197Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.6077359Z    License along with the GNU C Library; see the file COPYING.LIB.  If not, 
2025-05-24T14:54:58.6077457Z    see <http://www.gnu.org/licenses/>.  */
2025-05-24T14:54:58.6077461Z 
2025-05-24T14:54:58.6077599Z /* XXX This version of the implementation is not really complete.
2025-05-24T14:54:58.6077731Z    Some of the fields cannot add information alone.  But if seeing
2025-05-24T14:54:58.6077864Z    some of them in the same format (such as year, week and weekday)
2025-05-24T14:54:58.6077984Z    this is enough information for determining the date.  */
2025-05-24T14:54:58.6077990Z 
2025-05-24T14:54:58.6078058Z #include "replace.h"
2025-05-24T14:54:58.6078135Z #include "system/locale.h"
2025-05-24T14:54:58.6078204Z #include "system/time.h"
2025-05-24T14:54:58.6078207Z 
2025-05-24T14:54:58.6078268Z #ifndef __P
2025-05-24T14:54:58.6078378Z # if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
2025-05-24T14:54:58.6078454Z #  define __P(args) args
2025-05-24T14:54:58.6078512Z # else
2025-05-24T14:54:58.6078577Z #  define __P(args) ()
2025-05-24T14:54:58.6078710Z # endif  /* GCC.  */
2025-05-24T14:54:58.6078776Z #endif  /* Not __P.  */
2025-05-24T14:54:58.6078780Z 
2025-05-24T14:54:58.6078878Z #if ! HAVE_LOCALTIME_R && ! defined localtime_r
2025-05-24T14:54:58.6078942Z # ifdef _LIBC
2025-05-24T14:54:58.6079025Z #  define localtime_r __localtime_r
2025-05-24T14:54:58.6079082Z # else
2025-05-24T14:54:58.6079218Z /* Approximate localtime_r as best we can in its absence.  */
2025-05-24T14:54:58.6079302Z #  define localtime_r my_localtime_r
2025-05-24T14:54:58.6079452Z static struct tm *localtime_r __P ((const time_t *, struct tm *));
2025-05-24T14:54:58.6079520Z static struct tm *
2025-05-24T14:54:58.6079590Z localtime_r (t, tp)
2025-05-24T14:54:58.6079656Z      const time_t *t;
2025-05-24T14:54:58.6079717Z      struct tm *tp;
2025-05-24T14:54:58.6079773Z {
2025-05-24T14:54:58.6079852Z   struct tm *l = localtime (t);
2025-05-24T14:54:58.6079916Z   if (! l)
2025-05-24T14:54:58.6079975Z     return 0;
2025-05-24T14:54:58.6080033Z   *tp = *l;
2025-05-24T14:54:58.6080099Z   return tp;
2025-05-24T14:54:58.6080153Z }
2025-05-24T14:54:58.6080216Z # endif /* ! _LIBC */
2025-05-24T14:54:58.6080336Z #endif /* ! HAVE_LOCALTIME_R && ! defined (localtime_r) */
2025-05-24T14:54:58.6080340Z 
2025-05-24T14:54:58.6080343Z 
2025-05-24T14:54:58.6080458Z #define match_char(ch1, ch2) if (ch1 != ch2) return NULL
2025-05-24T14:54:58.6080535Z #if defined __GNUC__ && __GNUC__ >= 2
2025-05-24T14:54:58.6080615Z # define match_string(cs1, s2) \
2025-05-24T14:54:58.6080697Z   ({ size_t len = strlen (cs1);						      \
2025-05-24T14:54:58.6080884Z      int result = strncasecmp ((cs1), (s2), len) == 0;			      \
2025-05-24T14:54:58.6080962Z      if (result) (s2) += len;						      \
2025-05-24T14:54:58.6081026Z      result; })
2025-05-24T14:54:58.6081081Z #else
2025-05-24T14:54:58.6081173Z /* Oh come on.  Get a reasonable compiler.  */
2025-05-24T14:54:58.6081345Z # define match_string(cs1, s2) \
2025-05-24T14:54:58.6081495Z   (strncasecmp ((cs1), (s2), strlen (cs1)) ? 0 : ((s2) += strlen (cs1), 1))
2025-05-24T14:54:58.6081554Z #endif
2025-05-24T14:54:58.6081710Z /* We intentionally do not use isdigit() for testing because this will
2025-05-24T14:54:58.6081829Z    lead to problems with the wide character version.  */
2025-05-24T14:54:58.6081907Z #define get_number(from, to, n) \
2025-05-24T14:54:58.6081968Z   do {									      \
2025-05-24T14:54:58.6082041Z     int __n = n;							      \
2025-05-24T14:54:58.6082105Z     val = 0;								      \
2025-05-24T14:54:58.6082176Z     while (*rp == ' ')							      \
2025-05-24T14:54:58.6082247Z       ++rp;								      \
2025-05-24T14:54:58.6082324Z     if (*rp < '0' || *rp > '9')						      \
2025-05-24T14:54:58.6082392Z       return NULL;							      \
2025-05-24T14:54:58.6082453Z     do {								      \
2025-05-24T14:54:58.6082524Z       val *= 10;							      \
2025-05-24T14:54:58.6082599Z       val += *rp++ - '0';						      \
2025-05-24T14:54:58.6082725Z     } while (--__n > 0 && val * 10 <= to && *rp >= '0' && *rp <= '9');	      \
2025-05-24T14:54:58.6082811Z     if (val < from || val > to)						      \
2025-05-24T14:54:58.6082881Z       return NULL;							      \
2025-05-24T14:54:58.6082941Z   } while (0)
2025-05-24T14:54:58.6083006Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6083091Z # define get_alt_number(from, to, n) \
2025-05-24T14:54:58.6083149Z   ({									      \
2025-05-24T14:54:58.6083224Z     __label__ do_normal;						      \
2025-05-24T14:54:58.6083303Z     if (*decided != raw)						      \
2025-05-24T14:54:58.6083362Z       {									      \
2025-05-24T14:54:58.6083494Z 	const char *alts = _NL_CURRENT (LC_TIME, ALT_DIGITS);		      \
2025-05-24T14:54:58.6083559Z 	int __n = n;							      \
2025-05-24T14:54:58.6083631Z 	int any = 0;							      \
2025-05-24T14:54:58.6083701Z 	while (*rp == ' ')						      \
2025-05-24T14:54:58.6083763Z 	  ++rp;								      \
2025-05-24T14:54:58.6083831Z 	val = 0;							      \
2025-05-24T14:54:58.6083891Z 	do {								      \
2025-05-24T14:54:58.6083953Z 	  val *= 10;							      \
2025-05-24T14:54:58.6084074Z 	  while (*alts != '\0')						      \
2025-05-24T14:54:58.6084138Z 	    {								      \
2025-05-24T14:54:58.6084221Z 	      size_t len = strlen (alts);				      \
2025-05-24T14:54:58.6084315Z 	      if (strncasecmp (alts, rp, len) == 0)			      \
2025-05-24T14:54:58.6084386Z 	        break;							      \
2025-05-24T14:54:58.6084454Z 	      alts += len + 1;						      \
2025-05-24T14:54:58.6084516Z 	      ++val;							      \
2025-05-24T14:54:58.6084575Z 	    }								      \
2025-05-24T14:54:58.6084649Z 	  if (*alts == '\0')						      \
2025-05-24T14:54:58.6084709Z 	    {								      \
2025-05-24T14:54:58.6084792Z 	      if (*decided == not && ! any)				      \
2025-05-24T14:54:58.6084869Z 		goto do_normal;						      \
2025-05-24T14:54:58.6084988Z 	      /* If we haven't read anything it's an error.  */		      \
2025-05-24T14:54:58.6085057Z 	      if (! any)						      \
2025-05-24T14:54:58.6085124Z 		return NULL;						      \
2025-05-24T14:54:58.6085246Z 	      /* Correct the premature multiplication.  */		      \
2025-05-24T14:54:58.6085320Z 	      val /= 10;						      \
2025-05-24T14:54:58.6085598Z 	      break;							      \
2025-05-24T14:54:58.6085659Z 	    }								      \
2025-05-24T14:54:58.6085723Z 	  else								      \
2025-05-24T14:54:58.6085798Z 	    *decided = loc;						      \
2025-05-24T14:54:58.6085897Z 	} while (--__n > 0 && val * 10 <= to);				      \
2025-05-24T14:54:58.6085975Z 	if (val < from || val > to)					      \
2025-05-24T14:54:58.6086045Z 	  return NULL;							      \
2025-05-24T14:54:58.6086112Z       }									      \
2025-05-24T14:54:58.6086246Z     else								      \
2025-05-24T14:54:58.6086306Z       {									      \
2025-05-24T14:54:58.6086374Z        do_normal:							      \
2025-05-24T14:54:58.6086462Z         get_number (from, to, n);					      \
2025-05-24T14:54:58.6086520Z       }									      \
2025-05-24T14:54:58.6086679Z     0;									      \
2025-05-24T14:54:58.6086742Z   })
2025-05-24T14:54:58.6086798Z #else
2025-05-24T14:54:58.6086884Z # define get_alt_number(from, to, n) \
2025-05-24T14:54:58.6087006Z   /* We don't have the alternate representation.  */			      \
2025-05-24T14:54:58.6087084Z   get_number(from, to, n)
2025-05-24T14:54:58.6087141Z #endif
2025-05-24T14:54:58.6087217Z #define recursive(new_fmt) \
2025-05-24T14:54:58.6087294Z   (*(new_fmt) != '\0'							      \
2025-05-24T14:54:58.6087456Z    && (rp = strptime_internal (rp, (new_fmt), tm, decided, era_cnt)) != NULL)
2025-05-24T14:54:58.6087461Z 
2025-05-24T14:54:58.6087465Z 
2025-05-24T14:54:58.6087525Z #ifdef _LIBC
2025-05-24T14:54:58.6087655Z /* This is defined in locale/C-time.c in the GNU libc.  */
2025-05-24T14:54:58.6087755Z extern const struct locale_data _nl_C_LC_TIME;
2025-05-24T14:54:58.6087858Z extern const unsigned short int __mon_yday[2][13];
2025-05-24T14:54:58.6087862Z 
2025-05-24T14:54:58.6088029Z # define weekday_name (&_nl_C_LC_TIME.values[_NL_ITEM_INDEX (DAY_1)].string)
2025-05-24T14:54:58.6088107Z # define ab_weekday_name \
2025-05-24T14:54:58.6088219Z   (&_nl_C_LC_TIME.values[_NL_ITEM_INDEX (ABDAY_1)].string)
2025-05-24T14:54:58.6088370Z # define month_name (&_nl_C_LC_TIME.values[_NL_ITEM_INDEX (MON_1)].string)
2025-05-24T14:54:58.6088535Z # define ab_month_name (&_nl_C_LC_TIME.values[_NL_ITEM_INDEX (ABMON_1)].string)
2025-05-24T14:54:58.6088689Z # define HERE_D_T_FMT (_nl_C_LC_TIME.values[_NL_ITEM_INDEX (D_T_FMT)].string)
2025-05-24T14:54:58.6088839Z # define HERE_D_FMT (_nl_C_LC_TIME.values[_NL_ITEM_INDEX (D_FMT)].string)
2025-05-24T14:54:58.6088993Z # define HERE_AM_STR (_nl_C_LC_TIME.values[_NL_ITEM_INDEX (AM_STR)].string)
2025-05-24T14:54:58.6089153Z # define HERE_PM_STR (_nl_C_LC_TIME.values[_NL_ITEM_INDEX (PM_STR)].string)
2025-05-24T14:54:58.6089225Z # define HERE_T_FMT_AMPM \
2025-05-24T14:54:58.6089348Z   (_nl_C_LC_TIME.values[_NL_ITEM_INDEX (T_FMT_AMPM)].string)
2025-05-24T14:54:58.6089494Z # define HERE_T_FMT (_nl_C_LC_TIME.values[_NL_ITEM_INDEX (T_FMT)].string)
2025-05-24T14:54:58.6089498Z 
2025-05-24T14:54:58.6089619Z # define strncasecmp(s1, s2, n) __strncasecmp (s1, s2, n)
2025-05-24T14:54:58.6089741Z #else
2025-05-24T14:54:58.6089829Z static char const weekday_name[][10] =
2025-05-24T14:54:58.6089886Z   {
2025-05-24T14:54:58.6089978Z     "Sunday", "Monday", "Tuesday", "Wednesday",
2025-05-24T14:54:58.6090063Z     "Thursday", "Friday", "Saturday"
2025-05-24T14:54:58.6090118Z   };
2025-05-24T14:54:58.6090205Z static char const ab_weekday_name[][4] =
2025-05-24T14:54:58.6090259Z   {
2025-05-24T14:54:58.6090354Z     "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
2025-05-24T14:54:58.6090413Z   };
2025-05-24T14:54:58.6090491Z static char const month_name[][10] =
2025-05-24T14:54:58.6090552Z   {
2025-05-24T14:54:58.6090663Z     "January", "February", "March", "April", "May", "June",
2025-05-24T14:54:58.6090794Z     "July", "August", "September", "October", "November", "December"
2025-05-24T14:54:58.6090851Z   };
2025-05-24T14:54:58.6090940Z static char const ab_month_name[][4] =
2025-05-24T14:54:58.6090996Z   {
2025-05-24T14:54:58.6091078Z     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
2025-05-24T14:54:58.6091163Z     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
2025-05-24T14:54:58.6091219Z   };
2025-05-24T14:54:58.6091302Z # define HERE_D_T_FMT "%a %b %e %H:%M:%S %Y"
2025-05-24T14:54:58.6091376Z # define HERE_D_FMT "%m/%d/%y"
2025-05-24T14:54:58.6091452Z # define HERE_AM_STR "AM"
2025-05-24T14:54:58.6091523Z # define HERE_PM_STR "PM"
2025-05-24T14:54:58.6091604Z # define HERE_T_FMT_AMPM "%I:%M:%S %p"
2025-05-24T14:54:58.6091682Z # define HERE_T_FMT "%H:%M:%S"
2025-05-24T14:54:58.6091686Z 
2025-05-24T14:54:58.6091860Z static const unsigned short int __mon_yday[2][13] =
2025-05-24T14:54:58.6091918Z   {
2025-05-24T14:54:58.6091987Z     /* Normal years.  */
2025-05-24T14:54:58.6092089Z     { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
2025-05-24T14:54:58.6092155Z     /* Leap years.  */
2025-05-24T14:54:58.6092317Z     { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
2025-05-24T14:54:58.6092381Z   };
2025-05-24T14:54:58.6092440Z #endif
2025-05-24T14:54:58.6092444Z 
2025-05-24T14:54:58.6092585Z /* Status of lookup: do we use the locale data or the raw data?  */
2025-05-24T14:54:58.6092671Z enum locale_status { not, loc, raw };
2025-05-24T14:54:58.6092676Z 
2025-05-24T14:54:58.6092679Z 
2025-05-24T14:54:58.6092742Z #ifndef __isleap
2025-05-24T14:54:58.6092842Z /* Nonzero if YEAR is a leap year (every 4 years,
2025-05-24T14:54:58.6092951Z    except every 100th isn't, and every 400th is).  */
2025-05-24T14:54:58.6093023Z # define __isleap(year)	\
2025-05-24T14:54:58.6093123Z   ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
2025-05-24T14:54:58.6093184Z #endif
2025-05-24T14:54:58.6093187Z 
2025-05-24T14:54:58.6093274Z /* Compute the day of the week.  */
2025-05-24T14:54:58.6093338Z static void
2025-05-24T14:54:58.6093416Z day_of_the_week (struct tm *tm)
2025-05-24T14:54:58.6093481Z {
2025-05-24T14:54:58.6093624Z   /* We know that January 1st 1970 was a Thursday (= 4).  Compute the
2025-05-24T14:54:58.6093777Z      the difference between this data in the one on TM and so determine
2025-05-24T14:54:58.6093846Z      the weekday.  */
2025-05-24T14:54:58.6093962Z   int corr_year = 1900 + tm->tm_year - (tm->tm_mon < 2);
2025-05-24T14:54:58.6094027Z   int wday = (-473
2025-05-24T14:54:58.6094100Z 	      + (365 * (tm->tm_year - 70))
2025-05-24T14:54:58.6094172Z 	      + (corr_year / 4)
2025-05-24T14:54:58.6094273Z 	      - ((corr_year / 4) / 25) + ((corr_year / 4) % 25 < 0)
2025-05-24T14:54:58.6094347Z 	      + (((corr_year / 4) / 25) / 4)
2025-05-24T14:54:58.6094418Z 	      + __mon_yday[0][tm->tm_mon]
2025-05-24T14:54:58.6094496Z 	      + tm->tm_mday - 1);
2025-05-24T14:54:58.6094569Z   tm->tm_wday = ((wday % 7) + 7) % 7;
2025-05-24T14:54:58.6094624Z }
2025-05-24T14:54:58.6094628Z 
2025-05-24T14:54:58.6094712Z /* Compute the day of the year.  */
2025-05-24T14:54:58.6094775Z static void
2025-05-24T14:54:58.6094852Z day_of_the_year (struct tm *tm)
2025-05-24T14:54:58.6094915Z {
2025-05-24T14:54:58.6095047Z   tm->tm_yday = (__mon_yday[__isleap (1900 + tm->tm_year)][tm->tm_mon]
2025-05-24T14:54:58.6095168Z 		 + (tm->tm_mday - 1));
2025-05-24T14:54:58.6095228Z }
2025-05-24T14:54:58.6095232Z 
2025-05-24T14:54:58.6095301Z static char *
2025-05-24T14:54:58.6095542Z #ifdef _LIBC
2025-05-24T14:54:58.6095637Z internal_function
2025-05-24T14:54:58.6095704Z #endif
2025-05-24T14:54:58.6095875Z strptime_internal __P ((const char *rp, const char *fmt, struct tm *tm,
2025-05-24T14:54:58.6095970Z 			enum locale_status *decided, int era_cnt));
2025-05-24T14:54:58.6095974Z 
2025-05-24T14:54:58.6096036Z static char *
2025-05-24T14:54:58.6096106Z #ifdef _LIBC
2025-05-24T14:54:58.6096172Z internal_function
2025-05-24T14:54:58.6096229Z #endif
2025-05-24T14:54:58.6096341Z strptime_internal (rp, fmt, tm, decided, era_cnt)
2025-05-24T14:54:58.6096406Z      const char *rp;
2025-05-24T14:54:58.6096470Z      const char *fmt;
2025-05-24T14:54:58.6096535Z      struct tm *tm;
2025-05-24T14:54:58.6096618Z      enum locale_status *decided;
2025-05-24T14:54:58.6096679Z      int era_cnt;
2025-05-24T14:54:58.6096736Z {
2025-05-24T14:54:58.6096800Z   int cnt;
2025-05-24T14:54:58.6096861Z   size_t val;
2025-05-24T14:54:58.6096926Z   int have_I, is_pm;
2025-05-24T14:54:58.6097000Z   int century, want_century;
2025-05-24T14:54:58.6097065Z   int want_era;
2025-05-24T14:54:58.6097135Z   int have_wday, want_xday;
2025-05-24T14:54:58.6097197Z   int have_yday;
2025-05-24T14:54:58.6097272Z   int have_mon, have_mday;
2025-05-24T14:54:58.6097337Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6097406Z   const char *rp_backup;
2025-05-24T14:54:58.6097550Z   size_t num_eras;
2025-05-24T14:54:58.6097628Z   struct era_entry *era;
2025-05-24T14:54:58.6097632Z 
2025-05-24T14:54:58.6097690Z   era = NULL;
2025-05-24T14:54:58.6097746Z #endif
2025-05-24T14:54:58.6097750Z 
2025-05-24T14:54:58.6097819Z   have_I = is_pm = 0;
2025-05-24T14:54:58.6097886Z   century = -1;
2025-05-24T14:54:58.6098057Z   want_century = 0;
2025-05-24T14:54:58.6098121Z   want_era = 0;
2025-05-24T14:54:58.6098125Z 
2025-05-24T14:54:58.6098261Z   have_wday = want_xday = have_yday = have_mon = have_mday = 0;
2025-05-24T14:54:58.6098264Z 
2025-05-24T14:54:58.6098330Z   while (*fmt != '\0')
2025-05-24T14:54:58.6098386Z     {
2025-05-24T14:54:58.6098516Z       /* A white space in the format string matches 0 more or white
2025-05-24T14:54:58.6098595Z 	 space in the input string.  */
2025-05-24T14:54:58.6098665Z       if (isspace (*fmt))
2025-05-24T14:54:58.6098721Z 	{
2025-05-24T14:54:58.6098796Z 	  while (isspace (*rp))
2025-05-24T14:54:58.6098854Z 	    ++rp;
2025-05-24T14:54:58.6098913Z 	  ++fmt;
2025-05-24T14:54:58.6098980Z 	  continue;
2025-05-24T14:54:58.6099039Z 	}
2025-05-24T14:54:58.6099042Z 
2025-05-24T14:54:58.6099175Z       /* Any character but `%' must be matched by the same character
2025-05-24T14:54:58.6099251Z 	 in the input string.  */
2025-05-24T14:54:58.6099315Z       if (*fmt != '%')
2025-05-24T14:54:58.6099373Z 	{
2025-05-24T14:54:58.6099453Z 	  match_char (*fmt++, *rp++);
2025-05-24T14:54:58.6099520Z 	  continue;
2025-05-24T14:54:58.6099579Z 	}
2025-05-24T14:54:58.6099583Z 
2025-05-24T14:54:58.6099641Z       ++fmt;
2025-05-24T14:54:58.6099707Z #ifndef _NL_CURRENT
2025-05-24T14:54:58.6099822Z       /* We need this for handling the `E' modifier.  */
2025-05-24T14:54:58.6099885Z     start_over:
2025-05-24T14:54:58.6099943Z #endif
2025-05-24T14:54:58.6099947Z 
2025-05-24T14:54:58.6100016Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6100124Z       /* Make back up of current processing pointer.  */
2025-05-24T14:54:58.6100190Z       rp_backup = rp;
2025-05-24T14:54:58.6100254Z #endif
2025-05-24T14:54:58.6100259Z 
2025-05-24T14:54:58.6100323Z       switch (*fmt++)
2025-05-24T14:54:58.6100380Z 	{
2025-05-24T14:54:58.6100439Z 	case '%':
2025-05-24T14:54:58.6100529Z 	  /* Match the `%' character itself.  */
2025-05-24T14:54:58.6100599Z 	  match_char ('%', *rp++);
2025-05-24T14:54:58.6100658Z 	  break;
2025-05-24T14:54:58.6100726Z 	case 'a':
2025-05-24T14:54:58.6100785Z 	case 'A':
2025-05-24T14:54:58.6100856Z 	  /* Match day of week.  */
2025-05-24T14:54:58.6100994Z 	  for (cnt = 0; cnt < 7; ++cnt)
2025-05-24T14:54:58.6101057Z 	    {
2025-05-24T14:54:58.6101122Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6101192Z 	      if (*decided !=raw)
2025-05-24T14:54:58.6101254Z 		{
2025-05-24T14:54:58.6101379Z 		  if (match_string (_NL_CURRENT (LC_TIME, DAY_1 + cnt), rp))
2025-05-24T14:54:58.6101439Z 		    {
2025-05-24T14:54:58.6101507Z 		      if (*decided == not
2025-05-24T14:54:58.6101607Z 			  && strcmp (_NL_CURRENT (LC_TIME, DAY_1 + cnt),
2025-05-24T14:54:58.6101676Z 				     weekday_name[cnt]))
2025-05-24T14:54:58.6101742Z 			*decided = loc;
2025-05-24T14:54:58.6101807Z 		      break;
2025-05-24T14:54:58.6101864Z 		    }
2025-05-24T14:54:58.6101988Z 		  if (match_string (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt), rp))
2025-05-24T14:54:58.6102047Z 		    {
2025-05-24T14:54:58.6102123Z 		      if (*decided == not
2025-05-24T14:54:58.6102224Z 			  && strcmp (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt),
2025-05-24T14:54:58.6102296Z 				     ab_weekday_name[cnt]))
2025-05-24T14:54:58.6102369Z 			*decided = loc;
2025-05-24T14:54:58.6102428Z 		      break;
2025-05-24T14:54:58.6102487Z 		    }
2025-05-24T14:54:58.6102542Z 		}
2025-05-24T14:54:58.6102605Z #endif
2025-05-24T14:54:58.6102673Z 	      if (*decided != loc
2025-05-24T14:54:58.6102759Z 		  && (match_string (weekday_name[cnt], rp)
2025-05-24T14:54:58.6102854Z 		      || match_string (ab_weekday_name[cnt], rp)))
2025-05-24T14:54:58.6102916Z 		{
2025-05-24T14:54:58.6102979Z 		  *decided = raw;
2025-05-24T14:54:58.6103041Z 		  break;
2025-05-24T14:54:58.6103101Z 		}
2025-05-24T14:54:58.6103209Z 	    }
2025-05-24T14:54:58.6103271Z 	  if (cnt == 7)
2025-05-24T14:54:58.6103353Z 	    /* Does not match a weekday name.  */
2025-05-24T14:54:58.6103420Z 	    return NULL;
2025-05-24T14:54:58.6103485Z 	  tm->tm_wday = cnt;
2025-05-24T14:54:58.6103549Z 	  have_wday = 1;
2025-05-24T14:54:58.6103615Z 	  break;
2025-05-24T14:54:58.6103745Z 	case 'b':
2025-05-24T14:54:58.6103806Z 	case 'B':
2025-05-24T14:54:58.6103864Z 	case 'h':
2025-05-24T14:54:58.6103941Z 	  /* Match month name.  */
2025-05-24T14:54:58.6104012Z 	  for (cnt = 0; cnt < 12; ++cnt)
2025-05-24T14:54:58.6104069Z 	    {
2025-05-24T14:54:58.6104137Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6104207Z 	      if (*decided !=raw)
2025-05-24T14:54:58.6104263Z 		{
2025-05-24T14:54:58.6104386Z 		  if (match_string (_NL_CURRENT (LC_TIME, MON_1 + cnt), rp))
2025-05-24T14:54:58.6104447Z 		    {
2025-05-24T14:54:58.6104514Z 		      if (*decided == not
2025-05-24T14:54:58.6104605Z 			  && strcmp (_NL_CURRENT (LC_TIME, MON_1 + cnt),
2025-05-24T14:54:58.6104680Z 				     month_name[cnt]))
2025-05-24T14:54:58.6104745Z 			*decided = loc;
2025-05-24T14:54:58.6104802Z 		      break;
2025-05-24T14:54:58.6104859Z 		    }
2025-05-24T14:54:58.6104984Z 		  if (match_string (_NL_CURRENT (LC_TIME, ABMON_1 + cnt), rp))
2025-05-24T14:54:58.6105041Z 		    {
2025-05-24T14:54:58.6105109Z 		      if (*decided == not
2025-05-24T14:54:58.6105206Z 			  && strcmp (_NL_CURRENT (LC_TIME, ABMON_1 + cnt),
2025-05-24T14:54:58.6105279Z 				     ab_month_name[cnt]))
2025-05-24T14:54:58.6105460Z 			*decided = loc;
2025-05-24T14:54:58.6105522Z 		      break;
2025-05-24T14:54:58.6105583Z 		    }
2025-05-24T14:54:58.6105638Z 		}
2025-05-24T14:54:58.6105694Z #endif
2025-05-24T14:54:58.6105782Z 	      if (match_string (month_name[cnt], rp)
2025-05-24T14:54:58.6105873Z 		  || match_string (ab_month_name[cnt], rp))
2025-05-24T14:54:58.6105929Z 		{
2025-05-24T14:54:58.6105991Z 		  *decided = raw;
2025-05-24T14:54:58.6106053Z 		  break;
2025-05-24T14:54:58.6106108Z 		}
2025-05-24T14:54:58.6106167Z 	    }
2025-05-24T14:54:58.6106228Z 	  if (cnt == 12)
2025-05-24T14:54:58.6106312Z 	    /* Does not match a month name.  */
2025-05-24T14:54:58.6106372Z 	    return NULL;
2025-05-24T14:54:58.6106435Z 	  tm->tm_mon = cnt;
2025-05-24T14:54:58.6106501Z 	  want_xday = 1;
2025-05-24T14:54:58.6106561Z 	  break;
2025-05-24T14:54:58.6106622Z 	case 'c':
2025-05-24T14:54:58.6106711Z 	  /* Match locale's date and time format.  */
2025-05-24T14:54:58.6106849Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6106918Z 	  if (*decided != raw)
2025-05-24T14:54:58.6106974Z 	    {
2025-05-24T14:54:58.6107080Z 	      if (!recursive (_NL_CURRENT (LC_TIME, D_T_FMT)))
2025-05-24T14:54:58.6107138Z 		{
2025-05-24T14:54:58.6107207Z 		  if (*decided == loc)
2025-05-24T14:54:58.6107269Z 		    return NULL;
2025-05-24T14:54:58.6107336Z 		  else
2025-05-24T14:54:58.6107400Z 		    rp = rp_backup;
2025-05-24T14:54:58.6107459Z 		}
2025-05-24T14:54:58.6107524Z 	      else
2025-05-24T14:54:58.6107580Z 		{
2025-05-24T14:54:58.6107648Z 		  if (*decided == not &&
2025-05-24T14:54:58.6107762Z 		      strcmp (_NL_CURRENT (LC_TIME, D_T_FMT), HERE_D_T_FMT))
2025-05-24T14:54:58.6107833Z 		    *decided = loc;
2025-05-24T14:54:58.6107895Z 		  want_xday = 1;
2025-05-24T14:54:58.6107954Z 		  break;
2025-05-24T14:54:58.6108009Z 		}
2025-05-24T14:54:58.6108079Z 	      *decided = raw;
2025-05-24T14:54:58.6108138Z 	    }
2025-05-24T14:54:58.6108195Z #endif
2025-05-24T14:54:58.6108276Z 	  if (!recursive (HERE_D_T_FMT))
2025-05-24T14:54:58.6108339Z 	    return NULL;
2025-05-24T14:54:58.6108402Z 	  want_xday = 1;
2025-05-24T14:54:58.6108459Z 	  break;
2025-05-24T14:54:58.6108522Z 	case 'C':
2025-05-24T14:54:58.6108594Z 	  /* Match century number.  */
2025-05-24T14:54:58.6108656Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6108723Z 	match_century:
2025-05-24T14:54:58.6108777Z #endif
2025-05-24T14:54:58.6108844Z 	  get_number (0, 99, 2);
2025-05-24T14:54:58.6108906Z 	  century = val;
2025-05-24T14:54:58.6108972Z 	  want_xday = 1;
2025-05-24T14:54:58.6109030Z 	  break;
2025-05-24T14:54:58.6109154Z 	case 'd':
2025-05-24T14:54:58.6109219Z 	case 'e':
2025-05-24T14:54:58.6109290Z 	  /* Match day of month.  */
2025-05-24T14:54:58.6109358Z 	  get_number (1, 31, 2);
2025-05-24T14:54:58.6109423Z 	  tm->tm_mday = val;
2025-05-24T14:54:58.6109490Z 	  have_mday = 1;
2025-05-24T14:54:58.6109552Z 	  want_xday = 1;
2025-05-24T14:54:58.6109706Z 	  break;
2025-05-24T14:54:58.6109767Z 	case 'F':
2025-05-24T14:54:58.6109846Z 	  if (!recursive ("%Y-%m-%d"))
2025-05-24T14:54:58.6109910Z 	    return NULL;
2025-05-24T14:54:58.6109973Z 	  want_xday = 1;
2025-05-24T14:54:58.6110037Z 	  break;
2025-05-24T14:54:58.6110097Z 	case 'x':
2025-05-24T14:54:58.6110160Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6110229Z 	  if (*decided != raw)
2025-05-24T14:54:58.6110291Z 	    {
2025-05-24T14:54:58.6110386Z 	      if (!recursive (_NL_CURRENT (LC_TIME, D_FMT)))
2025-05-24T14:54:58.6110444Z 		{
2025-05-24T14:54:58.6110518Z 		  if (*decided == loc)
2025-05-24T14:54:58.6110580Z 		    return NULL;
2025-05-24T14:54:58.6110637Z 		  else
2025-05-24T14:54:58.6110703Z 		    rp = rp_backup;
2025-05-24T14:54:58.6110765Z 		}
2025-05-24T14:54:58.6110822Z 	      else
2025-05-24T14:54:58.6110878Z 		{
2025-05-24T14:54:58.6110949Z 		  if (*decided == not
2025-05-24T14:54:58.6111058Z 		      && strcmp (_NL_CURRENT (LC_TIME, D_FMT), HERE_D_FMT))
2025-05-24T14:54:58.6111126Z 		    *decided = loc;
2025-05-24T14:54:58.6111191Z 		  want_xday = 1;
2025-05-24T14:54:58.6111253Z 		  break;
2025-05-24T14:54:58.6111310Z 		}
2025-05-24T14:54:58.6111374Z 	      *decided = raw;
2025-05-24T14:54:58.6111437Z 	    }
2025-05-24T14:54:58.6111491Z #endif
2025-05-24T14:54:58.6111496Z 
2025-05-24T14:54:58.6111556Z 	  FALL_THROUGH;
2025-05-24T14:54:58.6111614Z 	case 'D':
2025-05-24T14:54:58.6111696Z 	  /* Match standard day format.  */
2025-05-24T14:54:58.6111766Z 	  if (!recursive (HERE_D_FMT))
2025-05-24T14:54:58.6111826Z 	    return NULL;
2025-05-24T14:54:58.6111894Z 	  want_xday = 1;
2025-05-24T14:54:58.6111951Z 	  break;
2025-05-24T14:54:58.6112009Z 	case 'k':
2025-05-24T14:54:58.6112067Z 	case 'H':
2025-05-24T14:54:58.6112153Z 	  /* Match hour in 24-hour clock.  */
2025-05-24T14:54:58.6112220Z 	  get_number (0, 23, 2);
2025-05-24T14:54:58.6112283Z 	  tm->tm_hour = val;
2025-05-24T14:54:58.6112343Z 	  have_I = 0;
2025-05-24T14:54:58.6112405Z 	  break;
2025-05-24T14:54:58.6112462Z 	case 'I':
2025-05-24T14:54:58.6112541Z 	  /* Match hour in 12-hour clock.  */
2025-05-24T14:54:58.6112613Z 	  get_number (1, 12, 2);
2025-05-24T14:54:58.6112753Z 	  tm->tm_hour = val % 12;
2025-05-24T14:54:58.6112813Z 	  have_I = 1;
2025-05-24T14:54:58.6112870Z 	  break;
2025-05-24T14:54:58.6112935Z 	case 'j':
2025-05-24T14:54:58.6113011Z 	  /* Match day number of year.  */
2025-05-24T14:54:58.6113078Z 	  get_number (1, 366, 3);
2025-05-24T14:54:58.6113150Z 	  tm->tm_yday = val - 1;
2025-05-24T14:54:58.6113212Z 	  have_yday = 1;
2025-05-24T14:54:58.6113270Z 	  break;
2025-05-24T14:54:58.6113328Z 	case 'm':
2025-05-24T14:54:58.6113405Z 	  /* Match number of month.  */
2025-05-24T14:54:58.6113474Z 	  get_number (1, 12, 2);
2025-05-24T14:54:58.6113540Z 	  tm->tm_mon = val - 1;
2025-05-24T14:54:58.6113604Z 	  have_mon = 1;
2025-05-24T14:54:58.6113666Z 	  want_xday = 1;
2025-05-24T14:54:58.6113723Z 	  break;
2025-05-24T14:54:58.6113780Z 	case 'M':
2025-05-24T14:54:58.6113851Z 	  /* Match minute.  */
2025-05-24T14:54:58.6113919Z 	  get_number (0, 59, 2);
2025-05-24T14:54:58.6113983Z 	  tm->tm_min = val;
2025-05-24T14:54:58.6114044Z 	  break;
2025-05-24T14:54:58.6114105Z 	case 'n':
2025-05-24T14:54:58.6114164Z 	case 't':
2025-05-24T14:54:58.6114240Z 	  /* Match any white space.  */
2025-05-24T14:54:58.6114314Z 	  while (isspace (*rp))
2025-05-24T14:54:58.6114372Z 	    ++rp;
2025-05-24T14:54:58.6114427Z 	  break;
2025-05-24T14:54:58.6114485Z 	case 'p':
2025-05-24T14:54:58.6114580Z 	  /* Match locale's equivalent of AM/PM.  */
2025-05-24T14:54:58.6114643Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6114711Z 	  if (*decided != raw)
2025-05-24T14:54:58.6114771Z 	    {
2025-05-24T14:54:58.6114885Z 	      if (match_string (_NL_CURRENT (LC_TIME, AM_STR), rp))
2025-05-24T14:54:58.6114989Z 		{
2025-05-24T14:54:58.6115103Z 		  if (strcmp (_NL_CURRENT (LC_TIME, AM_STR), HERE_AM_STR))
2025-05-24T14:54:58.6115172Z 		    *decided = loc;
2025-05-24T14:54:58.6115230Z 		  break;
2025-05-24T14:54:58.6115287Z 		}
2025-05-24T14:54:58.6115746Z 	      if (match_string (_NL_CURRENT (LC_TIME, PM_STR), rp))
2025-05-24T14:54:58.6115815Z 		{
2025-05-24T14:54:58.6115935Z 		  if (strcmp (_NL_CURRENT (LC_TIME, PM_STR), HERE_PM_STR))
2025-05-24T14:54:58.6116002Z 		    *decided = loc;
2025-05-24T14:54:58.6116073Z 		  is_pm = 1;
2025-05-24T14:54:58.6116130Z 		  break;
2025-05-24T14:54:58.6116186Z 		}
2025-05-24T14:54:58.6116256Z 	      *decided = raw;
2025-05-24T14:54:58.6116313Z 	    }
2025-05-24T14:54:58.6116369Z #endif
2025-05-24T14:54:58.6116453Z 	  if (!match_string (HERE_AM_STR, rp)) {
2025-05-24T14:54:58.6116545Z 	    if (match_string (HERE_PM_STR, rp)) {
2025-05-24T14:54:58.6116605Z 	      is_pm = 1;
2025-05-24T14:54:58.6116663Z 	    } else {
2025-05-24T14:54:58.6116735Z 	      return NULL;
2025-05-24T14:54:58.6116793Z 	    }
2025-05-24T14:54:58.6116847Z 	  }
2025-05-24T14:54:58.6116905Z 	  break;
2025-05-24T14:54:58.6116969Z 	case 'r':
2025-05-24T14:54:58.6117030Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6117094Z 	  if (*decided != raw)
2025-05-24T14:54:58.6117158Z 	    {
2025-05-24T14:54:58.6117270Z 	      if (!recursive (_NL_CURRENT (LC_TIME, T_FMT_AMPM)))
2025-05-24T14:54:58.6117327Z 		{
2025-05-24T14:54:58.6117393Z 		  if (*decided == loc)
2025-05-24T14:54:58.6117458Z 		    return NULL;
2025-05-24T14:54:58.6117514Z 		  else
2025-05-24T14:54:58.6117577Z 		    rp = rp_backup;
2025-05-24T14:54:58.6117633Z 		}
2025-05-24T14:54:58.6117695Z 	      else
2025-05-24T14:54:58.6117750Z 		{
2025-05-24T14:54:58.6117817Z 		  if (*decided == not &&
2025-05-24T14:54:58.6117914Z 		      strcmp (_NL_CURRENT (LC_TIME, T_FMT_AMPM),
2025-05-24T14:54:58.6117981Z 			      HERE_T_FMT_AMPM))
2025-05-24T14:54:58.6118044Z 		    *decided = loc;
2025-05-24T14:54:58.6118102Z 		  break;
2025-05-24T14:54:58.6118164Z 		}
2025-05-24T14:54:58.6118227Z 	      *decided = raw;
2025-05-24T14:54:58.6118282Z 	    }
2025-05-24T14:54:58.6118342Z #endif
2025-05-24T14:54:58.6118421Z 	  if (!recursive (HERE_T_FMT_AMPM))
2025-05-24T14:54:58.6118483Z 	    return NULL;
2025-05-24T14:54:58.6118541Z 	  break;
2025-05-24T14:54:58.6118606Z 	case 'R':
2025-05-24T14:54:58.6118681Z 	  if (!recursive ("%H:%M"))
2025-05-24T14:54:58.6118812Z 	    return NULL;
2025-05-24T14:54:58.6118874Z 	  break;
2025-05-24T14:54:58.6118931Z 	case 's':
2025-05-24T14:54:58.6118988Z 	  {
2025-05-24T14:54:58.6119113Z 	    /* The number of seconds may be very high so we cannot use
2025-05-24T14:54:58.6119219Z 	       the `get_number' macro.  Instead read the number
2025-05-24T14:54:58.6119339Z 	       character for character and construct the result while
2025-05-24T14:54:58.6119405Z 	       doing this.  */
2025-05-24T14:54:58.6119473Z 	    time_t secs = 0;
2025-05-24T14:54:58.6119542Z 	    if (*rp < '0' || *rp > '9')
2025-05-24T14:54:58.6119625Z 	      /* We need at least one digit.  */
2025-05-24T14:54:58.6119688Z 	      return NULL;
2025-05-24T14:54:58.6119692Z 
2025-05-24T14:54:58.6119755Z 	    do
2025-05-24T14:54:58.6119810Z 	      {
2025-05-24T14:54:58.6119869Z 		secs *= 10;
2025-05-24T14:54:58.6119941Z 		secs += *rp++ - '0';
2025-05-24T14:54:58.6120002Z 	      }
2025-05-24T14:54:58.6120075Z 	    while (*rp >= '0' && *rp <= '9');
2025-05-24T14:54:58.6120081Z 
2025-05-24T14:54:58.6120159Z 	    if (localtime_r (&secs, tm) == NULL)
2025-05-24T14:54:58.6120238Z 	      /* Error in function.  */
2025-05-24T14:54:58.6120300Z 	      return NULL;
2025-05-24T14:54:58.6120356Z 	  }
2025-05-24T14:54:58.6120416Z 	  break;
2025-05-24T14:54:58.6120473Z 	case 'S':
2025-05-24T14:54:58.6120538Z 	  get_number (0, 61, 2);
2025-05-24T14:54:58.6120603Z 	  tm->tm_sec = val;
2025-05-24T14:54:58.6120668Z 	  break;
2025-05-24T14:54:58.6120726Z 	case 'X':
2025-05-24T14:54:58.6120791Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6120861Z 	  if (*decided != raw)
2025-05-24T14:54:58.6120981Z 	    {
2025-05-24T14:54:58.6121076Z 	      if (!recursive (_NL_CURRENT (LC_TIME, T_FMT)))
2025-05-24T14:54:58.6121131Z 		{
2025-05-24T14:54:58.6121201Z 		  if (*decided == loc)
2025-05-24T14:54:58.6121262Z 		    return NULL;
2025-05-24T14:54:58.6121319Z 		  else
2025-05-24T14:54:58.6121459Z 		    rp = rp_backup;
2025-05-24T14:54:58.6121517Z 		}
2025-05-24T14:54:58.6121574Z 	      else
2025-05-24T14:54:58.6121632Z 		{
2025-05-24T14:54:58.6121745Z 		  if (strcmp (_NL_CURRENT (LC_TIME, T_FMT), HERE_T_FMT))
2025-05-24T14:54:58.6121809Z 		    *decided = loc;
2025-05-24T14:54:58.6121865Z 		  break;
2025-05-24T14:54:58.6121920Z 		}
2025-05-24T14:54:58.6121986Z 	      *decided = raw;
2025-05-24T14:54:58.6122042Z 	    }
2025-05-24T14:54:58.6122098Z #endif
2025-05-24T14:54:58.6122102Z 
2025-05-24T14:54:58.6122167Z 	  FALL_THROUGH;
2025-05-24T14:54:58.6122226Z 	case 'T':
2025-05-24T14:54:58.6122297Z 	  if (!recursive (HERE_T_FMT))
2025-05-24T14:54:58.6122358Z 	    return NULL;
2025-05-24T14:54:58.6122424Z 	  break;
2025-05-24T14:54:58.6122480Z 	case 'u':
2025-05-24T14:54:58.6122545Z 	  get_number (1, 7, 1);
2025-05-24T14:54:58.6122617Z 	  tm->tm_wday = val % 7;
2025-05-24T14:54:58.6122679Z 	  have_wday = 1;
2025-05-24T14:54:58.6122736Z 	  break;
2025-05-24T14:54:58.6122792Z 	case 'g':
2025-05-24T14:54:58.6122864Z 	  get_number (0, 99, 2);
2025-05-24T14:54:58.6122963Z 	  /* XXX This cannot determine any field in TM.  */
2025-05-24T14:54:58.6123022Z 	  break;
2025-05-24T14:54:58.6123085Z 	case 'G':
2025-05-24T14:54:58.6123153Z 	  if (*rp < '0' || *rp > '9')
2025-05-24T14:54:58.6123216Z 	    return NULL;
2025-05-24T14:54:58.6123324Z 	  /* XXX Ignore the number since we would need some more
2025-05-24T14:54:58.6123418Z 	     information to compute a real date.  */
2025-05-24T14:54:58.6123473Z 	  do
2025-05-24T14:54:58.6123533Z 	    ++rp;
2025-05-24T14:54:58.6123607Z 	  while (*rp >= '0' && *rp <= '9');
2025-05-24T14:54:58.6123663Z 	  break;
2025-05-24T14:54:58.6123720Z 	case 'U':
2025-05-24T14:54:58.6123779Z 	case 'V':
2025-05-24T14:54:58.6123844Z 	case 'W':
2025-05-24T14:54:58.6123911Z 	  get_number (0, 53, 2);
2025-05-24T14:54:58.6124026Z 	  /* XXX This cannot determine any field in TM without some
2025-05-24T14:54:58.6124097Z 	     information.  */
2025-05-24T14:54:58.6124154Z 	  break;
2025-05-24T14:54:58.6124215Z 	case 'w':
2025-05-24T14:54:58.6124290Z 	  /* Match number of weekday.  */
2025-05-24T14:54:58.6124360Z 	  get_number (0, 6, 1);
2025-05-24T14:54:58.6124474Z 	  tm->tm_wday = val;
2025-05-24T14:54:58.6124534Z 	  have_wday = 1;
2025-05-24T14:54:58.6124594Z 	  break;
2025-05-24T14:54:58.6124649Z 	case 'y':
2025-05-24T14:54:58.6124711Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6124779Z 	match_year_in_century:
2025-05-24T14:54:58.6124840Z #endif
2025-05-24T14:54:58.6124916Z 	  /* Match year within century.  */
2025-05-24T14:54:58.6124981Z 	  get_number (0, 99, 2);
2025-05-24T14:54:58.6125115Z 	  /* The "Year 2000: The Millennium Rollover" paper suggests that
2025-05-24T14:54:58.6125260Z 	     values in the range 69-99 refer to the twentieth century.  */
2025-05-24T14:54:58.6125737Z 	  tm->tm_year = val >= 69 ? val : val + 100;
2025-05-24T14:54:58.6125882Z 	  /* Indicate that we want to use the century, if specified.  */
2025-05-24T14:54:58.6125952Z 	  want_century = 1;
2025-05-24T14:54:58.6126013Z 	  want_xday = 1;
2025-05-24T14:54:58.6126073Z 	  break;
2025-05-24T14:54:58.6126138Z 	case 'Y':
2025-05-24T14:54:58.6126227Z 	  /* Match year including century number.  */
2025-05-24T14:54:58.6126296Z 	  get_number (0, 9999, 4);
2025-05-24T14:54:58.6126368Z 	  tm->tm_year = val - 1900;
2025-05-24T14:54:58.6126436Z 	  want_century = 0;
2025-05-24T14:54:58.6126497Z 	  want_xday = 1;
2025-05-24T14:54:58.6126551Z 	  break;
2025-05-24T14:54:58.6126608Z 	case 'Z':
2025-05-24T14:54:58.6126687Z 	  /* XXX How to handle this?  */
2025-05-24T14:54:58.6126743Z 	  break;
2025-05-24T14:54:58.6126800Z 	case 'E':
2025-05-24T14:54:58.6126866Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6126927Z 	  switch (*fmt++)
2025-05-24T14:54:58.6127058Z 	    {
2025-05-24T14:54:58.6127116Z 	    case 'c':
2025-05-24T14:54:58.6127231Z 	      /* Match locale's alternate date and time format.  */
2025-05-24T14:54:58.6127298Z 	      if (*decided != raw)
2025-05-24T14:54:58.6127351Z 		{
2025-05-24T14:54:58.6127566Z 		  const char *fmt = _NL_CURRENT (LC_TIME, ERA_D_T_FMT);
2025-05-24T14:54:58.6127571Z 
2025-05-24T14:54:58.6127635Z 		  if (*fmt == '\0')
2025-05-24T14:54:58.6127718Z 		    fmt = _NL_CURRENT (LC_TIME, D_T_FMT);
2025-05-24T14:54:58.6127722Z 
2025-05-24T14:54:58.6127793Z 		  if (!recursive (fmt))
2025-05-24T14:54:58.6127849Z 		    {
2025-05-24T14:54:58.6127918Z 		      if (*decided == loc)
2025-05-24T14:54:58.6127980Z 			return NULL;
2025-05-24T14:54:58.6128042Z 		      else
2025-05-24T14:54:58.6128104Z 			rp = rp_backup;
2025-05-24T14:54:58.6128160Z 		    }
2025-05-24T14:54:58.6128222Z 		  else
2025-05-24T14:54:58.6128277Z 		    {
2025-05-24T14:54:58.6128358Z 		      if (strcmp (fmt, HERE_D_T_FMT))
2025-05-24T14:54:58.6128420Z 			*decided = loc;
2025-05-24T14:54:58.6128488Z 		      want_xday = 1;
2025-05-24T14:54:58.6128547Z 		      break;
2025-05-24T14:54:58.6128602Z 		    }
2025-05-24T14:54:58.6128664Z 		  *decided = raw;
2025-05-24T14:54:58.6128724Z 		}
2025-05-24T14:54:58.6128826Z 	      /* The C locale has no era information, so use the
2025-05-24T14:54:58.6128906Z 		 normal representation.  */
2025-05-24T14:54:58.6128989Z 	      if (!recursive (HERE_D_T_FMT))
2025-05-24T14:54:58.6129053Z 		return NULL;
2025-05-24T14:54:58.6129115Z 	      want_xday = 1;
2025-05-24T14:54:58.6129174Z 	      break;
2025-05-24T14:54:58.6129236Z 	    case 'C':
2025-05-24T14:54:58.6129304Z 	      if (*decided != raw)
2025-05-24T14:54:58.6129360Z 		{
2025-05-24T14:54:58.6129431Z 		  if (era_cnt >= 0)
2025-05-24T14:54:58.6129488Z 		    {
2025-05-24T14:54:58.6129571Z 		      era = _nl_select_era_entry (era_cnt);
2025-05-24T14:54:58.6129653Z 		      if (match_string (era->era_name, rp))
2025-05-24T14:54:58.6129714Z 			{
2025-05-24T14:54:58.6129778Z 			  *decided = loc;
2025-05-24T14:54:58.6129838Z 			  break;
2025-05-24T14:54:58.6129901Z 			}
2025-05-24T14:54:58.6129959Z 		      else
2025-05-24T14:54:58.6130021Z 			return NULL;
2025-05-24T14:54:58.6130076Z 		    }
2025-05-24T14:54:58.6130139Z 		  else
2025-05-24T14:54:58.6130195Z 		    {
2025-05-24T14:54:58.6130279Z 		      num_eras = _NL_CURRENT_WORD (LC_TIME,
2025-05-24T14:54:58.6130358Z 						   _NL_TIME_ERA_NUM_ENTRIES);
2025-05-24T14:54:58.6130516Z 		      for (era_cnt = 0; era_cnt < (int) num_eras;
2025-05-24T14:54:58.6130588Z 			   ++era_cnt, rp = rp_backup)
2025-05-24T14:54:58.6130644Z 			{
2025-05-24T14:54:58.6130731Z 			  era = _nl_select_era_entry (era_cnt);
2025-05-24T14:54:58.6130811Z 			  if (match_string (era->era_name, rp))
2025-05-24T14:54:58.6130868Z 			    {
2025-05-24T14:54:58.6130938Z 			      *decided = loc;
2025-05-24T14:54:58.6130995Z 			      break;
2025-05-24T14:54:58.6131051Z 			    }
2025-05-24T14:54:58.6131106Z 			}
2025-05-24T14:54:58.6131185Z 		      if (era_cnt == (int) num_eras)
2025-05-24T14:54:58.6131243Z 			{
2025-05-24T14:54:58.6131305Z 			  era_cnt = -1;
2025-05-24T14:54:58.6131371Z 			  if (*decided == loc)
2025-05-24T14:54:58.6131441Z 			    return NULL;
2025-05-24T14:54:58.6131495Z 			}
2025-05-24T14:54:58.6131554Z 		      else
2025-05-24T14:54:58.6131619Z 			break;
2025-05-24T14:54:58.6131679Z 		    }
2025-05-24T14:54:58.6131683Z 
2025-05-24T14:54:58.6131746Z 		  *decided = raw;
2025-05-24T14:54:58.6131806Z 		}
2025-05-24T14:54:58.6131912Z 	      /* The C locale has no era information, so use the
2025-05-24T14:54:58.6131989Z 		 normal representation.  */
2025-05-24T14:54:58.6132058Z 	      goto match_century;
2025-05-24T14:54:58.6132120Z  	    case 'y':
2025-05-24T14:54:58.6132187Z 	      if (*decided == raw)
2025-05-24T14:54:58.6132258Z 		goto match_year_in_century;
2025-05-24T14:54:58.6132262Z 
2025-05-24T14:54:58.6132335Z 	      get_number(0, 9999, 4);
2025-05-24T14:54:58.6132401Z 	      tm->tm_year = val;
2025-05-24T14:54:58.6132462Z 	      want_era = 1;
2025-05-24T14:54:58.6132574Z 	      want_xday = 1;
2025-05-24T14:54:58.6132641Z 	      break;
2025-05-24T14:54:58.6132699Z 	    case 'Y':
2025-05-24T14:54:58.6132766Z 	      if (*decided != raw)
2025-05-24T14:54:58.6132821Z 		{
2025-05-24T14:54:58.6132905Z 		  num_eras = _NL_CURRENT_WORD (LC_TIME,
2025-05-24T14:54:58.6133069Z 					       _NL_TIME_ERA_NUM_ENTRIES);
2025-05-24T14:54:58.6133159Z 		  for (era_cnt = 0; era_cnt < (int) num_eras;
2025-05-24T14:54:58.6133238Z 		       ++era_cnt, rp = rp_backup)
2025-05-24T14:54:58.6133296Z 		    {
2025-05-24T14:54:58.6133376Z 		      era = _nl_select_era_entry (era_cnt);
2025-05-24T14:54:58.6133455Z 		      if (recursive (era->era_format))
2025-05-24T14:54:58.6133516Z 			break;
2025-05-24T14:54:58.6133573Z 		    }
2025-05-24T14:54:58.6133645Z 		  if (era_cnt == (int) num_eras)
2025-05-24T14:54:58.6133707Z 		    {
2025-05-24T14:54:58.6133770Z 		      era_cnt = -1;
2025-05-24T14:54:58.6133838Z 		      if (*decided == loc)
2025-05-24T14:54:58.6133898Z 			return NULL;
2025-05-24T14:54:58.6133962Z 		      else
2025-05-24T14:54:58.6134024Z 			rp = rp_backup;
2025-05-24T14:54:58.6134080Z 		    }
2025-05-24T14:54:58.6134142Z 		  else
2025-05-24T14:54:58.6134197Z 		    {
2025-05-24T14:54:58.6134261Z 		      *decided = loc;
2025-05-24T14:54:58.6134324Z 		      era_cnt = -1;
2025-05-24T14:54:58.6134387Z 		      break;
2025-05-24T14:54:58.6134450Z 		    }
2025-05-24T14:54:58.6134454Z 
2025-05-24T14:54:58.6134515Z 		  *decided = raw;
2025-05-24T14:54:58.6134576Z 		}
2025-05-24T14:54:58.6134646Z 	      get_number (0, 9999, 4);
2025-05-24T14:54:58.6134719Z 	      tm->tm_year = val - 1900;
2025-05-24T14:54:58.6134784Z 	      want_century = 0;
2025-05-24T14:54:58.6134852Z 	      want_xday = 1;
2025-05-24T14:54:58.6134910Z 	      break;
2025-05-24T14:54:58.6134970Z 	    case 'x':
2025-05-24T14:54:58.6135043Z 	      if (*decided != raw)
2025-05-24T14:54:58.6135099Z 		{
2025-05-24T14:54:58.6135206Z 		  const char *fmt = _NL_CURRENT (LC_TIME, ERA_D_FMT);
2025-05-24T14:54:58.6135210Z 
2025-05-24T14:54:58.6135274Z 		  if (*fmt == '\0')
2025-05-24T14:54:58.6135538Z 		    fmt = _NL_CURRENT (LC_TIME, D_FMT);
2025-05-24T14:54:58.6135546Z 
2025-05-24T14:54:58.6135641Z 		  if (!recursive (fmt))
2025-05-24T14:54:58.6135699Z 		    {
2025-05-24T14:54:58.6135773Z 		      if (*decided == loc)
2025-05-24T14:54:58.6135833Z 			return NULL;
2025-05-24T14:54:58.6135894Z 		      else
2025-05-24T14:54:58.6135958Z 			rp = rp_backup;
2025-05-24T14:54:58.6136018Z 		    }
2025-05-24T14:54:58.6136152Z 		  else
2025-05-24T14:54:58.6136208Z 		    {
2025-05-24T14:54:58.6136289Z 		      if (strcmp (fmt, HERE_D_FMT))
2025-05-24T14:54:58.6136352Z 			*decided = loc;
2025-05-24T14:54:58.6136409Z 		      break;
2025-05-24T14:54:58.6136464Z 		    }
2025-05-24T14:54:58.6136532Z 		  *decided = raw;
2025-05-24T14:54:58.6136588Z 		}
2025-05-24T14:54:58.6136661Z 	      if (!recursive (HERE_D_FMT))
2025-05-24T14:54:58.6136725Z 		return NULL;
2025-05-24T14:54:58.6136784Z 	      break;
2025-05-24T14:54:58.6136842Z 	    case 'X':
2025-05-24T14:54:58.6136910Z 	      if (*decided != raw)
2025-05-24T14:54:58.6136969Z 		{
2025-05-24T14:54:58.6137074Z 		  const char *fmt = _NL_CURRENT (LC_TIME, ERA_T_FMT);
2025-05-24T14:54:58.6137078Z 
2025-05-24T14:54:58.6137140Z 		  if (*fmt == '\0')
2025-05-24T14:54:58.6137220Z 		    fmt = _NL_CURRENT (LC_TIME, T_FMT);
2025-05-24T14:54:58.6137224Z 
2025-05-24T14:54:58.6137296Z 		  if (!recursive (fmt))
2025-05-24T14:54:58.6137353Z 		    {
2025-05-24T14:54:58.6137422Z 		      if (*decided == loc)
2025-05-24T14:54:58.6137489Z 			return NULL;
2025-05-24T14:54:58.6137545Z 		      else
2025-05-24T14:54:58.6137607Z 			rp = rp_backup;
2025-05-24T14:54:58.6137668Z 		    }
2025-05-24T14:54:58.6137725Z 		  else
2025-05-24T14:54:58.6137782Z 		    {
2025-05-24T14:54:58.6137855Z 		      if (strcmp (fmt, HERE_T_FMT))
2025-05-24T14:54:58.6137921Z 			*decided = loc;
2025-05-24T14:54:58.6137978Z 		      break;
2025-05-24T14:54:58.6138034Z 		    }
2025-05-24T14:54:58.6138103Z 		  *decided = raw;
2025-05-24T14:54:58.6138157Z 		}
2025-05-24T14:54:58.6138294Z 	      if (!recursive (HERE_T_FMT))
2025-05-24T14:54:58.6138355Z 		return NULL;
2025-05-24T14:54:58.6138416Z 	      break;
2025-05-24T14:54:58.6138474Z 	    default:
2025-05-24T14:54:58.6138540Z 	      return NULL;
2025-05-24T14:54:58.6138596Z 	    }
2025-05-24T14:54:58.6138657Z 	  break;
2025-05-24T14:54:58.6138834Z #else
2025-05-24T14:54:58.6138958Z 	  /* We have no information about the era format.  Just use
2025-05-24T14:54:58.6139038Z 	     the normal format.  */
2025-05-24T14:54:58.6139145Z 	  if (*fmt != 'c' && *fmt != 'C' && *fmt != 'y' && *fmt != 'Y'
2025-05-24T14:54:58.6139215Z 	      && *fmt != 'x' && *fmt != 'X')
2025-05-24T14:54:58.6139292Z 	    /* This is an illegal format.  */
2025-05-24T14:54:58.6139358Z 	    return NULL;
2025-05-24T14:54:58.6139362Z 
2025-05-24T14:54:58.6139424Z 	  goto start_over;
2025-05-24T14:54:58.6139481Z #endif
2025-05-24T14:54:58.6139544Z 	case 'O':
2025-05-24T14:54:58.6139605Z 	  switch (*fmt++)
2025-05-24T14:54:58.6139660Z 	    {
2025-05-24T14:54:58.6139720Z 	    case 'd':
2025-05-24T14:54:58.6139784Z 	    case 'e':
2025-05-24T14:54:58.6139911Z 	      /* Match day of month using alternate numeric symbols.  */
2025-05-24T14:54:58.6139982Z 	      get_alt_number (1, 31, 2);
2025-05-24T14:54:58.6140055Z 	      tm->tm_mday = val;
2025-05-24T14:54:58.6140119Z 	      have_mday = 1;
2025-05-24T14:54:58.6140184Z 	      want_xday = 1;
2025-05-24T14:54:58.6140241Z 	      break;
2025-05-24T14:54:58.6140307Z 	    case 'H':
2025-05-24T14:54:58.6140420Z 	      /* Match hour in 24-hour clock using alternate numeric
2025-05-24T14:54:58.6140481Z 		 symbols.  */
2025-05-24T14:54:58.6140557Z 	      get_alt_number (0, 23, 2);
2025-05-24T14:54:58.6140623Z 	      tm->tm_hour = val;
2025-05-24T14:54:58.6140683Z 	      have_I = 0;
2025-05-24T14:54:58.6140739Z 	      break;
2025-05-24T14:54:58.6140802Z 	    case 'I':
2025-05-24T14:54:58.6140909Z 	      /* Match hour in 12-hour clock using alternate numeric
2025-05-24T14:54:58.6140970Z 		 symbols.  */
2025-05-24T14:54:58.6141045Z 	      get_alt_number (1, 12, 2);
2025-05-24T14:54:58.6141116Z 	      tm->tm_hour = val - 1;
2025-05-24T14:54:58.6141176Z 	      have_I = 1;
2025-05-24T14:54:58.6141231Z 	      break;
2025-05-24T14:54:58.6141293Z 	    case 'm':
2025-05-24T14:54:58.6141398Z 	      /* Match month using alternate numeric symbols.  */
2025-05-24T14:54:58.6141469Z 	      get_alt_number (1, 12, 2);
2025-05-24T14:54:58.6141542Z 	      tm->tm_mon = val - 1;
2025-05-24T14:54:58.6141655Z 	      have_mon = 1;
2025-05-24T14:54:58.6141717Z 	      want_xday = 1;
2025-05-24T14:54:58.6141773Z 	      break;
2025-05-24T14:54:58.6141834Z 	    case 'M':
2025-05-24T14:54:58.6141942Z 	      /* Match minutes using alternate numeric symbols.  */
2025-05-24T14:54:58.6142010Z 	      get_alt_number (0, 59, 2);
2025-05-24T14:54:58.6142079Z 	      tm->tm_min = val;
2025-05-24T14:54:58.6142135Z 	      break;
2025-05-24T14:54:58.6142194Z 	    case 'S':
2025-05-24T14:54:58.6142303Z 	      /* Match seconds using alternate numeric symbols.  */
2025-05-24T14:54:58.6142378Z 	      get_alt_number (0, 61, 2);
2025-05-24T14:54:58.6142445Z 	      tm->tm_sec = val;
2025-05-24T14:54:58.6142502Z 	      break;
2025-05-24T14:54:58.6142563Z 	    case 'U':
2025-05-24T14:54:58.6142621Z 	    case 'V':
2025-05-24T14:54:58.6142679Z 	    case 'W':
2025-05-24T14:54:58.6142748Z 	      get_alt_number (0, 53, 2);
2025-05-24T14:54:58.6142861Z 	      /* XXX This cannot determine any field in TM without
2025-05-24T14:54:58.6142936Z 		 further information.  */
2025-05-24T14:54:58.6142996Z 	      break;
2025-05-24T14:54:58.6143059Z 	    case 'w':
2025-05-24T14:54:58.6143197Z 	      /* Match number of weekday using alternate numeric symbols.  */
2025-05-24T14:54:58.6143269Z 	      get_alt_number (0, 6, 1);
2025-05-24T14:54:58.6143337Z 	      tm->tm_wday = val;
2025-05-24T14:54:58.6143404Z 	      have_wday = 1;
2025-05-24T14:54:58.6143460Z 	      break;
2025-05-24T14:54:58.6143518Z 	    case 'y':
2025-05-24T14:54:58.6143663Z 	      /* Match year within century using alternate numeric symbols.  */
2025-05-24T14:54:58.6143781Z 	      get_alt_number (0, 99, 2);
2025-05-24T14:54:58.6143869Z 	      tm->tm_year = val >= 69 ? val : val + 100;
2025-05-24T14:54:58.6143932Z 	      want_xday = 1;
2025-05-24T14:54:58.6143994Z 	      break;
2025-05-24T14:54:58.6144052Z 	    default:
2025-05-24T14:54:58.6144115Z 	      return NULL;
2025-05-24T14:54:58.6144248Z 	    }
2025-05-24T14:54:58.6144310Z 	  break;
2025-05-24T14:54:58.6144367Z 	default:
2025-05-24T14:54:58.6144430Z 	  return NULL;
2025-05-24T14:54:58.6144490Z 	}
2025-05-24T14:54:58.6144548Z     }
2025-05-24T14:54:58.6144551Z 
2025-05-24T14:54:58.6144617Z   if (have_I && is_pm)
2025-05-24T14:54:58.6144684Z     tm->tm_hour += 12;
2025-05-24T14:54:58.6144688Z 
2025-05-24T14:54:58.6144752Z   if (century != -1)
2025-05-24T14:54:58.6144809Z     {
2025-05-24T14:54:58.6144877Z       if (want_century)
2025-05-24T14:54:58.6144984Z 	tm->tm_year = tm->tm_year % 100 + (century - 19) * 100;
2025-05-24T14:54:58.6145042Z       else
2025-05-24T14:54:58.6145182Z 	/* Only the century, but not the year.  Strange, but so be it.  */
2025-05-24T14:54:58.6145264Z 	tm->tm_year = (century - 19) * 100;
2025-05-24T14:54:58.6145320Z     }
2025-05-24T14:54:58.6145323Z 
2025-05-24T14:54:58.6145513Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6145585Z   if (era_cnt != -1)
2025-05-24T14:54:58.6145640Z     {
2025-05-24T14:54:58.6145724Z       era = _nl_select_era_entry(era_cnt);
2025-05-24T14:54:58.6145785Z       if (want_era)
2025-05-24T14:54:58.6145872Z 	tm->tm_year = (era->start_date[0]
2025-05-24T14:54:58.6145949Z 		       + ((tm->tm_year - era->offset)
2025-05-24T14:54:58.6146024Z 			  * era->absolute_direction));
2025-05-24T14:54:58.6146086Z       else
2025-05-24T14:54:58.6146163Z 	/* Era start year assumed.  */
2025-05-24T14:54:58.6146240Z 	tm->tm_year = era->start_date[0];
2025-05-24T14:54:58.6146295Z     }
2025-05-24T14:54:58.6146356Z   else
2025-05-24T14:54:58.6146412Z #endif
2025-05-24T14:54:58.6146472Z     if (want_era)
2025-05-24T14:54:58.6146534Z       return NULL;
2025-05-24T14:54:58.6146546Z 
2025-05-24T14:54:58.6146617Z   if (want_xday && !have_wday)
2025-05-24T14:54:58.6146672Z     {
2025-05-24T14:54:58.6146758Z       if ( !(have_mon && have_mday) && have_yday)
2025-05-24T14:54:58.6146817Z 	{
2025-05-24T14:54:58.6146930Z 	  /* We don't have tm_mon and/or tm_mday, compute them.  */
2025-05-24T14:54:58.6146995Z 	  int t_mon = 0;
2025-05-24T14:54:58.6147144Z 	  while (__mon_yday[__isleap(1900 + tm->tm_year)][t_mon] <= tm->tm_yday)
2025-05-24T14:54:58.6147275Z 	      t_mon++;
2025-05-24T14:54:58.6147336Z 	  if (!have_mon)
2025-05-24T14:54:58.6147406Z 	      tm->tm_mon = t_mon - 1;
2025-05-24T14:54:58.6147471Z 	  if (!have_mday)
2025-05-24T14:54:58.6147532Z 	      tm->tm_mday =
2025-05-24T14:54:58.6147590Z 		(tm->tm_yday
2025-05-24T14:54:58.6147710Z 		 - __mon_yday[__isleap(1900 + tm->tm_year)][t_mon - 1] + 1);
2025-05-24T14:54:58.6147766Z 	}
2025-05-24T14:54:58.6147833Z       day_of_the_week (tm);
2025-05-24T14:54:58.6147888Z     }
2025-05-24T14:54:58.6147962Z   if (want_xday && !have_yday)
2025-05-24T14:54:58.6148033Z     day_of_the_year (tm);
2025-05-24T14:54:58.6148037Z 
2025-05-24T14:54:58.6148117Z   return discard_const_p(char, rp);
2025-05-24T14:54:58.6148177Z }
2025-05-24T14:54:58.6148181Z 
2025-05-24T14:54:58.6148184Z 
2025-05-24T14:54:58.6148348Z char *rep_strptime(const char *buf, const char *format, struct tm *tm)
2025-05-24T14:54:58.6148403Z {
2025-05-24T14:54:58.6148483Z   enum locale_status decided;
2025-05-24T14:54:58.6148489Z 
2025-05-24T14:54:58.6148552Z #ifdef _NL_CURRENT
2025-05-24T14:54:58.6148614Z   decided = not;
2025-05-24T14:54:58.6148670Z #else
2025-05-24T14:54:58.6148738Z   decided = raw;
2025-05-24T14:54:58.6148795Z #endif
2025-05-24T14:54:58.6148925Z   return strptime_internal (buf, format, tm, &decided, -1);
2025-05-24T14:54:58.6148985Z }
2025-05-24T14:54:58.6149047Z -------------------
2025-05-24T14:54:58.6149126Z Content of lib/replace/timegm.c:
2025-05-24T14:54:58.6149182Z /*
2025-05-24T14:54:58.6149521Z  * Copyright (c) 1997 Kungliga Tekniska H√∂gskolan
2025-05-24T14:54:58.6149710Z  * (Royal Institute of Technology, Stockholm, Sweden). 
2025-05-24T14:54:58.6149781Z  * All rights reserved. 
2025-05-24T14:54:58.6149841Z  *
2025-05-24T14:54:58.6149997Z  * Redistribution and use in source and binary forms, with or without 
2025-05-24T14:54:58.6150262Z  * modification, are permitted provided that the following conditions 
2025-05-24T14:54:58.6150325Z  * are met: 
2025-05-24T14:54:58.6150386Z  *
2025-05-24T14:54:58.6150552Z  * 1. Redistributions of source code must retain the above copyright 
2025-05-24T14:54:58.6150692Z  *    notice, this list of conditions and the following disclaimer. 
2025-05-24T14:54:58.6150753Z  *
2025-05-24T14:54:58.6150916Z  * 2. Redistributions in binary form must reproduce the above copyright 
2025-05-24T14:54:58.6151069Z  *    notice, this list of conditions and the following disclaimer in the 
2025-05-24T14:54:58.6151239Z  *    documentation and/or other materials provided with the distribution. 
2025-05-24T14:54:58.6151298Z  *
2025-05-24T14:54:58.6151450Z  * 3. Neither the name of the Institute nor the names of its contributors 
2025-05-24T14:54:58.6151605Z  *    may be used to endorse or promote products derived from this software 
2025-05-24T14:54:58.6151709Z  *    without specific prior written permission. 
2025-05-24T14:54:58.6151766Z  *
2025-05-24T14:54:58.6151939Z  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
2025-05-24T14:54:58.6152104Z  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
2025-05-24T14:54:58.6152292Z  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
2025-05-24T14:54:58.6152456Z  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
2025-05-24T14:54:58.6152627Z  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
2025-05-24T14:54:58.6152800Z  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
2025-05-24T14:54:58.6152948Z  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
2025-05-24T14:54:58.6153116Z  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
2025-05-24T14:54:58.6153287Z  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
2025-05-24T14:54:58.6153437Z  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
2025-05-24T14:54:58.6153499Z  * SUCH DAMAGE. 
2025-05-24T14:54:58.6153560Z  */
2025-05-24T14:54:58.6153675Z 
2025-05-24T14:54:58.6153733Z /*
2025-05-24T14:54:58.6153817Z   adapted for Samba4 by Andrew Tridgell
2025-05-24T14:54:58.6153872Z */
2025-05-24T14:54:58.6153880Z 
2025-05-24T14:54:58.6153947Z #include "replace.h"
2025-05-24T14:54:58.6154016Z #include "system/time.h"
2025-05-24T14:54:58.6154020Z 
2025-05-24T14:54:58.6154095Z static int is_leap(unsigned y)
2025-05-24T14:54:58.6154157Z {
2025-05-24T14:54:58.6154218Z 	y += 1900;
2025-05-24T14:54:58.6154322Z 	return (y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0);
2025-05-24T14:54:58.6154383Z }
2025-05-24T14:54:58.6154389Z 
2025-05-24T14:54:58.6154469Z time_t rep_timegm(struct tm *tm)
2025-05-24T14:54:58.6154524Z {
2025-05-24T14:54:58.6154605Z 	static const unsigned ndays[2][12] ={
2025-05-24T14:54:58.6154690Z 		{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
2025-05-24T14:54:58.6154770Z 		{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};
2025-05-24T14:54:58.6154836Z 	time_t res = 0;
2025-05-24T14:54:58.6154901Z 	unsigned i;
2025-05-24T14:54:58.6154907Z 
2025-05-24T14:54:58.6154974Z 	if (tm->tm_mon > 12 ||
2025-05-24T14:54:58.6155038Z 	    tm->tm_mon < 0 ||
2025-05-24T14:54:58.6155102Z 	    tm->tm_mday > 31 ||
2025-05-24T14:54:58.6155172Z 	    tm->tm_min > 60 ||
2025-05-24T14:54:58.6155237Z 	    tm->tm_sec > 60 ||
2025-05-24T14:54:58.6155301Z 	    tm->tm_hour > 24) {
2025-05-24T14:54:58.6155577Z 		/* invalid tm structure */
2025-05-24T14:54:58.6155680Z 		return 0;
2025-05-24T14:54:58.6155737Z 	}
2025-05-24T14:54:58.6155793Z 	
2025-05-24T14:54:58.6155874Z 	for (i = 70; i < tm->tm_year; ++i)
2025-05-24T14:54:58.6156029Z 		res += is_leap(i) ? 366 : 365;
2025-05-24T14:54:58.6156084Z 	
2025-05-24T14:54:58.6156161Z 	for (i = 0; i < tm->tm_mon; ++i)
2025-05-24T14:54:58.6156243Z 		res += ndays[is_leap(tm->tm_year)][i];
2025-05-24T14:54:58.6156312Z 	res += tm->tm_mday - 1;
2025-05-24T14:54:58.6156369Z 	res *= 24;
2025-05-24T14:54:58.6156561Z 	res += tm->tm_hour;
2025-05-24T14:54:58.6156623Z 	res *= 60;
2025-05-24T14:54:58.6156685Z 	res += tm->tm_min;
2025-05-24T14:54:58.6156750Z 	res *= 60;
2025-05-24T14:54:58.6156811Z 	res += tm->tm_sec;
2025-05-24T14:54:58.6156872Z 	return res;
2025-05-24T14:54:58.6156926Z }
2025-05-24T14:54:58.6156991Z -------------------
2025-05-24T14:54:58.6157069Z Content of lib/replace/xattr.c:
2025-05-24T14:54:58.6157124Z /*
2025-05-24T14:54:58.6157201Z    Unix SMB/CIFS implementation.
2025-05-24T14:54:58.6157309Z    replacement routines for xattr implementations
2025-05-24T14:54:58.6157396Z    Copyright (C) Jeremy Allison  1998-2005
2025-05-24T14:54:58.6157477Z    Copyright (C) Timur Bakeyev        2005
2025-05-24T14:54:58.6157563Z    Copyright (C) Bjoern Jacke    2006-2007
2025-05-24T14:54:58.6157642Z    Copyright (C) Herb Lewis           2003
2025-05-24T14:54:58.6157720Z    Copyright (C) Andrew Bartlett      2012
2025-05-24T14:54:58.6157724Z 
2025-05-24T14:54:58.6157858Z      ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.6157992Z      ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.6158059Z      ** under the LGPL
2025-05-24T14:54:58.6158063Z 
2025-05-24T14:54:58.6158199Z    This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.6158336Z    modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.6158472Z    License as published by the Free Software Foundation; either
2025-05-24T14:54:58.6158607Z    version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.6158611Z 
2025-05-24T14:54:58.6158754Z    This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.6158896Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.6159052Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.6159159Z    Lesser General Public License for more details.
2025-05-24T14:54:58.6159163Z 
2025-05-24T14:54:58.6159309Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.6159495Z    License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.6159621Z */
2025-05-24T14:54:58.6159624Z 
2025-05-24T14:54:58.6159702Z #define UID_WRAPPER_NOT_REPLACE
2025-05-24T14:54:58.6159769Z #include "replace.h"
2025-05-24T14:54:58.6159842Z #include "system/filesys.h"
2025-05-24T14:54:58.6159915Z #include "system/dir.h"
2025-05-24T14:54:58.6159919Z 
2025-05-24T14:54:58.6160031Z /******** Solaris EA helper function prototypes ********/
2025-05-24T14:54:58.6160095Z #ifdef HAVE_ATTROPEN
2025-05-24T14:54:58.6160223Z #define SOLARIS_ATTRMODE S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP
2025-05-24T14:54:58.6160398Z static int solaris_write_xattr(int attrfd, const char *value, size_t size);
2025-05-24T14:54:58.6160558Z static ssize_t solaris_read_xattr(int attrfd, void *value, size_t size);
2025-05-24T14:54:58.6160728Z static ssize_t solaris_list_xattr(int attrdirfd, char *list, size_t size);
2025-05-24T14:54:58.6160865Z static int solaris_unlinkat(int attrdirfd, const char *name);
2025-05-24T14:54:58.6161092Z static int solaris_attropen(const char *path, const char *attrpath, int oflag, mode_t mode);
2025-05-24T14:54:58.6161281Z static int solaris_openat(int fildes, const char *path, int oflag, mode_t mode);
2025-05-24T14:54:58.6161339Z #endif
2025-05-24T14:54:58.6161342Z 
2025-05-24T14:54:58.6161422Z /**************************************************************************
2025-05-24T14:54:58.6161587Z  Wrappers for extended attribute calls. Based on the Linux package with
2025-05-24T14:54:58.6161754Z  support for IRIX and (Net|Free)BSD also. Expand as other systems have them.
2025-05-24T14:54:58.6161882Z ****************************************************************************/
2025-05-24T14:54:58.6161886Z 
2025-05-24T14:54:58.6162111Z ssize_t rep_getxattr (const char *path, const char *name, void *value, size_t size)
2025-05-24T14:54:58.6162172Z {
2025-05-24T14:54:58.6162322Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6162409Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6162503Z 	return getxattr(path, name, value, size);
2025-05-24T14:54:58.6162561Z #else
2025-05-24T14:54:58.6162564Z 
2025-05-24T14:54:58.6162673Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6162736Z #undef getxattr
2025-05-24T14:54:58.6162804Z 	int options = 0;
2025-05-24T14:54:58.6162920Z 	return getxattr(path, name, value, size, 0, options);
2025-05-24T14:54:58.6162975Z #endif
2025-05-24T14:54:58.6163053Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6163136Z 	return getea(path, name, value, size);
2025-05-24T14:54:58.6163213Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6163278Z 	ssize_t retval;
2025-05-24T14:54:58.6163352Z 	int attrnamespace;
2025-05-24T14:54:58.6163418Z 	const char *attrname;
2025-05-24T14:54:58.6163422Z 
2025-05-24T14:54:58.6163502Z 	if (strncmp(name, "system.", 7) == 0) {
2025-05-24T14:54:58.6163599Z 		attrnamespace = EXTATTR_NAMESPACE_SYSTEM;
2025-05-24T14:54:58.6163668Z 		attrname = name + 7;
2025-05-24T14:54:58.6163756Z 	} else if (strncmp(name, "user.", 5) == 0) {
2025-05-24T14:54:58.6163850Z 		attrnamespace = EXTATTR_NAMESPACE_USER;
2025-05-24T14:54:58.6163916Z 		attrname = name + 5;
2025-05-24T14:54:58.6163973Z 	} else {
2025-05-24T14:54:58.6164037Z 		errno = EINVAL;
2025-05-24T14:54:58.6164102Z 		return -1;
2025-05-24T14:54:58.6164157Z 	}
2025-05-24T14:54:58.6164160Z 
2025-05-24T14:54:58.6164215Z 	/*
2025-05-24T14:54:58.6164366Z 	 * The BSD implementation has a nasty habit of silently truncating
2025-05-24T14:54:58.6164514Z 	 * the returned value to the size of the buffer, so we have to check
2025-05-24T14:54:58.6164646Z 	 * that the buffer is large enough to fit the returned value.
2025-05-24T14:54:58.6164703Z 	 */
2025-05-24T14:54:58.6164877Z 	if((retval=extattr_get_file(path, attrnamespace, attrname, NULL, 0)) >= 0) {
2025-05-24T14:54:58.6164940Z 		if (size == 0) {
2025-05-24T14:54:58.6165002Z 			return retval;
2025-05-24T14:54:58.6165081Z 		} else if (retval > size) {
2025-05-24T14:54:58.6165142Z 			errno = ERANGE;
2025-05-24T14:54:58.6165205Z 			return -1;
2025-05-24T14:54:58.6165310Z 		}
2025-05-24T14:54:58.6165610Z 		if((retval=extattr_get_file(path, attrnamespace, attrname, value, size)) >= 0)
2025-05-24T14:54:58.6165674Z 			return retval;
2025-05-24T14:54:58.6165729Z 	}
2025-05-24T14:54:58.6165732Z 
2025-05-24T14:54:58.6165798Z 	return -1;
2025-05-24T14:54:58.6165876Z #elif defined(HAVE_XATTR_ATTR)
2025-05-24T14:54:58.6165944Z 	int retval, flags = 0;
2025-05-24T14:54:58.6166016Z 	int valuelength = (int)size;
2025-05-24T14:54:58.6166102Z 	char *attrname = strchr(name,'.') + 1;
2025-05-24T14:54:58.6166106Z 
2025-05-24T14:54:58.6166220Z 	if (strncmp(name, "system", 6) == 0) flags |= ATTR_ROOT;
2025-05-24T14:54:58.6166224Z 
2025-05-24T14:54:58.6166379Z 	retval = attr_get(path, attrname, (char *)value, &valuelength, flags);
2025-05-24T14:54:58.6166484Z 	if (size == 0 && retval == -1 && errno == E2BIG) {
2025-05-24T14:54:58.6166556Z 		return valuelength;
2025-05-24T14:54:58.6166612Z 	}
2025-05-24T14:54:58.6166615Z 
2025-05-24T14:54:58.6166704Z 	return retval ? retval : valuelength;
2025-05-24T14:54:58.6166780Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6166846Z 	ssize_t ret = -1;
2025-05-24T14:54:58.6166962Z 	int attrfd = solaris_attropen(path, name, O_RDONLY, 0);
2025-05-24T14:54:58.6167030Z 	if (attrfd >= 0) {
2025-05-24T14:54:58.6167127Z 		ret = solaris_read_xattr(attrfd, value, size);
2025-05-24T14:54:58.6167188Z 		close(attrfd);
2025-05-24T14:54:58.6167248Z 	}
2025-05-24T14:54:58.6167308Z 	return ret;
2025-05-24T14:54:58.6167365Z #else
2025-05-24T14:54:58.6167425Z 	errno = ENOSYS;
2025-05-24T14:54:58.6167489Z 	return -1;
2025-05-24T14:54:58.6167619Z #endif
2025-05-24T14:54:58.6167674Z }
2025-05-24T14:54:58.6167678Z 
2025-05-24T14:54:58.6167863Z ssize_t rep_fgetxattr (int filedes, const char *name, void *value, size_t size)
2025-05-24T14:54:58.6167918Z {
2025-05-24T14:54:58.6167992Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6168174Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6168283Z 	return fgetxattr(filedes, name, value, size);
2025-05-24T14:54:58.6168342Z #else
2025-05-24T14:54:58.6168346Z 
2025-05-24T14:54:58.6168454Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6168522Z #undef fgetxattr
2025-05-24T14:54:58.6168587Z 	int options = 0;
2025-05-24T14:54:58.6168713Z 	return fgetxattr(filedes, name, value, size, 0, options);
2025-05-24T14:54:58.6168777Z #endif
2025-05-24T14:54:58.6168849Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6168937Z 	return fgetea(filedes, name, value, size);
2025-05-24T14:54:58.6169014Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6169084Z 	ssize_t retval;
2025-05-24T14:54:58.6169152Z 	int attrnamespace;
2025-05-24T14:54:58.6169219Z 	const char *attrname;
2025-05-24T14:54:58.6169222Z 
2025-05-24T14:54:58.6169307Z 	if (strncmp(name, "system.", 7) == 0) {
2025-05-24T14:54:58.6169394Z 		attrnamespace = EXTATTR_NAMESPACE_SYSTEM;
2025-05-24T14:54:58.6169466Z 		attrname = name + 7;
2025-05-24T14:54:58.6169556Z 	} else if (strncmp(name, "user.", 5) == 0) {
2025-05-24T14:54:58.6169648Z 		attrnamespace = EXTATTR_NAMESPACE_USER;
2025-05-24T14:54:58.6169714Z 		attrname = name + 5;
2025-05-24T14:54:58.6169772Z 	} else {
2025-05-24T14:54:58.6169838Z 		errno = EINVAL;
2025-05-24T14:54:58.6169899Z 		return -1;
2025-05-24T14:54:58.6169955Z 	}
2025-05-24T14:54:58.6169959Z 
2025-05-24T14:54:58.6170127Z 	if((retval=extattr_get_fd(filedes, attrnamespace, attrname, NULL, 0)) >= 0) {
2025-05-24T14:54:58.6170197Z 		if (size == 0) {
2025-05-24T14:54:58.6170258Z 			return retval;
2025-05-24T14:54:58.6170328Z 		} else if (retval > size) {
2025-05-24T14:54:58.6170396Z 			errno = ERANGE;
2025-05-24T14:54:58.6170456Z 			return -1;
2025-05-24T14:54:58.6170511Z 		}
2025-05-24T14:54:58.6170687Z 		if((retval=extattr_get_fd(filedes, attrnamespace, attrname, value, size)) >= 0)
2025-05-24T14:54:58.6170755Z 			return retval;
2025-05-24T14:54:58.6170810Z 	}
2025-05-24T14:54:58.6170813Z 
2025-05-24T14:54:58.6170881Z 	return -1;
2025-05-24T14:54:58.6170961Z #elif defined(HAVE_XATTR_ATTR)
2025-05-24T14:54:58.6171099Z 	int retval, flags = 0;
2025-05-24T14:54:58.6171173Z 	int valuelength = (int)size;
2025-05-24T14:54:58.6171252Z 	char *attrname = strchr(name,'.') + 1;
2025-05-24T14:54:58.6171261Z 
2025-05-24T14:54:58.6171370Z 	if (strncmp(name, "system", 6) == 0) flags |= ATTR_ROOT;
2025-05-24T14:54:58.6171374Z 
2025-05-24T14:54:58.6171537Z 	retval = attr_getf(filedes, attrname, (char *)value, &valuelength, flags);
2025-05-24T14:54:58.6171630Z 	if (size == 0 && retval == -1 && errno == E2BIG) {
2025-05-24T14:54:58.6171703Z 		return valuelength;
2025-05-24T14:54:58.6171757Z 	}
2025-05-24T14:54:58.6171842Z 	return retval ? retval : valuelength;
2025-05-24T14:54:58.6171920Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6171984Z 	ssize_t ret = -1;
2025-05-24T14:54:58.6172124Z 	int attrfd = solaris_openat(filedes, name, O_RDONLY|O_XATTR, 0);
2025-05-24T14:54:58.6172188Z 	if (attrfd >= 0) {
2025-05-24T14:54:58.6172291Z 		ret = solaris_read_xattr(attrfd, value, size);
2025-05-24T14:54:58.6172353Z 		close(attrfd);
2025-05-24T14:54:58.6172410Z 	}
2025-05-24T14:54:58.6172475Z 	return ret;
2025-05-24T14:54:58.6172531Z #else
2025-05-24T14:54:58.6172592Z 	errno = ENOSYS;
2025-05-24T14:54:58.6172652Z 	return -1;
2025-05-24T14:54:58.6172712Z #endif
2025-05-24T14:54:58.6172767Z }
2025-05-24T14:54:58.6172770Z 
2025-05-24T14:54:58.6172846Z #if defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6172850Z 
2025-05-24T14:54:58.6172951Z #define EXTATTR_PREFIX(s)	(s), (sizeof((s))-1)
2025-05-24T14:54:58.6172955Z 
2025-05-24T14:54:58.6173017Z static struct {
2025-05-24T14:54:58.6173080Z         int space;
2025-05-24T14:54:58.6173198Z 	const char *name;
2025-05-24T14:54:58.6173258Z 	size_t len;
2025-05-24T14:54:58.6173315Z }
2025-05-24T14:54:58.6173379Z extattr[] = {
2025-05-24T14:54:58.6173505Z 	{ EXTATTR_NAMESPACE_SYSTEM, EXTATTR_PREFIX("system.") },
2025-05-24T14:54:58.6173618Z         { EXTATTR_NAMESPACE_USER, EXTATTR_PREFIX("user.") },
2025-05-24T14:54:58.6173745Z };
2025-05-24T14:54:58.6173749Z 
2025-05-24T14:54:58.6173818Z typedef union {
2025-05-24T14:54:58.6173886Z 	const char *path;
2025-05-24T14:54:58.6173947Z 	int filedes;
2025-05-24T14:54:58.6174007Z } extattr_arg;
2025-05-24T14:54:58.6174010Z 
2025-05-24T14:54:58.6174193Z static ssize_t bsd_attr_list (int type, extattr_arg arg, char *list, size_t size)
2025-05-24T14:54:58.6174249Z {
2025-05-24T14:54:58.6174327Z 	ssize_t list_size, total_size = 0;
2025-05-24T14:54:58.6174391Z 	int i, len;
2025-05-24T14:54:58.6174450Z 	size_t t;
2025-05-24T14:54:58.6174508Z 	char *buf;
2025-05-24T14:54:58.6174602Z 	/* Iterate through extattr(2) namespaces */
2025-05-24T14:54:58.6174697Z 	for(t = 0; t < ARRAY_SIZE(extattr); t++) {
2025-05-24T14:54:58.6174800Z 		if (t != EXTATTR_NAMESPACE_USER && geteuid() != 0) {
2025-05-24T14:54:58.6174959Z 			/* ignore all but user namespace when we are not root, see bug 10247 */
2025-05-24T14:54:58.6175023Z 			continue;
2025-05-24T14:54:58.6175079Z 		}
2025-05-24T14:54:58.6175147Z 		switch(type) {
2025-05-24T14:54:58.6175205Z 			case 0:
2025-05-24T14:54:58.6175548Z 				list_size = extattr_list_file(arg.path, extattr[t].space, list, size);
2025-05-24T14:54:58.6175631Z 				break;
2025-05-24T14:54:58.6175690Z 			case 1:
2025-05-24T14:54:58.6175846Z 				list_size = extattr_list_link(arg.path, extattr[t].space, list, size);
2025-05-24T14:54:58.6175903Z 				break;
2025-05-24T14:54:58.6175960Z 			case 2:
2025-05-24T14:54:58.6176112Z 				list_size = extattr_list_fd(arg.filedes, extattr[t].space, list, size);
2025-05-24T14:54:58.6176174Z 				break;
2025-05-24T14:54:58.6176232Z 			default:
2025-05-24T14:54:58.6176295Z 				errno = ENOSYS;
2025-05-24T14:54:58.6176364Z 				return -1;
2025-05-24T14:54:58.6176420Z 		}
2025-05-24T14:54:58.6176571Z 		/* Some error happened. Errno should be set by the previous call */
2025-05-24T14:54:58.6176634Z 		if(list_size < 0)
2025-05-24T14:54:58.6176700Z 			return -1;
2025-05-24T14:54:58.6176768Z 		/* No attributes */
2025-05-24T14:54:58.6176837Z 		if(list_size == 0)
2025-05-24T14:54:58.6176899Z 			continue;
2025-05-24T14:54:58.6177016Z 		/* XXX: Call with an empty buffer may be used to calculate
2025-05-24T14:54:58.6177218Z 		   necessary buffer size. Unfortunately, we can't say, how
2025-05-24T14:54:58.6177336Z 		   many attributes were returned, so here is the potential
2025-05-24T14:54:58.6177417Z 		   problem with the emulation.
2025-05-24T14:54:58.6177470Z 		*/
2025-05-24T14:54:58.6177533Z 		if(list == NULL) {
2025-05-24T14:54:58.6177643Z 			/* Take the worse case of one char attribute names -
2025-05-24T14:54:58.6177738Z 			   two bytes per name plus one more for sanity.
2025-05-24T14:54:58.6177795Z 			*/
2025-05-24T14:54:58.6177919Z 			total_size += list_size + (list_size/2 + 1)*extattr[t].len;
2025-05-24T14:54:58.6177983Z 			continue;
2025-05-24T14:54:58.6178038Z 		}
2025-05-24T14:54:58.6178150Z 		/* Count necessary offset to fit namespace prefixes */
2025-05-24T14:54:58.6178213Z 		len = 0;
2025-05-24T14:54:58.6178303Z 		for(i = 0; i < list_size; i += list[i] + 1)
2025-05-24T14:54:58.6178371Z 			len += extattr[t].len;
2025-05-24T14:54:58.6178375Z 
2025-05-24T14:54:58.6178455Z 		total_size += list_size + len;
2025-05-24T14:54:58.6178545Z 		/* Buffer is too small to fit the results */
2025-05-24T14:54:58.6178614Z 		if(total_size > size) {
2025-05-24T14:54:58.6178676Z 			errno = ERANGE;
2025-05-24T14:54:58.6178741Z 			return -1;
2025-05-24T14:54:58.6178796Z 		}
2025-05-24T14:54:58.6178900Z 		/* Shift results back, so we can prepend prefixes */
2025-05-24T14:54:58.6179006Z 		buf = (char *)memmove(list + len, list, list_size);
2025-05-24T14:54:58.6179010Z 
2025-05-24T14:54:58.6179090Z 		for(i = 0; i < list_size; i += len + 1) {
2025-05-24T14:54:58.6179235Z 			len = buf[i];
2025-05-24T14:54:58.6179239Z 
2025-05-24T14:54:58.6179295Z 			/*
2025-05-24T14:54:58.6179399Z 			 * If for some reason we receive a truncated
2025-05-24T14:54:58.6179491Z 			 * return from call to list xattrs the pascal
2025-05-24T14:54:58.6179675Z 			 * string lengths will not be changed and
2025-05-24T14:54:58.6179762Z 			 * therefore we must check that we're not
2025-05-24T14:54:58.6179850Z 			 * reading garbage data or off end of array
2025-05-24T14:54:58.6179904Z 			 */
2025-05-24T14:54:58.6179974Z 			if (len + i >= list_size) {
2025-05-24T14:54:58.6180040Z 				errno = ERANGE;
2025-05-24T14:54:58.6180100Z 				return -1;
2025-05-24T14:54:58.6180154Z 			}
2025-05-24T14:54:58.6180261Z 			strncpy(list, extattr[t].name, extattr[t].len + 1);
2025-05-24T14:54:58.6180329Z 			list += extattr[t].len;
2025-05-24T14:54:58.6180404Z 			strncpy(list, buf + i + 1, len);
2025-05-24T14:54:58.6180466Z 			list[len] = '\0';
2025-05-24T14:54:58.6180529Z 			list += len + 1;
2025-05-24T14:54:58.6180585Z 		}
2025-05-24T14:54:58.6180649Z 		size -= total_size;
2025-05-24T14:54:58.6180710Z 	}
2025-05-24T14:54:58.6180771Z 	return total_size;
2025-05-24T14:54:58.6180825Z }
2025-05-24T14:54:58.6180829Z 
2025-05-24T14:54:58.6180885Z #endif
2025-05-24T14:54:58.6180892Z 
2025-05-24T14:54:58.6181132Z #if defined(HAVE_XATTR_ATTR) && (defined(HAVE_SYS_ATTRIBUTES_H) || defined(HAVE_ATTR_ATTRIBUTES_H))
2025-05-24T14:54:58.6181223Z static char attr_buffer[ATTR_MAX_VALUELEN];
2025-05-24T14:54:58.6181227Z 
2025-05-24T14:54:58.6181454Z static ssize_t irix_attr_list(const char *path, int filedes, char *list, size_t size, int flags)
2025-05-24T14:54:58.6181514Z {
2025-05-24T14:54:58.6181580Z 	int retval = 0, index;
2025-05-24T14:54:58.6181656Z 	attrlist_cursor_t *cursor = 0;
2025-05-24T14:54:58.6181724Z 	int total_size = 0;
2025-05-24T14:54:58.6181816Z 	attrlist_t * al = (attrlist_t *)attr_buffer;
2025-05-24T14:54:58.6181880Z 	attrlist_ent_t *ae;
2025-05-24T14:54:58.6181954Z 	size_t ent_size, left = size;
2025-05-24T14:54:58.6182025Z 	char *bp = list;
2025-05-24T14:54:58.6182028Z 
2025-05-24T14:54:58.6182092Z 	while (true) {
2025-05-24T14:54:58.6182152Z 	    if (filedes)
2025-05-24T14:54:58.6182342Z 		retval = attr_listf(filedes, attr_buffer, ATTR_MAX_VALUELEN, flags, cursor);
2025-05-24T14:54:58.6185313Z 	    else
2025-05-24T14:54:58.6185690Z 		retval = attr_list(path, attr_buffer, ATTR_MAX_VALUELEN, flags, cursor);
2025-05-24T14:54:58.6185881Z 	    if (retval) break;
2025-05-24T14:54:58.6185996Z 	    for (index = 0; index < al->al_count; index++) {
2025-05-24T14:54:58.6186083Z 		ae = ATTR_ENTRY(attr_buffer, index);
2025-05-24T14:54:58.6186183Z 		ent_size = strlen(ae->a_name) + sizeof("user.");
2025-05-24T14:54:58.6186256Z 		if (left >= ent_size) {
2025-05-24T14:54:58.6186342Z 		    strncpy(bp, "user.", sizeof("user."));
2025-05-24T14:54:58.6186462Z 		    strncat(bp, ae->a_name, ent_size - sizeof("user."));
2025-05-24T14:54:58.6186530Z 		    bp += ent_size;
2025-05-24T14:54:58.6186598Z 		    left -= ent_size;
2025-05-24T14:54:58.6186665Z 		} else if (size) {
2025-05-24T14:54:58.6186727Z 		    errno = ERANGE;
2025-05-24T14:54:58.6186796Z 		    retval = -1;
2025-05-24T14:54:58.6186855Z 		    break;
2025-05-24T14:54:58.6186914Z 		}
2025-05-24T14:54:58.6186993Z 		total_size += ent_size;
2025-05-24T14:54:58.6187103Z 	    }
2025-05-24T14:54:58.6187232Z 	    if (al->al_more == 0) break;
2025-05-24T14:54:58.6187333Z 	}
2025-05-24T14:54:58.6187448Z 	if (retval == 0) {
2025-05-24T14:54:58.6187561Z 	    flags |= ATTR_ROOT;
2025-05-24T14:54:58.6187664Z 	    cursor = 0;
2025-05-24T14:54:58.6187767Z 	    while (true) {
2025-05-24T14:54:58.6187872Z 		if (filedes)
2025-05-24T14:54:58.6188184Z 		    retval = attr_listf(filedes, attr_buffer, ATTR_MAX_VALUELEN, flags, cursor);
2025-05-24T14:54:58.6188276Z 		else
2025-05-24T14:54:58.6188560Z 		    retval = attr_list(path, attr_buffer, ATTR_MAX_VALUELEN, flags, cursor);
2025-05-24T14:54:58.6188665Z 		if (retval) break;
2025-05-24T14:54:58.6188825Z 		for (index = 0; index < al->al_count; index++) {
2025-05-24T14:54:58.6189072Z 		    ae = ATTR_ENTRY(attr_buffer, index);
2025-05-24T14:54:58.6189255Z 		    ent_size = strlen(ae->a_name) + sizeof("system.");
2025-05-24T14:54:58.6189369Z 		    if (left >= ent_size) {
2025-05-24T14:54:58.6189519Z 			strncpy(bp, "system.", sizeof("system."));
2025-05-24T14:54:58.6189860Z 			strncat(bp, ae->a_name, ent_size - sizeof("system."));
2025-05-24T14:54:58.6189966Z 			bp += ent_size;
2025-05-24T14:54:58.6190076Z 			left -= ent_size;
2025-05-24T14:54:58.6190189Z 		    } else if (size) {
2025-05-24T14:54:58.6190290Z 			errno = ERANGE;
2025-05-24T14:54:58.6190394Z 			retval = -1;
2025-05-24T14:54:58.6190489Z 			break;
2025-05-24T14:54:58.6190587Z 		    }
2025-05-24T14:54:58.6190705Z 		    total_size += ent_size;
2025-05-24T14:54:58.6190798Z 		}
2025-05-24T14:54:58.6190873Z 		if (al->al_more == 0) break;
2025-05-24T14:54:58.6190934Z 	    }
2025-05-24T14:54:58.6190991Z 	}
2025-05-24T14:54:58.6191090Z 	return (ssize_t)(retval ? retval : total_size);
2025-05-24T14:54:58.6191152Z }
2025-05-24T14:54:58.6191157Z 
2025-05-24T14:54:58.6191214Z #endif
2025-05-24T14:54:58.6191218Z 
2025-05-24T14:54:58.6191372Z ssize_t rep_listxattr (const char *path, char *list, size_t size)
2025-05-24T14:54:58.6191431Z {
2025-05-24T14:54:58.6191504Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6191589Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6191671Z 	return listxattr(path, list, size);
2025-05-24T14:54:58.6191735Z #else
2025-05-24T14:54:58.6191848Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6191913Z #undef listxattr
2025-05-24T14:54:58.6191981Z 	int options = 0;
2025-05-24T14:54:58.6192079Z 	return listxattr(path, list, size, options);
2025-05-24T14:54:58.6192136Z #endif
2025-05-24T14:54:58.6192212Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6192295Z 	return listea(path, list, size);
2025-05-24T14:54:58.6192370Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6192433Z 	extattr_arg arg;
2025-05-24T14:54:58.6192501Z 	arg.path = path;
2025-05-24T14:54:58.6192589Z 	return bsd_attr_list(0, arg, list, size);
2025-05-24T14:54:58.6192731Z #elif defined(HAVE_XATTR_ATTR) && defined(HAVE_SYS_ATTRIBUTES_H)
2025-05-24T14:54:58.6192829Z 	return irix_attr_list(path, 0, list, size, 0);
2025-05-24T14:54:58.6192909Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6192978Z 	ssize_t ret = -1;
2025-05-24T14:54:58.6193104Z 	int attrdirfd = solaris_attropen(path, ".", O_RDONLY, 0);
2025-05-24T14:54:58.6193232Z 	if (attrdirfd >= 0) {
2025-05-24T14:54:58.6193331Z 		ret = solaris_list_xattr(attrdirfd, list, size);
2025-05-24T14:54:58.6193394Z 		close(attrdirfd);
2025-05-24T14:54:58.6193449Z 	}
2025-05-24T14:54:58.6193512Z 	return ret;
2025-05-24T14:54:58.6193569Z #else
2025-05-24T14:54:58.6193635Z 	errno = ENOSYS;
2025-05-24T14:54:58.6193701Z 	return -1;
2025-05-24T14:54:58.6193757Z #endif
2025-05-24T14:54:58.6193813Z }
2025-05-24T14:54:58.6193817Z 
2025-05-24T14:54:58.6193951Z ssize_t rep_flistxattr (int filedes, char *list, size_t size)
2025-05-24T14:54:58.6194013Z {
2025-05-24T14:54:58.6194086Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6194162Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6194250Z 	return flistxattr(filedes, list, size);
2025-05-24T14:54:58.6194305Z #else
2025-05-24T14:54:58.6194413Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6194479Z #undef flistxattr
2025-05-24T14:54:58.6194547Z 	int options = 0;
2025-05-24T14:54:58.6194651Z 	return flistxattr(filedes, list, size, options);
2025-05-24T14:54:58.6194707Z #endif
2025-05-24T14:54:58.6194787Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6194867Z 	return flistea(filedes, list, size);
2025-05-24T14:54:58.6194944Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6195005Z 	extattr_arg arg;
2025-05-24T14:54:58.6195078Z 	arg.filedes = filedes;
2025-05-24T14:54:58.6195162Z 	return bsd_attr_list(2, arg, list, size);
2025-05-24T14:54:58.6195235Z #elif defined(HAVE_XATTR_ATTR)
2025-05-24T14:54:58.6195525Z 	return irix_attr_list(NULL, filedes, list, size, 0);
2025-05-24T14:54:58.6195730Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6195800Z 	ssize_t ret = -1;
2025-05-24T14:54:58.6195958Z 	int attrdirfd = solaris_openat(filedes, ".", O_RDONLY|O_XATTR, 0);
2025-05-24T14:54:58.6196030Z 	if (attrdirfd >= 0) {
2025-05-24T14:54:58.6196238Z 		ret = solaris_list_xattr(attrdirfd, list, size);
2025-05-24T14:54:58.6196361Z 		close(attrdirfd);
2025-05-24T14:54:58.6196468Z 	}
2025-05-24T14:54:58.6196568Z 	return ret;
2025-05-24T14:54:58.6196660Z #else
2025-05-24T14:54:58.6196763Z 	errno = ENOSYS;
2025-05-24T14:54:58.6196868Z 	return -1;
2025-05-24T14:54:58.6196957Z #endif
2025-05-24T14:54:58.6197045Z }
2025-05-24T14:54:58.6197051Z 
2025-05-24T14:54:58.6197271Z int rep_removexattr (const char *path, const char *name)
2025-05-24T14:54:58.6197358Z {
2025-05-24T14:54:58.6197487Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6197583Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6197666Z 	return removexattr(path, name);
2025-05-24T14:54:58.6197725Z #else
2025-05-24T14:54:58.6197842Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6197912Z #undef removexattr
2025-05-24T14:54:58.6197977Z 	int options = 0;
2025-05-24T14:54:58.6198072Z 	return removexattr(path, name, options);
2025-05-24T14:54:58.6198128Z #endif
2025-05-24T14:54:58.6198209Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6198284Z 	return removeea(path, name);
2025-05-24T14:54:58.6198359Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6198433Z 	int attrnamespace;
2025-05-24T14:54:58.6198500Z 	const char *attrname;
2025-05-24T14:54:58.6198504Z 
2025-05-24T14:54:58.6198586Z 	if (strncmp(name, "system.", 7) == 0) {
2025-05-24T14:54:58.6198679Z 		attrnamespace = EXTATTR_NAMESPACE_SYSTEM;
2025-05-24T14:54:58.6198748Z 		attrname = name + 7;
2025-05-24T14:54:58.6198837Z 	} else if (strncmp(name, "user.", 5) == 0) {
2025-05-24T14:54:58.6198924Z 		attrnamespace = EXTATTR_NAMESPACE_USER;
2025-05-24T14:54:58.6198994Z 		attrname = name + 5;
2025-05-24T14:54:58.6199054Z 	} else {
2025-05-24T14:54:58.6199114Z 		errno = EINVAL;
2025-05-24T14:54:58.6199175Z 		return -1;
2025-05-24T14:54:58.6199235Z 	}
2025-05-24T14:54:58.6199239Z 
2025-05-24T14:54:58.6199376Z 	return extattr_delete_file(path, attrnamespace, attrname);
2025-05-24T14:54:58.6199451Z #elif defined(HAVE_XATTR_ATTR)
2025-05-24T14:54:58.6199520Z 	int flags = 0;
2025-05-24T14:54:58.6199600Z 	char *attrname = strchr(name,'.') + 1;
2025-05-24T14:54:58.6199686Z 
2025-05-24T14:54:58.6199802Z 	if (strncmp(name, "system", 6) == 0) flags |= ATTR_ROOT;
2025-05-24T14:54:58.6199806Z 
2025-05-24T14:54:58.6199896Z 	return attr_remove(path, attrname, flags);
2025-05-24T14:54:58.6199969Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6200031Z 	int ret = -1;
2025-05-24T14:54:58.6200153Z 	int attrdirfd = solaris_attropen(path, ".", O_RDONLY, 0);
2025-05-24T14:54:58.6200221Z 	if (attrdirfd >= 0) {
2025-05-24T14:54:58.6200309Z 		ret = solaris_unlinkat(attrdirfd, name);
2025-05-24T14:54:58.6200373Z 		close(attrdirfd);
2025-05-24T14:54:58.6200433Z 	}
2025-05-24T14:54:58.6200492Z 	return ret;
2025-05-24T14:54:58.6200547Z #else
2025-05-24T14:54:58.6200607Z 	errno = ENOSYS;
2025-05-24T14:54:58.6200671Z 	return -1;
2025-05-24T14:54:58.6200726Z #endif
2025-05-24T14:54:58.6200781Z }
2025-05-24T14:54:58.6200785Z 
2025-05-24T14:54:58.6200902Z int rep_fremovexattr (int filedes, const char *name)
2025-05-24T14:54:58.6200959Z {
2025-05-24T14:54:58.6201033Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6201112Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6201197Z 	return fremovexattr(filedes, name);
2025-05-24T14:54:58.6201254Z #else
2025-05-24T14:54:58.6201363Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6201433Z #undef fremovexattr
2025-05-24T14:54:58.6201497Z 	int options = 0;
2025-05-24T14:54:58.6201593Z 	return fremovexattr(filedes, name, options);
2025-05-24T14:54:58.6201648Z #endif
2025-05-24T14:54:58.6201726Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6201803Z 	return fremoveea(filedes, name);
2025-05-24T14:54:58.6201945Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6202015Z 	int attrnamespace;
2025-05-24T14:54:58.6202079Z 	const char *attrname;
2025-05-24T14:54:58.6202083Z 
2025-05-24T14:54:58.6202163Z 	if (strncmp(name, "system.", 7) == 0) {
2025-05-24T14:54:58.6202324Z 		attrnamespace = EXTATTR_NAMESPACE_SYSTEM;
2025-05-24T14:54:58.6202397Z 		attrname = name + 7;
2025-05-24T14:54:58.6202481Z 	} else if (strncmp(name, "user.", 5) == 0) {
2025-05-24T14:54:58.6202568Z 		attrnamespace = EXTATTR_NAMESPACE_USER;
2025-05-24T14:54:58.6202638Z 		attrname = name + 5;
2025-05-24T14:54:58.6202695Z 	} else {
2025-05-24T14:54:58.6202759Z 		errno = EINVAL;
2025-05-24T14:54:58.6202820Z 		return -1;
2025-05-24T14:54:58.6202881Z 	}
2025-05-24T14:54:58.6202885Z 
2025-05-24T14:54:58.6203023Z 	return extattr_delete_fd(filedes, attrnamespace, attrname);
2025-05-24T14:54:58.6203097Z #elif defined(HAVE_XATTR_ATTR)
2025-05-24T14:54:58.6203163Z 	int flags = 0;
2025-05-24T14:54:58.6203242Z 	char *attrname = strchr(name,'.') + 1;
2025-05-24T14:54:58.6203249Z 
2025-05-24T14:54:58.6203360Z 	if (strncmp(name, "system", 6) == 0) flags |= ATTR_ROOT;
2025-05-24T14:54:58.6203364Z 
2025-05-24T14:54:58.6203466Z 	return attr_removef(filedes, attrname, flags);
2025-05-24T14:54:58.6203544Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6203612Z 	int ret = -1;
2025-05-24T14:54:58.6203759Z 	int attrdirfd = solaris_openat(filedes, ".", O_RDONLY|O_XATTR, 0);
2025-05-24T14:54:58.6203832Z 	if (attrdirfd >= 0) {
2025-05-24T14:54:58.6203921Z 		ret = solaris_unlinkat(attrdirfd, name);
2025-05-24T14:54:58.6203986Z 		close(attrdirfd);
2025-05-24T14:54:58.6204043Z 	}
2025-05-24T14:54:58.6204109Z 	return ret;
2025-05-24T14:54:58.6204165Z #else
2025-05-24T14:54:58.6204226Z 	errno = ENOSYS;
2025-05-24T14:54:58.6204291Z 	return -1;
2025-05-24T14:54:58.6204347Z #endif
2025-05-24T14:54:58.6204400Z }
2025-05-24T14:54:58.6204403Z 
2025-05-24T14:54:58.6204628Z int rep_setxattr (const char *path, const char *name, const void *value, size_t size, int flags)
2025-05-24T14:54:58.6204690Z {
2025-05-24T14:54:58.6204754Z 	int retval = -1;
2025-05-24T14:54:58.6204829Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6204909Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6205014Z 	retval = setxattr(path, name, value, size, flags);
2025-05-24T14:54:58.6205076Z 	if (retval < 0) {
2025-05-24T14:54:58.6205161Z 		if (errno == ENOSPC || errno == E2BIG) {
2025-05-24T14:54:58.6205235Z 			errno = ENAMETOOLONG;
2025-05-24T14:54:58.6205494Z 		}
2025-05-24T14:54:58.6205582Z 	}
2025-05-24T14:54:58.6205710Z 	return retval;
2025-05-24T14:54:58.6205780Z #else
2025-05-24T14:54:58.6205896Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6205957Z #undef setxattr
2025-05-24T14:54:58.6206069Z 	retval = setxattr(path, name, value, size, 0, flags);
2025-05-24T14:54:58.6206132Z 	if (retval < 0) {
2025-05-24T14:54:58.6206200Z 		if (errno == E2BIG) {
2025-05-24T14:54:58.6206273Z 			errno = ENAMETOOLONG;
2025-05-24T14:54:58.6206327Z 		}
2025-05-24T14:54:58.6206386Z 	}
2025-05-24T14:54:58.6206447Z 	return retval;
2025-05-24T14:54:58.6206507Z #endif
2025-05-24T14:54:58.6206580Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6206640Z 	if (flags) {
2025-05-24T14:54:58.6206722Z 		retval = getea(path, name, NULL, 0);
2025-05-24T14:54:58.6206789Z 		if (retval < 0) {
2025-05-24T14:54:58.6206885Z 			if (flags & XATTR_REPLACE && errno == ENOATTR) {
2025-05-24T14:54:58.6206945Z 				return -1;
2025-05-24T14:54:58.6207006Z 			}
2025-05-24T14:54:58.6207063Z 		} else {
2025-05-24T14:54:58.6207136Z 			if (flags & XATTR_CREATE) {
2025-05-24T14:54:58.6207196Z 				errno = EEXIST;
2025-05-24T14:54:58.6207261Z 				return -1;
2025-05-24T14:54:58.6207316Z 			}
2025-05-24T14:54:58.6207372Z 		}
2025-05-24T14:54:58.6207428Z 	}
2025-05-24T14:54:58.6207518Z 	retval = setea(path, name, value, size, 0);
2025-05-24T14:54:58.6207580Z 	return retval;
2025-05-24T14:54:58.6207657Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6207727Z 	int attrnamespace;
2025-05-24T14:54:58.6207879Z 	const char *attrname;
2025-05-24T14:54:58.6207884Z 
2025-05-24T14:54:58.6207965Z 	if (strncmp(name, "system.", 7) == 0) {
2025-05-24T14:54:58.6208061Z 		attrnamespace = EXTATTR_NAMESPACE_SYSTEM;
2025-05-24T14:54:58.6208127Z 		attrname = name + 7;
2025-05-24T14:54:58.6208212Z 	} else if (strncmp(name, "user.", 5) == 0) {
2025-05-24T14:54:58.6208403Z 		attrnamespace = EXTATTR_NAMESPACE_USER;
2025-05-24T14:54:58.6208475Z 		attrname = name + 5;
2025-05-24T14:54:58.6208537Z 	} else {
2025-05-24T14:54:58.6208599Z 		errno = EINVAL;
2025-05-24T14:54:58.6208664Z 		return -1;
2025-05-24T14:54:58.6208717Z 	}
2025-05-24T14:54:58.6208721Z 
2025-05-24T14:54:58.6208779Z 	if (flags) {
2025-05-24T14:54:58.6208856Z 		/* Check attribute existence */
2025-05-24T14:54:58.6209017Z 		retval = extattr_get_file(path, attrnamespace, attrname, NULL, 0);
2025-05-24T14:54:58.6209083Z 		if (retval < 0) {
2025-05-24T14:54:58.6209177Z 			/* REPLACE attribute, that doesn't exist */
2025-05-24T14:54:58.6209275Z 			if (flags & XATTR_REPLACE && errno == ENOATTR) {
2025-05-24T14:54:58.6209339Z 				errno = ENOATTR;
2025-05-24T14:54:58.6209403Z 				return -1;
2025-05-24T14:54:58.6209459Z 			}
2025-05-24T14:54:58.6209532Z 			/* Ignore other errors */
2025-05-24T14:54:58.6209587Z 		}
2025-05-24T14:54:58.6209645Z 		else {
2025-05-24T14:54:58.6209739Z 			/* CREATE attribute, that already exists */
2025-05-24T14:54:58.6209809Z 			if (flags & XATTR_CREATE) {
2025-05-24T14:54:58.6209869Z 				errno = EEXIST;
2025-05-24T14:54:58.6209931Z 				return -1;
2025-05-24T14:54:58.6209988Z 			}
2025-05-24T14:54:58.6210041Z 		}
2025-05-24T14:54:58.6210096Z 	}
2025-05-24T14:54:58.6210264Z 	retval = extattr_set_file(path, attrnamespace, attrname, value, size);
2025-05-24T14:54:58.6210339Z 	return (retval < 0) ? -1 : 0;
2025-05-24T14:54:58.6210415Z #elif defined(HAVE_XATTR_ATTR)
2025-05-24T14:54:58.6210476Z 	int myflags = 0;
2025-05-24T14:54:58.6210560Z 	char *attrname = strchr(name,'.') + 1;
2025-05-24T14:54:58.6210564Z 
2025-05-24T14:54:58.6210681Z 	if (strncmp(name, "system", 6) == 0) myflags |= ATTR_ROOT;
2025-05-24T14:54:58.6210779Z 	if (flags & XATTR_CREATE) myflags |= ATTR_CREATE;
2025-05-24T14:54:58.6210884Z 	if (flags & XATTR_REPLACE) myflags |= ATTR_REPLACE;
2025-05-24T14:54:58.6210888Z 
2025-05-24T14:54:58.6211039Z 	retval = attr_set(path, attrname, (const char *)value, size, myflags);
2025-05-24T14:54:58.6211103Z 	if (retval < 0) {
2025-05-24T14:54:58.6211173Z 		if (errno == E2BIG) {
2025-05-24T14:54:58.6211310Z 			errno = ENAMETOOLONG;
2025-05-24T14:54:58.6211366Z 		}
2025-05-24T14:54:58.6211421Z 	}
2025-05-24T14:54:58.6211485Z 	return retval;
2025-05-24T14:54:58.6211558Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6211626Z 	int myflags = O_RDWR;
2025-05-24T14:54:58.6211686Z 	int attrfd;
2025-05-24T14:54:58.6211775Z 	if (flags & XATTR_CREATE) myflags |= O_EXCL;
2025-05-24T14:54:58.6211867Z 	if (!(flags & XATTR_REPLACE)) myflags |= O_CREAT;
2025-05-24T14:54:58.6212046Z 	attrfd = solaris_attropen(path, name, myflags, (mode_t) SOLARIS_ATTRMODE);
2025-05-24T14:54:58.6212114Z 	if (attrfd >= 0) {
2025-05-24T14:54:58.6212218Z 		retval = solaris_write_xattr(attrfd, value, size);
2025-05-24T14:54:58.6212279Z 		close(attrfd);
2025-05-24T14:54:58.6212337Z 	}
2025-05-24T14:54:58.6212398Z 	return retval;
2025-05-24T14:54:58.6212453Z #else
2025-05-24T14:54:58.6212514Z 	errno = ENOSYS;
2025-05-24T14:54:58.6212582Z 	return -1;
2025-05-24T14:54:58.6212638Z #endif
2025-05-24T14:54:58.6212693Z }
2025-05-24T14:54:58.6212699Z 
2025-05-24T14:54:58.6212921Z int rep_fsetxattr (int filedes, const char *name, const void *value, size_t size, int flags)
2025-05-24T14:54:58.6212976Z {
2025-05-24T14:54:58.6213039Z 	int retval = -1;
2025-05-24T14:54:58.6213113Z #if defined(HAVE_XATTR_XATTR)
2025-05-24T14:54:58.6213194Z #ifndef XATTR_ADDITIONAL_OPTIONS
2025-05-24T14:54:58.6213309Z 	retval = fsetxattr(filedes, name, value, size, flags);
2025-05-24T14:54:58.6213372Z 	if (retval < 0) {
2025-05-24T14:54:58.6213442Z 		if (errno == ENOSPC) {
2025-05-24T14:54:58.6213511Z 			errno = ENAMETOOLONG;
2025-05-24T14:54:58.6213614Z 		}
2025-05-24T14:54:58.6213669Z 	}
2025-05-24T14:54:58.6213733Z 	return retval;
2025-05-24T14:54:58.6213791Z #else
2025-05-24T14:54:58.6213900Z /* So that we do not recursively call this function */
2025-05-24T14:54:58.6213968Z #undef fsetxattr
2025-05-24T14:54:58.6214160Z 	retval = fsetxattr(filedes, name, value, size, 0, flags);
2025-05-24T14:54:58.6214227Z 	if (retval < 0) {
2025-05-24T14:54:58.6214292Z 		if (errno == E2BIG) {
2025-05-24T14:54:58.6214369Z 			errno = ENAMETOOLONG;
2025-05-24T14:54:58.6214423Z 		}
2025-05-24T14:54:58.6214477Z 	}
2025-05-24T14:54:58.6214536Z 	return retval;
2025-05-24T14:54:58.6214596Z #endif
2025-05-24T14:54:58.6214666Z #elif defined(HAVE_XATTR_EA)
2025-05-24T14:54:58.6214724Z 	if (flags) {
2025-05-24T14:54:58.6214812Z 		retval = fgetea(filedes, name, NULL, 0);
2025-05-24T14:54:58.6214874Z 		if (retval < 0) {
2025-05-24T14:54:58.6214972Z 			if (flags & XATTR_REPLACE && errno == ENOATTR) {
2025-05-24T14:54:58.6215033Z 				return -1;
2025-05-24T14:54:58.6215092Z 			}
2025-05-24T14:54:58.6215149Z 		} else {
2025-05-24T14:54:58.6215217Z 			if (flags & XATTR_CREATE) {
2025-05-24T14:54:58.6215281Z 				errno = EEXIST;
2025-05-24T14:54:58.6215483Z 				return -1;
2025-05-24T14:54:58.6215580Z 			}
2025-05-24T14:54:58.6215640Z 		}
2025-05-24T14:54:58.6215697Z 	}
2025-05-24T14:54:58.6215800Z 	retval = fsetea(filedes, name, value, size, 0);
2025-05-24T14:54:58.6215860Z 	return retval;
2025-05-24T14:54:58.6215939Z #elif defined(HAVE_XATTR_EXTATTR)
2025-05-24T14:54:58.6216006Z 	int attrnamespace;
2025-05-24T14:54:58.6216072Z 	const char *attrname;
2025-05-24T14:54:58.6216076Z 
2025-05-24T14:54:58.6216156Z 	if (strncmp(name, "system.", 7) == 0) {
2025-05-24T14:54:58.6216250Z 		attrnamespace = EXTATTR_NAMESPACE_SYSTEM;
2025-05-24T14:54:58.6216316Z 		attrname = name + 7;
2025-05-24T14:54:58.6216403Z 	} else if (strncmp(name, "user.", 5) == 0) {
2025-05-24T14:54:58.6216492Z 		attrnamespace = EXTATTR_NAMESPACE_USER;
2025-05-24T14:54:58.6216556Z 		attrname = name + 5;
2025-05-24T14:54:58.6216614Z 	} else {
2025-05-24T14:54:58.6216674Z 		errno = EINVAL;
2025-05-24T14:54:58.6216738Z 		return -1;
2025-05-24T14:54:58.6216793Z 	}
2025-05-24T14:54:58.6216797Z 
2025-05-24T14:54:58.6216856Z 	if (flags) {
2025-05-24T14:54:58.6216936Z 		/* Check attribute existence */
2025-05-24T14:54:58.6217094Z 		retval = extattr_get_fd(filedes, attrnamespace, attrname, NULL, 0);
2025-05-24T14:54:58.6217159Z 		if (retval < 0) {
2025-05-24T14:54:58.6217326Z 			/* REPLACE attribute, that doesn't exist */
2025-05-24T14:54:58.6217427Z 			if (flags & XATTR_REPLACE && errno == ENOATTR) {
2025-05-24T14:54:58.6217490Z 				errno = ENOATTR;
2025-05-24T14:54:58.6217553Z 				return -1;
2025-05-24T14:54:58.6217613Z 			}
2025-05-24T14:54:58.6217682Z 			/* Ignore other errors */
2025-05-24T14:54:58.6217736Z 		}
2025-05-24T14:54:58.6217794Z 		else {
2025-05-24T14:54:58.6217885Z 			/* CREATE attribute, that already exists */
2025-05-24T14:54:58.6217954Z 			if (flags & XATTR_CREATE) {
2025-05-24T14:54:58.6218016Z 				errno = EEXIST;
2025-05-24T14:54:58.6218079Z 				return -1;
2025-05-24T14:54:58.6218134Z 			}
2025-05-24T14:54:58.6218188Z 		}
2025-05-24T14:54:58.6218244Z 	}
2025-05-24T14:54:58.6218413Z 	retval = extattr_set_fd(filedes, attrnamespace, attrname, value, size);
2025-05-24T14:54:58.6218482Z 	return (retval < 0) ? -1 : 0;
2025-05-24T14:54:58.6218558Z #elif defined(HAVE_XATTR_ATTR)
2025-05-24T14:54:58.6218624Z 	int myflags = 0;
2025-05-24T14:54:58.6218707Z 	char *attrname = strchr(name,'.') + 1;
2025-05-24T14:54:58.6218711Z 
2025-05-24T14:54:58.6218829Z 	if (strncmp(name, "system", 6) == 0) myflags |= ATTR_ROOT;
2025-05-24T14:54:58.6218927Z 	if (flags & XATTR_CREATE) myflags |= ATTR_CREATE;
2025-05-24T14:54:58.6219026Z 	if (flags & XATTR_REPLACE) myflags |= ATTR_REPLACE;
2025-05-24T14:54:58.6219029Z 
2025-05-24T14:54:58.6219194Z 	return attr_setf(filedes, attrname, (const char *)value, size, myflags);
2025-05-24T14:54:58.6219268Z #elif defined(HAVE_ATTROPEN)
2025-05-24T14:54:58.6219346Z 	int myflags = O_RDWR | O_XATTR;
2025-05-24T14:54:58.6219471Z 	int attrfd;
2025-05-24T14:54:58.6219558Z 	if (flags & XATTR_CREATE) myflags |= O_EXCL;
2025-05-24T14:54:58.6219652Z 	if (!(flags & XATTR_REPLACE)) myflags |= O_CREAT;
2025-05-24T14:54:58.6219823Z 	attrfd = solaris_openat(filedes, name, myflags, (mode_t) SOLARIS_ATTRMODE);
2025-05-24T14:54:58.6219987Z 	if (attrfd >= 0) {
2025-05-24T14:54:58.6220092Z 		retval = solaris_write_xattr(attrfd, value, size);
2025-05-24T14:54:58.6220159Z 		close(attrfd);
2025-05-24T14:54:58.6220219Z 	}
2025-05-24T14:54:58.6220281Z 	return retval;
2025-05-24T14:54:58.6220336Z #else
2025-05-24T14:54:58.6220396Z 	errno = ENOSYS;
2025-05-24T14:54:58.6220453Z 	return -1;
2025-05-24T14:54:58.6220509Z #endif
2025-05-24T14:54:58.6220562Z }
2025-05-24T14:54:58.6220566Z 
2025-05-24T14:54:58.6220649Z /**************************************************************************
2025-05-24T14:54:58.6220736Z  helper functions for Solaris' EA support
2025-05-24T14:54:58.6220824Z ****************************************************************************/
2025-05-24T14:54:58.6220947Z #ifdef HAVE_ATTROPEN
2025-05-24T14:54:58.6221420Z static ssize_t solaris_read_xattr(int attrfd, void *value, size_t size)
2025-05-24T14:54:58.6221520Z {
2025-05-24T14:54:58.6221631Z 	struct stat sbuf;
2025-05-24T14:54:58.6221637Z 
2025-05-24T14:54:58.6221767Z 	if (fstat(attrfd, &sbuf) == -1) {
2025-05-24T14:54:58.6221866Z 		errno = ENOATTR;
2025-05-24T14:54:58.6221967Z 		return -1;
2025-05-24T14:54:58.6222061Z 	}
2025-05-24T14:54:58.6222066Z 
2025-05-24T14:54:58.6222335Z 	/* This is to return the current size of the named extended attribute */
2025-05-24T14:54:58.6222435Z 	if (size == 0) {
2025-05-24T14:54:58.6222542Z 		return sbuf.st_size;
2025-05-24T14:54:58.6222633Z 	}
2025-05-24T14:54:58.6222638Z 
2025-05-24T14:54:58.6222758Z 	/* check size and read xattr */
2025-05-24T14:54:58.6222884Z 	if (sbuf.st_size > size) {
2025-05-24T14:54:58.6222957Z 		errno = ERANGE;
2025-05-24T14:54:58.6223022Z 		return -1;
2025-05-24T14:54:58.6223077Z 	}
2025-05-24T14:54:58.6223082Z 
2025-05-24T14:54:58.6223172Z 	return read(attrfd, value, sbuf.st_size);
2025-05-24T14:54:58.6223230Z }
2025-05-24T14:54:58.6223233Z 
2025-05-24T14:54:58.6223403Z static ssize_t solaris_list_xattr(int attrdirfd, char *list, size_t size)
2025-05-24T14:54:58.6223457Z {
2025-05-24T14:54:58.6223522Z 	ssize_t len = 0;
2025-05-24T14:54:58.6223586Z 	DIR *dirp;
2025-05-24T14:54:58.6223648Z 	struct dirent *de;
2025-05-24T14:54:58.6223791Z 	int newfd = dup(attrdirfd);
2025-05-24T14:54:58.6223921Z 	/* CAUTION: The originating file descriptor should not be
2025-05-24T14:54:58.6224022Z 	            used again following the call to fdopendir().
2025-05-24T14:54:58.6224121Z 	            For that reason we dup() the file descriptor
2025-05-24T14:54:58.6224204Z 		    here to make things more clear. */
2025-05-24T14:54:58.6224277Z 	dirp = fdopendir(newfd);
2025-05-24T14:54:58.6224280Z 
2025-05-24T14:54:58.6224354Z 	while ((de = readdir(dirp))) {
2025-05-24T14:54:58.6224438Z 		size_t listlen = strlen(de->d_name) + 1;
2025-05-24T14:54:58.6224563Z 		if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, "..")) {
2025-05-24T14:54:58.6224639Z 			/* we don't want "." and ".." here: */
2025-05-24T14:54:58.6224699Z 			continue;
2025-05-24T14:54:58.6224756Z 		}
2025-05-24T14:54:58.6224761Z 
2025-05-24T14:54:58.6224819Z 		if (size == 0) {
2025-05-24T14:54:58.6224973Z 			/* return the current size of the list of extended attribute names*/
2025-05-24T14:54:58.6225036Z 			len += listlen;
2025-05-24T14:54:58.6225096Z 		} else {
2025-05-24T14:54:58.6225311Z 			/* check size and copy entrie—ï + nul into list. */
2025-05-24T14:54:58.6225528Z 			if ((len + listlen) > size) {
2025-05-24T14:54:58.6225597Z 				errno = ERANGE;
2025-05-24T14:54:58.6225658Z 				len = -1;
2025-05-24T14:54:58.6225713Z 				break;
2025-05-24T14:54:58.6225770Z 			} else {
2025-05-24T14:54:58.6225864Z 				strlcpy(list + len, de->d_name, listlen);
2025-05-24T14:54:58.6225923Z 				len += listlen;
2025-05-24T14:54:58.6225977Z 			}
2025-05-24T14:54:58.6226119Z 		}
2025-05-24T14:54:58.6226174Z 	}
2025-05-24T14:54:58.6226178Z 
2025-05-24T14:54:58.6226255Z 	if (closedir(dirp) == -1) {
2025-05-24T14:54:58.6226315Z 		return -1;
2025-05-24T14:54:58.6226372Z 	}
2025-05-24T14:54:58.6226431Z 	return len;
2025-05-24T14:54:58.6226484Z }
2025-05-24T14:54:58.6226488Z 
2025-05-24T14:54:58.6226758Z static int solaris_unlinkat(int attrdirfd, const char *name)
2025-05-24T14:54:58.6226814Z {
2025-05-24T14:54:58.6226909Z 	if (unlinkat(attrdirfd, name, 0) == -1) {
2025-05-24T14:54:58.6226976Z 		if (errno == ENOENT) {
2025-05-24T14:54:58.6227039Z 			errno = ENOATTR;
2025-05-24T14:54:58.6227093Z 		}
2025-05-24T14:54:58.6227153Z 		return -1;
2025-05-24T14:54:58.6227208Z 	}
2025-05-24T14:54:58.6227265Z 	return 0;
2025-05-24T14:54:58.6227320Z }
2025-05-24T14:54:58.6227324Z 
2025-05-24T14:54:58.6227555Z static int solaris_attropen(const char *path, const char *attrpath, int oflag, mode_t mode)
2025-05-24T14:54:58.6227613Z {
2025-05-24T14:54:58.6227725Z 	int filedes = attropen(path, attrpath, oflag, mode);
2025-05-24T14:54:58.6227794Z 	if (filedes == -1) {
2025-05-24T14:54:58.6227864Z 		if (errno == EINVAL) {
2025-05-24T14:54:58.6227925Z 			errno = ENOTSUP;
2025-05-24T14:54:58.6227979Z 		} else {
2025-05-24T14:54:58.6228039Z 			errno = ENOATTR;
2025-05-24T14:54:58.6228097Z 		}
2025-05-24T14:54:58.6228151Z 	}
2025-05-24T14:54:58.6228214Z 	return filedes;
2025-05-24T14:54:58.6228270Z }
2025-05-24T14:54:58.6228274Z 
2025-05-24T14:54:58.6228465Z static int solaris_openat(int fildes, const char *path, int oflag, mode_t mode)
2025-05-24T14:54:58.6228519Z {
2025-05-24T14:54:58.6228621Z 	int filedes = openat(fildes, path, oflag, mode);
2025-05-24T14:54:58.6228689Z 	if (filedes == -1) {
2025-05-24T14:54:58.6228754Z 		if (errno == EINVAL) {
2025-05-24T14:54:58.6228814Z 			errno = ENOTSUP;
2025-05-24T14:54:58.6228874Z 		} else {
2025-05-24T14:54:58.6228935Z 			errno = ENOATTR;
2025-05-24T14:54:58.6228987Z 		}
2025-05-24T14:54:58.6229040Z 	}
2025-05-24T14:54:58.6229102Z 	return filedes;
2025-05-24T14:54:58.6229158Z }
2025-05-24T14:54:58.6229161Z 
2025-05-24T14:54:58.6229328Z static int solaris_write_xattr(int attrfd, const char *value, size_t size)
2025-05-24T14:54:58.6229385Z {
2025-05-24T14:54:58.6229536Z 	if ((ftruncate(attrfd, 0) == 0) && (write(attrfd, value, size) == size)) {
2025-05-24T14:54:58.6229594Z 		return 0;
2025-05-24T14:54:58.6229653Z 	} else {
2025-05-24T14:54:58.6229715Z 		return -1;
2025-05-24T14:54:58.6229768Z 	}
2025-05-24T14:54:58.6229890Z }
2025-05-24T14:54:58.6229960Z #endif /*HAVE_ATTROPEN*/
2025-05-24T14:54:58.6229965Z 
2025-05-24T14:54:58.6229969Z 
2025-05-24T14:54:58.6230029Z -------------------
2025-05-24T14:54:58.6230125Z Analyzing replace.h for typedef conflicts...
2025-05-24T14:54:58.6230343Z + for file in lib/replace/*.c
2025-05-24T14:54:58.6230449Z + grep -q RTLD_DEFAULT lib/replace/socketpair.c
2025-05-24T14:54:58.6230526Z + for file in lib/replace/*.c
2025-05-24T14:54:58.6230623Z + grep -q RTLD_DEFAULT lib/replace/strptime.c
2025-05-24T14:54:58.6230695Z + for file in lib/replace/*.c
2025-05-24T14:54:58.6230787Z + grep -q RTLD_DEFAULT lib/replace/timegm.c
2025-05-24T14:54:58.6230855Z + for file in lib/replace/*.c
2025-05-24T14:54:58.6230943Z + grep -q RTLD_DEFAULT lib/replace/xattr.c
2025-05-24T14:54:58.6231005Z + '[' 4 -gt 0 ']'
2025-05-24T14:54:58.6231373Z + echo 'Patching replace.h to remove conflicting typedefs: typedef.*intptr_t typedef.*uintptr_t typedef.*ptrdiff_t typedef.*useconds_t'
2025-05-24T14:54:58.6231459Z + for pattern in "${PATTERNS[@]}"
2025-05-24T14:54:58.6231567Z + sed -i '/typedef.*intptr_t/d' lib/replace/replace.h
2025-05-24T14:54:58.6231641Z + for pattern in "${PATTERNS[@]}"
2025-05-24T14:54:58.6231752Z + sed -i '/typedef.*uintptr_t/d' lib/replace/replace.h
2025-05-24T14:54:58.6231823Z + for pattern in "${PATTERNS[@]}"
2025-05-24T14:54:58.6231928Z + sed -i '/typedef.*ptrdiff_t/d' lib/replace/replace.h
2025-05-24T14:54:58.6231999Z + for pattern in "${PATTERNS[@]}"
2025-05-24T14:54:58.6232113Z + sed -i '/typedef.*useconds_t/d' lib/replace/replace.h
2025-05-24T14:54:58.6232229Z + '[' false = true ']'
2025-05-24T14:54:58.6232308Z + echo '=== Patched replace.h ==='
2025-05-24T14:54:58.6232386Z + cat lib/replace/replace.h
2025-05-24T14:54:58.6232471Z + echo '=== End of patched replace.h ==='
2025-05-24T14:54:58.6232541Z + export ANDROID_API=21
2025-05-24T14:54:58.6232603Z + ANDROID_API=21
2025-05-24T14:54:58.6232767Z + export NDK_HOME=/home/runner/android-ndk
2025-05-24T14:54:58.6232848Z + NDK_HOME=/home/runner/android-ndk
2025-05-24T14:54:58.6233071Z + export TOOLCHAIN=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin
2025-05-24T14:54:58.6233262Z + TOOLCHAIN=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin
2025-05-24T14:54:58.6233485Z + export SYSROOT=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot
2025-05-24T14:54:58.6233680Z + SYSROOT=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot
2025-05-24T14:54:58.6233985Z + export CC=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang
2025-05-24T14:54:58.6234261Z + CC=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang
2025-05-24T14:54:58.6234467Z + export AR=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar
2025-05-24T14:54:58.6234655Z + AR=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar
2025-05-24T14:54:58.6234891Z + export RANLIB=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib
2025-05-24T14:54:58.6235104Z + RANLIB=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib
2025-05-24T14:54:58.6236186Z + export 'CFLAGS=--target=aarch64-linux-android21 --sysroot=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot -fPIC -DANDROID -I/home/runner/work/boost-armv8-build/boost-armv8-build/talloc-2.4.2 -I/home/runner/work/boost-armv8-build/boost-armv8-build/talloc-2.4.2/lib/replace -std=c99'
2025-05-24T14:54:58.6237140Z + CFLAGS='--target=aarch64-linux-android21 --sysroot=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot -fPIC -DANDROID -I/home/runner/work/boost-armv8-build/boost-armv8-build/talloc-2.4.2 -I/home/runner/work/boost-armv8-build/boost-armv8-build/talloc-2.4.2/lib/replace -std=c99'
2025-05-24T14:54:58.6237540Z + export 'LDFLAGS=--target=aarch64-linux-android21 --sysroot=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot -fPIC'
2025-05-24T14:54:58.6237983Z + LDFLAGS='--target=aarch64-linux-android21 --sysroot=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot -fPIC'
2025-05-24T14:54:58.6238070Z + mkdir -p install/include install/lib
2025-05-24T14:54:58.6238133Z + cd lib/replace
2025-05-24T14:54:58.6238197Z + for src in *.c
2025-05-24T14:54:58.6239556Z + /home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang --target=aarch64-linux-android21 --sysroot=/home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot -fPIC -DANDROID -I/home/runner/work/boost-armv8-build/boost-armv8-build/talloc-2.4.2 -I/home/runner/work/boost-armv8-build/boost-armv8-build/talloc-2.4.2/lib/replace -std=c99 -c closefrom.c -o closefrom.o
2025-05-24T14:54:58.6239644Z In file included from closefrom.c:24:
2025-05-24T14:54:58.6240071Z /home/runner/work/boost-armv8-build/boost-armv8-build/talloc-2.4.2/lib/replace/replace.h:1037:47: error: use of undeclared identifier 'RTLD_DEFAULT'
2025-05-24T14:54:58.6240239Z         __wrapper_enabled_fn = (bool (*)(void))dlsym(RTLD_DEFAULT, state->fnname);
2025-05-24T14:54:58.6240316Z                                                      ^
2025-05-24T14:54:58.6240384Z 1 error generated.
2025-05-24T14:54:58.6240728Z Patching replace.h to remove conflicting typedefs: typedef.*intptr_t typedef.*uintptr_t typedef.*ptrdiff_t typedef.*useconds_t
2025-05-24T14:54:58.6240801Z === Patched replace.h ===
2025-05-24T14:54:58.6240857Z /*
2025-05-24T14:54:58.6240938Z    Unix SMB/CIFS implementation.
2025-05-24T14:54:58.6240943Z 
2025-05-24T14:54:58.6241155Z    macros to go along with the lib/replace/ portability layer code
2025-05-24T14:54:58.6241159Z 
2025-05-24T14:54:58.6241238Z    Copyright (C) Andrew Tridgell 2005
2025-05-24T14:54:58.6241326Z    Copyright (C) Jelmer Vernooij 2006-2008
2025-05-24T14:54:58.6241402Z    Copyright (C) Jeremy Allison 2007.
2025-05-24T14:54:58.6241507Z 
2025-05-24T14:54:58.6241634Z      ** NOTE! The following LGPL license applies to the replace
2025-05-24T14:54:58.6241768Z      ** library. This does NOT imply that all of Samba is released
2025-05-24T14:54:58.6241833Z      ** under the LGPL
2025-05-24T14:54:58.6241837Z 
2025-05-24T14:54:58.6241970Z    This library is free software; you can redistribute it and/or
2025-05-24T14:54:58.6242100Z    modify it under the terms of the GNU Lesser General Public
2025-05-24T14:54:58.6242232Z    License as published by the Free Software Foundation; either
2025-05-24T14:54:58.6242368Z    version 3 of the License, or (at your option) any later version.
2025-05-24T14:54:58.6242374Z 
2025-05-24T14:54:58.6242511Z    This library is distributed in the hope that it will be useful,
2025-05-24T14:54:58.6242653Z    but WITHOUT ANY WARRANTY; without even the implied warranty of
2025-05-24T14:54:58.6242814Z    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2025-05-24T14:54:58.6242917Z    Lesser General Public License for more details.
2025-05-24T14:54:58.6242921Z 
2025-05-24T14:54:58.6243065Z    You should have received a copy of the GNU Lesser General Public
2025-05-24T14:54:58.6243250Z    License along with this library; if not, see <http://www.gnu.org/licenses/>.
2025-05-24T14:54:58.6243309Z */
2025-05-24T14:54:58.6243312Z 
2025-05-24T14:54:58.6243393Z #ifndef _LIBREPLACE_REPLACE_H
2025-05-24T14:54:58.6243468Z #define _LIBREPLACE_REPLACE_H
2025-05-24T14:54:58.6243471Z 
2025-05-24T14:54:58.6243534Z #ifndef NO_CONFIG_H
2025-05-24T14:54:58.6243598Z #include "config.h"
2025-05-24T14:54:58.6243653Z #endif
2025-05-24T14:54:58.6243656Z 
2025-05-24T14:54:58.6243725Z #ifdef HAVE_STANDARDS_H
2025-05-24T14:54:58.6243795Z #include <standards.h>
2025-05-24T14:54:58.6243854Z #endif
2025-05-24T14:54:58.6243857Z 
2025-05-24T14:54:58.6243909Z /*
2025-05-24T14:54:58.6244033Z  * Needs to be defined before std*.h and string*.h are included
2025-05-24T14:54:58.6244151Z  * As it's also needed when Python.h is the first header we
2025-05-24T14:54:58.6244244Z  * require a global -D__STDC_WANT_LIB_EXT1__=1
2025-05-24T14:54:58.6244298Z  */
2025-05-24T14:54:58.6244419Z #if __STDC_WANT_LIB_EXT1__ != 1
2025-05-24T14:54:58.6244506Z #error -D__STDC_WANT_LIB_EXT1__=1 required
2025-05-24T14:54:58.6244562Z #endif
2025-05-24T14:54:58.6244565Z 
2025-05-24T14:54:58.6244627Z #include <stdio.h>
2025-05-24T14:54:58.6244691Z #include <stdlib.h>
2025-05-24T14:54:58.6244752Z #include <stdarg.h>
2025-05-24T14:54:58.6244812Z #include <errno.h>
2025-05-24T14:54:58.6244816Z 
2025-05-24T14:54:58.6244889Z #ifndef HAVE_DECL_EWOULDBLOCK
2025-05-24T14:54:58.6244960Z #define EWOULDBLOCK EAGAIN
2025-05-24T14:54:58.6245014Z #endif
2025-05-24T14:54:58.6245019Z 
2025-05-24T14:54:58.6245107Z #if defined(_MSC_VER) || defined(__MINGW32__)
2025-05-24T14:54:58.6245178Z #include "win32_replace.h"
2025-05-24T14:54:58.6245232Z #endif
2025-05-24T14:54:58.6245236Z 
2025-05-24T14:54:58.6245239Z 
2025-05-24T14:54:58.6245307Z #ifdef HAVE_INTTYPES_H
2025-05-24T14:54:58.6245614Z #define __STDC_FORMAT_MACROS
2025-05-24T14:54:58.6245706Z #include <inttypes.h>
2025-05-24T14:54:58.6245785Z #elif defined(HAVE_STDINT_H)
2025-05-24T14:54:58.6245850Z #include <stdint.h>
2025-05-24T14:54:58.6246039Z /* force off HAVE_INTTYPES_H so that roken doesn't try to include both,
2025-05-24T14:54:58.6246192Z    which causes a warning storm on irix */
2025-05-24T14:54:58.6246317Z #undef HAVE_INTTYPES_H
2025-05-24T14:54:58.6246380Z #endif
2025-05-24T14:54:58.6246384Z 
2025-05-24T14:54:58.6246448Z #ifdef HAVE_MALLOC_H
2025-05-24T14:54:58.6246511Z #include <malloc.h>
2025-05-24T14:54:58.6246570Z #endif
2025-05-24T14:54:58.6246573Z 
2025-05-24T14:54:58.6246638Z #ifndef __PRI64_PREFIX
2025-05-24T14:54:58.6246817Z # if __WORDSIZE == 64 && ! defined __APPLE__
2025-05-24T14:54:58.6246888Z #  define __PRI64_PREFIX	"l"
2025-05-24T14:54:58.6246946Z # else
2025-05-24T14:54:58.6247015Z #  define __PRI64_PREFIX	"ll"
2025-05-24T14:54:58.6247072Z # endif
2025-05-24T14:54:58.6247131Z #endif
2025-05-24T14:54:58.6247239Z 
2025-05-24T14:54:58.6247312Z /* Decimal notation.  */
2025-05-24T14:54:58.6247374Z #ifndef PRId8
2025-05-24T14:54:58.6247441Z # define PRId8		"d"
2025-05-24T14:54:58.6247499Z #endif
2025-05-24T14:54:58.6247561Z #ifndef PRId16
2025-05-24T14:54:58.6247627Z # define PRId16		"d"
2025-05-24T14:54:58.6247684Z #endif
2025-05-24T14:54:58.6247745Z #ifndef PRId32
2025-05-24T14:54:58.6247808Z # define PRId32		"d"
2025-05-24T14:54:58.6247863Z #endif
2025-05-24T14:54:58.6247925Z #ifndef PRId64
2025-05-24T14:54:58.6248002Z # define PRId64		__PRI64_PREFIX "d"
2025-05-24T14:54:58.6248056Z #endif
2025-05-24T14:54:58.6248060Z 
2025-05-24T14:54:58.6248121Z #ifndef PRIi8
2025-05-24T14:54:58.6248186Z # define PRIi8		"i"
2025-05-24T14:54:58.6248240Z #endif
2025-05-24T14:54:58.6248299Z #ifndef PRIi16
2025-05-24T14:54:58.6248364Z # define PRIi16		"i"
2025-05-24T14:54:58.6248419Z #endif
2025-05-24T14:54:58.6248479Z #ifndef PRIi32
2025-05-24T14:54:58.6248541Z # define PRIi32		"i"
2025-05-24T14:54:58.6248598Z #endif
2025-05-24T14:54:58.6248661Z #ifndef PRIi64
2025-05-24T14:54:58.6248734Z # define PRIi64		__PRI64_PREFIX "i"
2025-05-24T14:54:58.6248794Z #endif
2025-05-24T14:54:58.6248798Z 
2025-05-24T14:54:58.6248856Z #ifndef PRIu8
2025-05-24T14:54:58.6248921Z # define PRIu8		"u"
2025-05-24T14:54:58.6248975Z #endif
2025-05-24T14:54:58.6249036Z #ifndef PRIu16
2025-05-24T14:54:58.6249098Z # define PRIu16		"u"
2025-05-24T14:54:58.6249152Z #endif
2025-05-24T14:54:58.6249216Z #ifndef PRIu32
2025-05-24T14:54:58.6249279Z # define PRIu32		"u"
2025-05-24T14:54:58.6249335Z #endif
2025-05-24T14:54:58.6249394Z #ifndef PRIu64
2025-05-24T14:54:58.6249468Z # define PRIu64		__PRI64_PREFIX "u"
2025-05-24T14:54:58.6249523Z #endif
2025-05-24T14:54:58.6249528Z 
2025-05-24T14:54:58.6249587Z #ifndef SCNd8
2025-05-24T14:54:58.6249655Z # define SCNd8		"hhd"
2025-05-24T14:54:58.6249711Z #endif
2025-05-24T14:54:58.6249772Z #ifndef SCNd16
2025-05-24T14:54:58.6249836Z # define SCNd16		"hd"
2025-05-24T14:54:58.6249893Z #endif
2025-05-24T14:54:58.6249956Z #ifndef SCNd32
2025-05-24T14:54:58.6250018Z # define SCNd32		"d"
2025-05-24T14:54:58.6250074Z #endif
2025-05-24T14:54:58.6250205Z #ifndef SCNd64
2025-05-24T14:54:58.6250276Z # define SCNd64		__PRI64_PREFIX "d"
2025-05-24T14:54:58.6250331Z #endif
2025-05-24T14:54:58.6250334Z 
2025-05-24T14:54:58.6250396Z #ifndef SCNi8
2025-05-24T14:54:58.6250457Z # define SCNi8		"hhi"
2025-05-24T14:54:58.6250511Z #endif
2025-05-24T14:54:58.6250571Z #ifndef SCNi16
2025-05-24T14:54:58.6250632Z # define SCNi16		"hi"
2025-05-24T14:54:58.6250687Z #endif
2025-05-24T14:54:58.6250744Z #ifndef SCNi32
2025-05-24T14:54:58.6250812Z # define SCNi32		"i"
2025-05-24T14:54:58.6250865Z #endif
2025-05-24T14:54:58.6250924Z #ifndef SCNi64
2025-05-24T14:54:58.6251000Z # define SCNi64		__PRI64_PREFIX "i"
2025-05-24T14:54:58.6251054Z #endif
2025-05-24T14:54:58.6251058Z 
2025-05-24T14:54:58.6251115Z #ifndef SCNu8
2025-05-24T14:54:58.6251176Z # define SCNu8		"hhu"
2025-05-24T14:54:58.6251233Z #endif
2025-05-24T14:54:58.6251292Z #ifndef SCNu16
2025-05-24T14:54:58.6251357Z # define SCNu16		"hu"
2025-05-24T14:54:58.6251414Z #endif
2025-05-24T14:54:58.6251473Z #ifndef SCNu32
2025-05-24T14:54:58.6251536Z # define SCNu32		"u"
2025-05-24T14:54:58.6251589Z #endif
2025-05-24T14:54:58.6251649Z #ifndef SCNu64
2025-05-24T14:54:58.6251720Z # define SCNu64		__PRI64_PREFIX "u"
2025-05-24T14:54:58.6251777Z #endif
2025-05-24T14:54:58.6251780Z 
2025-05-24T14:54:58.6251852Z #ifdef HAVE_BSD_STRING_H
2025-05-24T14:54:58.6251918Z #include <bsd/string.h>
2025-05-24T14:54:58.6251973Z #endif
2025-05-24T14:54:58.6251976Z 
2025-05-24T14:54:58.6252041Z #ifdef HAVE_BSD_UNISTD_H
2025-05-24T14:54:58.6252109Z #include <bsd/unistd.h>
2025-05-24T14:54:58.6252162Z #endif
2025-05-24T14:54:58.6252213Z 
2025-05-24T14:54:58.6252276Z #ifdef HAVE_UNISTD_H
2025-05-24T14:54:58.6252341Z #include <unistd.h>
2025-05-24T14:54:58.6252394Z #endif
2025-05-24T14:54:58.6252398Z 
2025-05-24T14:54:58.6252459Z #ifdef HAVE_STRING_H
2025-05-24T14:54:58.6252521Z #include <string.h>
2025-05-24T14:54:58.6252583Z #endif
2025-05-24T14:54:58.6252677Z 
2025-05-24T14:54:58.6252744Z #ifdef HAVE_STRINGS_H
2025-05-24T14:54:58.6252806Z #include <strings.h>
2025-05-24T14:54:58.6252864Z #endif
2025-05-24T14:54:58.6252867Z 
2025-05-24T14:54:58.6252935Z #ifdef HAVE_SYS_TYPES_H
2025-05-24T14:54:58.6253000Z #include <sys/types.h>
2025-05-24T14:54:58.6253054Z #endif
2025-05-24T14:54:58.6253060Z 
2025-05-24T14:54:58.6253132Z #ifdef HAVE_SYS_SYSMACROS_H
2025-05-24T14:54:58.6253206Z #include <sys/sysmacros.h>
2025-05-24T14:54:58.6253260Z #endif
2025-05-24T14:54:58.6253263Z 
2025-05-24T14:54:58.6253337Z #ifdef HAVE_SETPROCTITLE_H
2025-05-24T14:54:58.6253411Z #include <setproctitle.h>
2025-05-24T14:54:58.6253465Z #endif
2025-05-24T14:54:58.6253470Z 
2025-05-24T14:54:58.6253533Z #if STDC_HEADERS
2025-05-24T14:54:58.6253596Z #include <stdlib.h>
2025-05-24T14:54:58.6253657Z #include <stddef.h>
2025-05-24T14:54:58.6253710Z #endif
2025-05-24T14:54:58.6253713Z 
2025-05-24T14:54:58.6253784Z #ifdef HAVE_LINUX_TYPES_H
2025-05-24T14:54:58.6253838Z /*
2025-05-24T14:54:58.6254022Z  * This is needed as some broken header files require this to be included early
2025-05-24T14:54:58.6254082Z  */
2025-05-24T14:54:58.6254150Z #include <linux/types.h>
2025-05-24T14:54:58.6254204Z #endif
2025-05-24T14:54:58.6254208Z 
2025-05-24T14:54:58.6254272Z #ifndef HAVE_STRERROR
2025-05-24T14:54:58.6254359Z extern const char *const sys_errlist[];
2025-05-24T14:54:58.6254437Z #define strerror(i) sys_errlist[i]
2025-05-24T14:54:58.6254490Z #endif
2025-05-24T14:54:58.6254493Z 
2025-05-24T14:54:58.6254563Z #ifndef HAVE_ERRNO_DECL
2025-05-24T14:54:58.6254624Z extern int errno;
2025-05-24T14:54:58.6254678Z #endif
2025-05-24T14:54:58.6254681Z 
2025-05-24T14:54:58.6254748Z #ifndef HAVE_STRDUP
2025-05-24T14:54:58.6254817Z #define strdup rep_strdup
2025-05-24T14:54:58.6254894Z char *rep_strdup(const char *s);
2025-05-24T14:54:58.6254948Z #endif
2025-05-24T14:54:58.6254951Z 
2025-05-24T14:54:58.6255015Z #ifndef HAVE_MEMMOVE
2025-05-24T14:54:58.6255086Z #define memmove rep_memmove
2025-05-24T14:54:58.6255211Z void *rep_memmove(void *dest,const void *src,int size);
2025-05-24T14:54:58.6255269Z #endif
2025-05-24T14:54:58.6255320Z 
2025-05-24T14:54:58.6255590Z #ifndef HAVE_MEMMEM
2025-05-24T14:54:58.6255668Z #define memmem rep_memmem
2025-05-24T14:54:58.6255799Z void *rep_memmem(const void *haystack, size_t haystacklen,
2025-05-24T14:54:58.6255887Z 		 const void *needle, size_t needlelen);
2025-05-24T14:54:58.6255943Z #endif
2025-05-24T14:54:58.6255947Z 
2025-05-24T14:54:58.6256013Z #ifndef HAVE_MEMALIGN
2025-05-24T14:54:58.6256091Z #define memalign rep_memalign
2025-05-24T14:54:58.6256191Z void *rep_memalign(size_t boundary, size_t size);
2025-05-24T14:54:58.6256246Z #endif
2025-05-24T14:54:58.6256253Z 
2025-05-24T14:54:58.6256317Z #ifndef HAVE_MKTIME
2025-05-24T14:54:58.6256385Z #define mktime rep_mktime
2025-05-24T14:54:58.6256468Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.6256523Z #endif
2025-05-24T14:54:58.6256526Z 
2025-05-24T14:54:58.6256590Z #ifndef HAVE_TIMEGM
2025-05-24T14:54:58.6256660Z #define timegm rep_timegm
2025-05-24T14:54:58.6256739Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.6256798Z #endif
2025-05-24T14:54:58.6256802Z 
2025-05-24T14:54:58.6256863Z #ifndef HAVE_UTIME
2025-05-24T14:54:58.6256930Z #define utime rep_utime
2025-05-24T14:54:58.6257006Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.6257064Z #endif
2025-05-24T14:54:58.6257067Z 
2025-05-24T14:54:58.6257129Z #ifndef HAVE_UTIMES
2025-05-24T14:54:58.6257195Z #define utimes rep_utimes
2025-05-24T14:54:58.6257273Z /* prototype is in "system/time.h" */
2025-05-24T14:54:58.6257329Z #endif
2025-05-24T14:54:58.6257332Z 
2025-05-24T14:54:58.6257395Z #ifndef HAVE_STRLCPY
2025-05-24T14:54:58.6257549Z #define strlcpy rep_strlcpy
2025-05-24T14:54:58.6257677Z size_t rep_strlcpy(char *d, const char *s, size_t bufsize);
2025-05-24T14:54:58.6257732Z #endif
2025-05-24T14:54:58.6257736Z 
2025-05-24T14:54:58.6257798Z #ifndef HAVE_STRLCAT
2025-05-24T14:54:58.6257869Z #define strlcat rep_strlcat
2025-05-24T14:54:58.6258089Z size_t rep_strlcat(char *d, const char *s, size_t bufsize);
2025-05-24T14:54:58.6258145Z #endif
2025-05-24T14:54:58.6258151Z 
2025-05-24T14:54:58.6258221Z #ifndef HAVE_CLOSEFROM
2025-05-24T14:54:58.6258297Z #define closefrom rep_closefrom
2025-05-24T14:54:58.6258371Z int rep_closefrom(int lower);
2025-05-24T14:54:58.6258431Z #endif
2025-05-24T14:54:58.6258435Z 
2025-05-24T14:54:58.6258441Z 
2025-05-24T14:54:58.6258556Z #if (defined(BROKEN_STRNDUP) || !defined(HAVE_STRNDUP))
2025-05-24T14:54:58.6258619Z #undef HAVE_STRNDUP
2025-05-24T14:54:58.6258698Z #define strndup rep_strndup
2025-05-24T14:54:58.6258797Z char *rep_strndup(const char *s, size_t n);
2025-05-24T14:54:58.6258854Z #endif
2025-05-24T14:54:58.6258858Z 
2025-05-24T14:54:58.6258968Z #if (defined(BROKEN_STRNLEN) || !defined(HAVE_STRNLEN))
2025-05-24T14:54:58.6259035Z #undef HAVE_STRNLEN
2025-05-24T14:54:58.6259105Z #define strnlen rep_strnlen
2025-05-24T14:54:58.6259197Z size_t rep_strnlen(const char *s, size_t n);
2025-05-24T14:54:58.6259255Z #endif
2025-05-24T14:54:58.6259258Z 
2025-05-24T14:54:58.6259335Z #if !defined(HAVE_DECL_ENVIRON)
2025-05-24T14:54:58.6259400Z # ifdef __APPLE__
2025-05-24T14:54:58.6259469Z #   include <crt_externs.h>
2025-05-24T14:54:58.6259553Z #   define environ (*_NSGetEnviron())
2025-05-24T14:54:58.6259618Z # else /* __APPLE__ */
2025-05-24T14:54:58.6259685Z extern char **environ;
2025-05-24T14:54:58.6259749Z # endif /* __APPLE */
2025-05-24T14:54:58.6259834Z #endif /* !defined(HAVE_DECL_ENVIRON) */
2025-05-24T14:54:58.6259838Z 
2025-05-24T14:54:58.6259904Z #ifndef HAVE_SETENV
2025-05-24T14:54:58.6259976Z #define setenv rep_setenv
2025-05-24T14:54:58.6260133Z int rep_setenv(const char *name, const char *value, int overwrite);
2025-05-24T14:54:58.6260190Z #else
2025-05-24T14:54:58.6260257Z #ifndef HAVE_SETENV_DECL
2025-05-24T14:54:58.6260395Z int setenv(const char *name, const char *value, int overwrite);
2025-05-24T14:54:58.6260451Z #endif
2025-05-24T14:54:58.6260506Z #endif
2025-05-24T14:54:58.6260509Z 
2025-05-24T14:54:58.6260576Z #ifndef HAVE_UNSETENV
2025-05-24T14:54:58.6260657Z #define unsetenv rep_unsetenv
2025-05-24T14:54:58.6260824Z int rep_unsetenv(const char *name);
2025-05-24T14:54:58.6260880Z #endif
2025-05-24T14:54:58.6260883Z 
2025-05-24T14:54:58.6260949Z #ifndef HAVE_SETEUID
2025-05-24T14:54:58.6261017Z #define seteuid rep_seteuid
2025-05-24T14:54:58.6261084Z int rep_seteuid(uid_t);
2025-05-24T14:54:58.6261139Z #endif
2025-05-24T14:54:58.6261142Z 
2025-05-24T14:54:58.6261208Z #ifndef HAVE_SETEGID
2025-05-24T14:54:58.6261277Z #define setegid rep_setegid
2025-05-24T14:54:58.6261344Z int rep_setegid(gid_t);
2025-05-24T14:54:58.6261401Z #endif
2025-05-24T14:54:58.6261405Z 
2025-05-24T14:54:58.6261535Z #if (defined(USE_SETRESUID) && !defined(HAVE_SETRESUID_DECL))
2025-05-24T14:54:58.6261599Z /* stupid glibc */
2025-05-24T14:54:58.6261707Z int setresuid(uid_t ruid, uid_t euid, uid_t suid);
2025-05-24T14:54:58.6261761Z #endif
2025-05-24T14:54:58.6261890Z #if (defined(USE_SETRESUID) && !defined(HAVE_SETRESGID_DECL))
2025-05-24T14:54:58.6262024Z int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
2025-05-24T14:54:58.6262087Z #endif
2025-05-24T14:54:58.6262091Z 
2025-05-24T14:54:58.6262154Z #ifndef HAVE_CHOWN
2025-05-24T14:54:58.6262222Z #define chown rep_chown
2025-05-24T14:54:58.6262336Z int rep_chown(const char *path, uid_t uid, gid_t gid);
2025-05-24T14:54:58.6262395Z #endif
2025-05-24T14:54:58.6262399Z 
2025-05-24T14:54:58.6262463Z #ifndef HAVE_CHROOT
2025-05-24T14:54:58.6262532Z #define chroot rep_chroot
2025-05-24T14:54:58.6262614Z int rep_chroot(const char *dirname);
2025-05-24T14:54:58.6262668Z #endif
2025-05-24T14:54:58.6262672Z 
2025-05-24T14:54:58.6262732Z #ifndef HAVE_LINK
2025-05-24T14:54:58.6262850Z #define link rep_link
2025-05-24T14:54:58.6262962Z int rep_link(const char *oldpath, const char *newpath);
2025-05-24T14:54:58.6263017Z #endif
2025-05-24T14:54:58.6263020Z 
2025-05-24T14:54:58.6263089Z #ifndef HAVE_READLINK
2025-05-24T14:54:58.6263161Z #define readlink rep_readlink
2025-05-24T14:54:58.6263388Z ssize_t rep_readlink(const char *path, char *buf, size_t bufsize);
2025-05-24T14:54:58.6263446Z #endif
2025-05-24T14:54:58.6263452Z 
2025-05-24T14:54:58.6263520Z #ifndef HAVE_SYMLINK
2025-05-24T14:54:58.6263590Z #define symlink rep_symlink
2025-05-24T14:54:58.6263713Z int rep_symlink(const char *oldpath, const char *newpath);
2025-05-24T14:54:58.6263772Z #endif
2025-05-24T14:54:58.6263776Z 
2025-05-24T14:54:58.6263840Z #ifndef HAVE_REALPATH
2025-05-24T14:54:58.6263912Z #define realpath rep_realpath
2025-05-24T14:54:58.6264034Z char *rep_realpath(const char *path, char *resolved_path);
2025-05-24T14:54:58.6264093Z #endif
2025-05-24T14:54:58.6264097Z 
2025-05-24T14:54:58.6264161Z #ifndef HAVE_LCHOWN
2025-05-24T14:54:58.6264231Z #define lchown rep_lchown
2025-05-24T14:54:58.6264344Z int rep_lchown(const char *fname,uid_t uid,gid_t gid);
2025-05-24T14:54:58.6264398Z #endif
2025-05-24T14:54:58.6264401Z 
2025-05-24T14:54:58.6264465Z #ifdef HAVE_UNIX_H
2025-05-24T14:54:58.6264528Z #include <unix.h>
2025-05-24T14:54:58.6264586Z #endif
2025-05-24T14:54:58.6264590Z 
2025-05-24T14:54:58.6264659Z #ifndef HAVE_SETLINEBUF
2025-05-24T14:54:58.6264739Z #define setlinebuf rep_setlinebuf
2025-05-24T14:54:58.6264817Z void rep_setlinebuf(FILE *);
2025-05-24T14:54:58.6264873Z #endif
2025-05-24T14:54:58.6264876Z 
2025-05-24T14:54:58.6264942Z #ifndef HAVE_STRCASESTR
2025-05-24T14:54:58.6265021Z #define strcasestr rep_strcasestr
2025-05-24T14:54:58.6265160Z char *rep_strcasestr(const char *haystack, const char *needle);
2025-05-24T14:54:58.6265215Z #endif
2025-05-24T14:54:58.6265218Z 
2025-05-24T14:54:58.6265284Z #ifndef HAVE_STRSEP
2025-05-24T14:54:58.6265465Z #define strsep rep_strsep
2025-05-24T14:54:58.6265572Z char *rep_strsep(char **pps, const char *delim);
2025-05-24T14:54:58.6265629Z #endif
2025-05-24T14:54:58.6265633Z 
2025-05-24T14:54:58.6265702Z #ifndef HAVE_STRTOK_R
2025-05-24T14:54:58.6265774Z #define strtok_r rep_strtok_r
2025-05-24T14:54:58.6265910Z char *rep_strtok_r(char *s, const char *delim, char **save_ptr);
2025-05-24T14:54:58.6265972Z #endif
2025-05-24T14:54:58.6265976Z 
2025-05-24T14:54:58.6265979Z 
2025-05-24T14:54:58.6266051Z 
2025-05-24T14:54:58.6266117Z #ifndef HAVE_STRTOLL
2025-05-24T14:54:58.6266189Z #define strtoll rep_strtoll
2025-05-24T14:54:58.6266342Z long long int rep_strtoll(const char *str, char **endptr, int base);
2025-05-24T14:54:58.6266399Z #else
2025-05-24T14:54:58.6266463Z #ifdef HAVE_BSD_STRTOLL
2025-05-24T14:54:58.6266533Z #define strtoll rep_strtoll
2025-05-24T14:54:58.6266677Z long long int rep_strtoll(const char *str, char **endptr, int base);
2025-05-24T14:54:58.6266732Z #endif
2025-05-24T14:54:58.6266787Z #endif
2025-05-24T14:54:58.6266790Z 
2025-05-24T14:54:58.6266859Z #ifndef HAVE_STRTOULL
2025-05-24T14:54:58.6266931Z #define strtoull rep_strtoull
2025-05-24T14:54:58.6267107Z unsigned long long int rep_strtoull(const char *str, char **endptr, int base);
2025-05-24T14:54:58.6267166Z #else
2025-05-24T14:54:58.6267300Z #ifdef HAVE_BSD_STRTOLL /* yes, it's not HAVE_BSD_STRTOULL */
2025-05-24T14:54:58.6267375Z #define strtoull rep_strtoull
2025-05-24T14:54:58.6267547Z unsigned long long int rep_strtoull(const char *str, char **endptr, int base);
2025-05-24T14:54:58.6267606Z #endif
2025-05-24T14:54:58.6267662Z #endif
2025-05-24T14:54:58.6267665Z 
2025-05-24T14:54:58.6267732Z #ifndef HAVE_FTRUNCATE
2025-05-24T14:54:58.6267807Z #define ftruncate rep_ftruncate
2025-05-24T14:54:58.6267880Z int rep_ftruncate(int,off_t);
2025-05-24T14:54:58.6267935Z #endif
2025-05-24T14:54:58.6267939Z 
2025-05-24T14:54:58.6268004Z #ifndef HAVE_INITGROUPS
2025-05-24T14:54:58.6268085Z #define initgroups rep_initgroups
2025-05-24T14:54:58.6268173Z int rep_initgroups(char *name, gid_t id);
2025-05-24T14:54:58.6268291Z #endif
2025-05-24T14:54:58.6268294Z 
2025-05-24T14:54:58.6268393Z #if !defined(HAVE_BZERO) && defined(HAVE_MEMSET)
2025-05-24T14:54:58.6268476Z #define bzero(a,b) memset((a),'\0',(b))
2025-05-24T14:54:58.6268531Z #endif
2025-05-24T14:54:58.6268535Z 
2025-05-24T14:54:58.6268597Z #ifndef HAVE_DLERROR
2025-05-24T14:54:58.6268771Z #define dlerror rep_dlerror
2025-05-24T14:54:58.6268842Z char *rep_dlerror(void);
2025-05-24T14:54:58.6268901Z #endif
2025-05-24T14:54:58.6268904Z 
2025-05-24T14:54:58.6268975Z #ifndef HAVE_DLOPEN
2025-05-24T14:54:58.6269046Z #define dlopen rep_dlopen
2025-05-24T14:54:58.6269124Z #ifdef DLOPEN_TAKES_UNSIGNED_FLAGS
2025-05-24T14:54:58.6269243Z void *rep_dlopen(const char *name, unsigned int flags);
2025-05-24T14:54:58.6269303Z #else
2025-05-24T14:54:58.6269401Z void *rep_dlopen(const char *name, int flags);
2025-05-24T14:54:58.6269456Z #endif
2025-05-24T14:54:58.6269518Z #endif
2025-05-24T14:54:58.6269521Z 
2025-05-24T14:54:58.6269583Z #ifndef HAVE_DLSYM
2025-05-24T14:54:58.6269657Z #define dlsym rep_dlsym
2025-05-24T14:54:58.6269760Z void *rep_dlsym(void *handle, const char *symbol);
2025-05-24T14:54:58.6269815Z #endif
2025-05-24T14:54:58.6269818Z 
2025-05-24T14:54:58.6269882Z #ifndef HAVE_DLCLOSE
2025-05-24T14:54:58.6269953Z #define dlclose rep_dlclose
2025-05-24T14:54:58.6270035Z int rep_dlclose(void *handle);
2025-05-24T14:54:58.6270091Z #endif
2025-05-24T14:54:58.6270094Z 
2025-05-24T14:54:58.6270163Z #ifndef HAVE_SOCKETPAIR
2025-05-24T14:54:58.6270244Z #define socketpair rep_socketpair
2025-05-24T14:54:58.6270327Z /* prototype is in system/network.h */
2025-05-24T14:54:58.6270383Z #endif
2025-05-24T14:54:58.6270387Z 
2025-05-24T14:54:58.6270564Z /* for old gcc releases that don't have the feature test macro __has_attribute */
2025-05-24T14:54:58.6270632Z #ifndef __has_attribute
2025-05-24T14:54:58.6270705Z #define __has_attribute(x) 0
2025-05-24T14:54:58.6270759Z #endif
2025-05-24T14:54:58.6270763Z 
2025-05-24T14:54:58.6270835Z #ifndef PRINTF_ATTRIBUTE
2025-05-24T14:54:58.6270926Z #if __has_attribute(format) || (__GNUC__ >= 3)
2025-05-24T14:54:58.6271074Z /** Use gcc attribute to check printf fns.  a1 is the 1-based index of
2025-05-24T14:54:58.6271229Z  * the parameter containing the format, and a2 the index of the first
2025-05-24T14:54:58.6271364Z  * argument. Note that some gcc 2.x versions don't handle this
2025-05-24T14:54:58.6271427Z  * properly **/
2025-05-24T14:54:58.6271598Z #define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))
2025-05-24T14:54:58.6271707Z #else
2025-05-24T14:54:58.6271789Z #define PRINTF_ATTRIBUTE(a1, a2)
2025-05-24T14:54:58.6271843Z #endif
2025-05-24T14:54:58.6271902Z #endif
2025-05-24T14:54:58.6271906Z 
2025-05-24T14:54:58.6271972Z #ifndef _DEPRECATED_
2025-05-24T14:54:58.6272070Z #if __has_attribute(deprecated) || (__GNUC__ >= 3)
2025-05-24T14:54:58.6272174Z #define _DEPRECATED_ __attribute__ ((deprecated))
2025-05-24T14:54:58.6272235Z #else
2025-05-24T14:54:58.6272299Z #define _DEPRECATED_
2025-05-24T14:54:58.6272356Z #endif
2025-05-24T14:54:58.6272417Z #endif
2025-05-24T14:54:58.6272420Z 
2025-05-24T14:54:58.6272543Z #if !defined(HAVE_VDPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6272619Z #define vdprintf rep_vdprintf
2025-05-24T14:54:58.6272801Z int rep_vdprintf(int fd, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);
2025-05-24T14:54:58.6272856Z #endif
2025-05-24T14:54:58.6272859Z 
2025-05-24T14:54:58.6272976Z #if !defined(HAVE_DPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6273051Z #define dprintf rep_dprintf
2025-05-24T14:54:58.6273206Z int rep_dprintf(int fd, const char *format, ...) PRINTF_ATTRIBUTE(2,3);
2025-05-24T14:54:58.6273260Z #endif
2025-05-24T14:54:58.6273263Z 
2025-05-24T14:54:58.6273383Z #if !defined(HAVE_VASPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6273460Z #define vasprintf rep_vasprintf
2025-05-24T14:54:58.6273649Z int rep_vasprintf(char **ptr, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);
2025-05-24T14:54:58.6273706Z #endif
2025-05-24T14:54:58.6273774Z 
2025-05-24T14:54:58.6273893Z #if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6273969Z #define snprintf rep_snprintf
2025-05-24T14:54:58.6274125Z int rep_snprintf(char *,size_t ,const char *, ...) PRINTF_ATTRIBUTE(3,4);
2025-05-24T14:54:58.6274182Z #endif
2025-05-24T14:54:58.6274260Z 
2025-05-24T14:54:58.6274381Z #if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6274457Z #define vsnprintf rep_vsnprintf
2025-05-24T14:54:58.6274630Z int rep_vsnprintf(char *,size_t ,const char *, va_list ap) PRINTF_ATTRIBUTE(3,0);
2025-05-24T14:54:58.6274688Z #endif
2025-05-24T14:54:58.6274692Z 
2025-05-24T14:54:58.6274805Z #if !defined(HAVE_ASPRINTF) || !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6274877Z #define asprintf rep_asprintf
2025-05-24T14:54:58.6275020Z int rep_asprintf(char **,const char *, ...) PRINTF_ATTRIBUTE(2,3);
2025-05-24T14:54:58.6275075Z #endif
2025-05-24T14:54:58.6275078Z 
2025-05-24T14:54:58.6275151Z #if !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6275226Z #ifdef REPLACE_BROKEN_PRINTF
2025-05-24T14:54:58.6275284Z /*
2025-05-24T14:54:58.6275465Z  * We do not redefine printf by default
2025-05-24T14:54:58.6275554Z  * as it breaks the build if system headers
2025-05-24T14:54:58.6275646Z  * use __attribute__((format(printf, 3, 0)))
2025-05-24T14:54:58.6275758Z  * instead of __attribute__((format(__printf__, 3, 0)))
2025-05-24T14:54:58.6275815Z  */
2025-05-24T14:54:58.6275895Z #define printf rep_printf
2025-05-24T14:54:58.6275950Z #endif
2025-05-24T14:54:58.6276069Z int rep_printf(const char *, ...) PRINTF_ATTRIBUTE(1,2);
2025-05-24T14:54:58.6276124Z #endif
2025-05-24T14:54:58.6276128Z 
2025-05-24T14:54:58.6276207Z #if !defined(HAVE_C99_VSNPRINTF)
2025-05-24T14:54:58.6276280Z #define fprintf rep_fprintf
2025-05-24T14:54:58.6276435Z int rep_fprintf(FILE *stream, const char *, ...) PRINTF_ATTRIBUTE(2,3);
2025-05-24T14:54:58.6276495Z #endif
2025-05-24T14:54:58.6276499Z 
2025-05-24T14:54:58.6276561Z #ifndef HAVE_VSYSLOG
2025-05-24T14:54:58.6276626Z #ifdef HAVE_SYSLOG
2025-05-24T14:54:58.6276698Z #define vsyslog rep_vsyslog
2025-05-24T14:54:58.6276945Z void rep_vsyslog (int facility_priority, const char *format, va_list arglist) PRINTF_ATTRIBUTE(2,0);
2025-05-24T14:54:58.6277000Z #endif
2025-05-24T14:54:58.6277054Z #endif
2025-05-24T14:54:58.6277057Z 
2025-05-24T14:54:58.6277188Z /* we used to use these fns, but now we have good replacements
2025-05-24T14:54:58.6277336Z    for snprintf and vsnprintf */
2025-05-24T14:54:58.6277405Z #define slprintf snprintf
2025-05-24T14:54:58.6277409Z 
2025-05-24T14:54:58.6277412Z 
2025-05-24T14:54:58.6277478Z #ifndef HAVE_VA_COPY
2025-05-24T14:54:58.6277538Z #undef va_copy
2025-05-24T14:54:58.6277603Z #ifdef HAVE___VA_COPY
2025-05-24T14:54:58.6277699Z #define va_copy(dest, src) __va_copy(dest, src)
2025-05-24T14:54:58.6277758Z #else
2025-05-24T14:54:58.6277842Z #define va_copy(dest, src) (dest) = (src)
2025-05-24T14:54:58.6277896Z #endif
2025-05-24T14:54:58.6277956Z #endif
2025-05-24T14:54:58.6277961Z 
2025-05-24T14:54:58.6278027Z #ifndef HAVE_VOLATILE
2025-05-24T14:54:58.6278088Z #define volatile
2025-05-24T14:54:58.6278143Z #endif
2025-05-24T14:54:58.6278147Z 
2025-05-24T14:54:58.6278225Z #ifndef HAVE_COMPARISON_FN_T
2025-05-24T14:54:58.6278350Z typedef int (*comparison_fn_t)(const void *, const void *);
2025-05-24T14:54:58.6278408Z #endif
2025-05-24T14:54:58.6278411Z 
2025-05-24T14:54:58.6278487Z #ifndef HAVE_WORKING_STRPTIME
2025-05-24T14:54:58.6278561Z #define strptime rep_strptime
2025-05-24T14:54:58.6278619Z struct tm;
2025-05-24T14:54:58.6278781Z char *rep_strptime(const char *buf, const char *format, struct tm *tm);
2025-05-24T14:54:58.6278838Z #endif
2025-05-24T14:54:58.6278841Z 
2025-05-24T14:54:58.6278903Z #ifndef HAVE_DUP2
2025-05-24T14:54:58.6278969Z #define dup2 rep_dup2
2025-05-24T14:54:58.6279050Z int rep_dup2(int oldfd, int newfd);
2025-05-24T14:54:58.6279107Z #endif
2025-05-24T14:54:58.6279110Z 
2025-05-24T14:54:58.6279207Z /* Load header file for dynamic linking stuff */
2025-05-24T14:54:58.6279340Z #ifdef HAVE_DLFCN_H
2025-05-24T14:54:58.6279403Z #include <dlfcn.h>
2025-05-24T14:54:58.6279458Z #endif
2025-05-24T14:54:58.6279461Z 
2025-05-24T14:54:58.6279521Z #ifndef RTLD_LAZY
2025-05-24T14:54:58.6279588Z #define RTLD_LAZY 0
2025-05-24T14:54:58.6279642Z #endif
2025-05-24T14:54:58.6279705Z #ifndef RTLD_NOW
2025-05-24T14:54:58.6279870Z #define RTLD_NOW 0
2025-05-24T14:54:58.6279927Z #endif
2025-05-24T14:54:58.6279992Z #ifndef RTLD_GLOBAL
2025-05-24T14:54:58.6280054Z #define RTLD_GLOBAL 0
2025-05-24T14:54:58.6280113Z #endif
2025-05-24T14:54:58.6280117Z 
2025-05-24T14:54:58.6280187Z #ifndef HAVE_SECURE_MKSTEMP
2025-05-24T14:54:58.6280274Z #define mkstemp(path) rep_mkstemp(path)
2025-05-24T14:54:58.6280353Z int rep_mkstemp(char *temp);
2025-05-24T14:54:58.6280408Z #endif
2025-05-24T14:54:58.6280411Z 
2025-05-24T14:54:58.6280475Z #ifndef HAVE_MKDTEMP
2025-05-24T14:54:58.6280546Z #define mkdtemp rep_mkdtemp
2025-05-24T14:54:58.6280625Z char *rep_mkdtemp(char *template);
2025-05-24T14:54:58.6280680Z #endif
2025-05-24T14:54:58.6280683Z 
2025-05-24T14:54:58.6280746Z #ifndef HAVE_PREAD
2025-05-24T14:54:58.6280817Z #define pread rep_pread
2025-05-24T14:54:58.6280973Z ssize_t rep_pread(int __fd, void *__buf, size_t __nbytes, off_t __offset);
2025-05-24T14:54:58.6281055Z #define LIBREPLACE_PREAD_REPLACED 1
2025-05-24T14:54:58.6281117Z #else
2025-05-24T14:54:58.6281199Z #define LIBREPLACE_PREAD_NOT_REPLACED 1
2025-05-24T14:54:58.6281256Z #endif
2025-05-24T14:54:58.6281259Z 
2025-05-24T14:54:58.6281323Z #ifndef HAVE_PWRITE
2025-05-24T14:54:58.6281398Z #define pwrite rep_pwrite
2025-05-24T14:54:58.6281565Z ssize_t rep_pwrite(int __fd, const void *__buf, size_t __nbytes, off_t __offset);
2025-05-24T14:54:58.6281645Z #define LIBREPLACE_PWRITE_REPLACED 1
2025-05-24T14:54:58.6281709Z #else
2025-05-24T14:54:58.6281797Z #define LIBREPLACE_PWRITE_NOT_REPLACED 1
2025-05-24T14:54:58.6281851Z #endif
2025-05-24T14:54:58.6281854Z 
2025-05-24T14:54:58.6281973Z #if !defined(HAVE_INET_NTOA) || defined(REPLACE_INET_NTOA)
2025-05-24T14:54:58.6282054Z #define inet_ntoa rep_inet_ntoa
2025-05-24T14:54:58.6282135Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6282191Z #endif
2025-05-24T14:54:58.6282194Z 
2025-05-24T14:54:58.6282264Z #ifndef HAVE_INET_PTON
2025-05-24T14:54:58.6282338Z #define inet_pton rep_inet_pton
2025-05-24T14:54:58.6282422Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6282480Z #endif
2025-05-24T14:54:58.6282532Z 
2025-05-24T14:54:58.6282599Z #ifndef HAVE_INET_NTOP
2025-05-24T14:54:58.6282673Z #define inet_ntop rep_inet_ntop
2025-05-24T14:54:58.6282752Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6282811Z #endif
2025-05-24T14:54:58.6282814Z 
2025-05-24T14:54:58.6282877Z #ifndef HAVE_INET_ATON
2025-05-24T14:54:58.6282948Z #define inet_aton rep_inet_aton
2025-05-24T14:54:58.6283029Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6283083Z #endif
2025-05-24T14:54:58.6283087Z 
2025-05-24T14:54:58.6283147Z #ifndef HAVE_CONNECT
2025-05-24T14:54:58.6283220Z #define connect rep_connect
2025-05-24T14:54:58.6283302Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6283356Z #endif
2025-05-24T14:54:58.6283360Z 
2025-05-24T14:54:58.6283432Z #ifndef HAVE_GETHOSTBYNAME
2025-05-24T14:54:58.6283519Z #define gethostbyname rep_gethostbyname
2025-05-24T14:54:58.6283602Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6283656Z #endif
2025-05-24T14:54:58.6283660Z 
2025-05-24T14:54:58.6283730Z #ifndef HAVE_GETIFADDRS
2025-05-24T14:54:58.6283811Z #define getifaddrs rep_getifaddrs
2025-05-24T14:54:58.6283888Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6283943Z #endif
2025-05-24T14:54:58.6283946Z 
2025-05-24T14:54:58.6284019Z #ifndef HAVE_FREEIFADDRS
2025-05-24T14:54:58.6284100Z #define freeifaddrs rep_freeifaddrs
2025-05-24T14:54:58.6284183Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6284240Z #endif
2025-05-24T14:54:58.6284243Z 
2025-05-24T14:54:58.6284320Z #ifndef HAVE_GET_CURRENT_DIR_NAME
2025-05-24T14:54:58.6284492Z #define get_current_dir_name rep_get_current_dir_name
2025-05-24T14:54:58.6284580Z char *rep_get_current_dir_name(void);
2025-05-24T14:54:58.6284635Z #endif
2025-05-24T14:54:58.6284639Z 
2025-05-24T14:54:58.6284781Z #if (!defined(HAVE_STRERROR_R) || !defined(STRERROR_R_XSI_NOT_GNU))
2025-05-24T14:54:58.6284932Z #define strerror_r rep_strerror_r
2025-05-24T14:54:58.6285060Z int rep_strerror_r(int errnum, char *buf, size_t buflen);
2025-05-24T14:54:58.6285118Z #endif
2025-05-24T14:54:58.6285121Z 
2025-05-24T14:54:58.6285197Z #if !defined(HAVE_CLOCK_GETTIME)
2025-05-24T14:54:58.6285280Z #define clock_gettime rep_clock_gettime
2025-05-24T14:54:58.6285506Z #endif
2025-05-24T14:54:58.6285513Z 
2025-05-24T14:54:58.6285639Z #ifdef HAVE_LIMITS_H
2025-05-24T14:54:58.6285726Z #include <limits.h>
2025-05-24T14:54:58.6285784Z #endif
2025-05-24T14:54:58.6285787Z 
2025-05-24T14:54:58.6285858Z #ifdef HAVE_SYS_PARAM_H
2025-05-24T14:54:58.6285928Z #include <sys/param.h>
2025-05-24T14:54:58.6285987Z #endif
2025-05-24T14:54:58.6285993Z 
2025-05-24T14:54:58.6286113Z /* The extra casts work around common compiler bugs.  */
2025-05-24T14:54:58.6286203Z #define _TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
2025-05-24T14:54:58.6286345Z /* The outer cast is needed to work around a bug in Cray C 5.0.3.0.
2025-05-24T14:54:58.6286446Z    It is necessary at least when t == time_t.  */
2025-05-24T14:54:58.6286542Z #define _TYPE_MINIMUM(t) ((t) (_TYPE_SIGNED (t) \
2025-05-24T14:54:58.6286640Z   			      ? ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1) : (t) 0))
2025-05-24T14:54:58.6286768Z #define _TYPE_MAXIMUM(t) ((t) (~ (t) 0 - _TYPE_MINIMUM (t)))
2025-05-24T14:54:58.6286772Z 
2025-05-24T14:54:58.6286835Z #ifndef UINT16_MAX
2025-05-24T14:54:58.6286904Z #define UINT16_MAX 65535
2025-05-24T14:54:58.6286962Z #endif
2025-05-24T14:54:58.6286966Z 
2025-05-24T14:54:58.6287027Z #ifndef UINT32_MAX
2025-05-24T14:54:58.6287099Z #define UINT32_MAX (4294967295U)
2025-05-24T14:54:58.6287157Z #endif
2025-05-24T14:54:58.6287161Z 
2025-05-24T14:54:58.6287220Z #ifndef UINT64_MAX
2025-05-24T14:54:58.6287297Z #define UINT64_MAX ((uint64_t)-1)
2025-05-24T14:54:58.6287353Z #endif
2025-05-24T14:54:58.6287356Z 
2025-05-24T14:54:58.6287421Z #ifndef INT64_MAX
2025-05-24T14:54:58.6287494Z #define INT64_MAX 9223372036854775807LL
2025-05-24T14:54:58.6287547Z #endif
2025-05-24T14:54:58.6287550Z 
2025-05-24T14:54:58.6287617Z #ifndef CHAR_BIT
2025-05-24T14:54:58.6287677Z #define CHAR_BIT 8
2025-05-24T14:54:58.6287731Z #endif
2025-05-24T14:54:58.6287814Z 
2025-05-24T14:54:58.6287882Z #ifndef INT32_MAX
2025-05-24T14:54:58.6287962Z #define INT32_MAX _TYPE_MAXIMUM(int32_t)
2025-05-24T14:54:58.6288016Z #endif
2025-05-24T14:54:58.6288019Z 
2025-05-24T14:54:58.6288084Z #ifdef HAVE_STDBOOL_H
2025-05-24T14:54:58.6288152Z #include <stdbool.h>
2025-05-24T14:54:58.6288206Z #endif
2025-05-24T14:54:58.6288210Z 
2025-05-24T14:54:58.6288270Z #ifndef HAVE_BOOL
2025-05-24T14:54:58.6288348Z #error Need a real boolean type
2025-05-24T14:54:58.6288404Z #endif
2025-05-24T14:54:58.6288407Z 
2025-05-24T14:54:58.6288480Z #if !defined(HAVE_INTPTR_T)
2025-05-24T14:54:58.6288550Z #define __intptr_t_defined
2025-05-24T14:54:58.6288609Z #endif
2025-05-24T14:54:58.6288612Z 
2025-05-24T14:54:58.6288683Z #if !defined(HAVE_UINTPTR_T)
2025-05-24T14:54:58.6288753Z #define __uintptr_t_defined
2025-05-24T14:54:58.6288813Z #endif
2025-05-24T14:54:58.6288820Z 
2025-05-24T14:54:58.6288894Z #if !defined(HAVE_PTRDIFF_T)
2025-05-24T14:54:58.6288950Z #endif
2025-05-24T14:54:58.6288955Z 
2025-05-24T14:54:58.6289015Z /*
2025-05-24T14:54:58.6289153Z  * to prevent <rpcsvc/yp_prot.h> from doing a redefine of 'bool'
2025-05-24T14:54:58.6289211Z  *
2025-05-24T14:54:58.6289315Z  * IRIX, HPUX, MacOS 10 and Solaris need BOOL_DEFINED
2025-05-24T14:54:58.6289387Z  * Tru64 needs _BOOL_EXISTS
2025-05-24T14:54:58.6289458Z  * AIX needs _BOOL,_TRUE,_FALSE
2025-05-24T14:54:58.6289514Z  */
2025-05-24T14:54:58.6289581Z #ifndef BOOL_DEFINED
2025-05-24T14:54:58.6289644Z #define BOOL_DEFINED
2025-05-24T14:54:58.6289698Z #endif
2025-05-24T14:54:58.6289761Z #ifndef _BOOL_EXISTS
2025-05-24T14:54:58.6289893Z #define _BOOL_EXISTS
2025-05-24T14:54:58.6289947Z #endif
2025-05-24T14:54:58.6290004Z #ifndef _BOOL
2025-05-24T14:54:58.6290064Z #define _BOOL
2025-05-24T14:54:58.6290118Z #endif
2025-05-24T14:54:58.6290120Z 
2025-05-24T14:54:58.6290198Z #ifndef __bool_true_false_are_defined
2025-05-24T14:54:58.6290376Z #define __bool_true_false_are_defined
2025-05-24T14:54:58.6290437Z #endif
2025-05-24T14:54:58.6290442Z 
2025-05-24T14:54:58.6290501Z #ifndef true
2025-05-24T14:54:58.6290562Z #define true (1)
2025-05-24T14:54:58.6290620Z #endif
2025-05-24T14:54:58.6290677Z #ifndef false
2025-05-24T14:54:58.6290737Z #define false (0)
2025-05-24T14:54:58.6290791Z #endif
2025-05-24T14:54:58.6290794Z 
2025-05-24T14:54:58.6290856Z #ifndef _TRUE
2025-05-24T14:54:58.6290916Z #define _TRUE true
2025-05-24T14:54:58.6290970Z #endif
2025-05-24T14:54:58.6291032Z #ifndef _FALSE
2025-05-24T14:54:58.6291095Z #define _FALSE false
2025-05-24T14:54:58.6291151Z #endif
2025-05-24T14:54:58.6291154Z 
2025-05-24T14:54:58.6291227Z #ifndef HAVE_FUNCTION_MACRO
2025-05-24T14:54:58.6291297Z #ifdef HAVE_func_MACRO
2025-05-24T14:54:58.6291368Z #define __FUNCTION__ __func__
2025-05-24T14:54:58.6291428Z #else
2025-05-24T14:54:58.6291503Z #define __FUNCTION__ ("")
2025-05-24T14:54:58.6291559Z #endif
2025-05-24T14:54:58.6291615Z #endif
2025-05-24T14:54:58.6291621Z 
2025-05-24T14:54:58.6291624Z 
2025-05-24T14:54:58.6291683Z #ifndef MIN
2025-05-24T14:54:58.6291767Z #define MIN(a,b) ((a)<(b)?(a):(b))
2025-05-24T14:54:58.6291825Z #endif
2025-05-24T14:54:58.6291828Z 
2025-05-24T14:54:58.6291888Z #ifndef MAX
2025-05-24T14:54:58.6291965Z #define MAX(a,b) ((a)>(b)?(a):(b))
2025-05-24T14:54:58.6292022Z #endif
2025-05-24T14:54:58.6292025Z 
2025-05-24T14:54:58.6292095Z #if !defined(HAVE_VOLATILE)
2025-05-24T14:54:58.6292162Z #define volatile
2025-05-24T14:54:58.6292220Z #endif
2025-05-24T14:54:58.6292223Z 
2025-05-24T14:54:58.6292278Z /**
2025-05-24T14:54:58.6292423Z   this is a warning hack. The idea is to use this everywhere that we
2025-05-24T14:54:58.6292573Z   get the "discarding const" warning from gcc. That doesn't actually
2025-05-24T14:54:58.6292704Z   fix the problem of course, but it means that when we do get to
2025-05-24T14:54:58.6292825Z   cleaning them up we can do it by searching the code for
2025-05-24T14:54:58.6292893Z   discard_const.
2025-05-24T14:54:58.6292900Z 
2025-05-24T14:54:58.6293045Z   It also means that other error types aren't as swamped by the noise
2025-05-24T14:54:58.6293259Z   of hundreds of const warnings, so we are more likely to notice when
2025-05-24T14:54:58.6293328Z   we get new errors.
2025-05-24T14:54:58.6293332Z 
2025-05-24T14:54:58.6293456Z   Please only add more uses of this macro when you find it
2025-05-24T14:54:58.6293599Z   _really_ hard to fix const warnings. Our aim is to eventually use
2025-05-24T14:54:58.6293687Z   this function in only a very few places.
2025-05-24T14:54:58.6293695Z 
2025-05-24T14:54:58.6293864Z   Also, please call this via the discard_const_p() macro interface, as that
2025-05-24T14:54:58.6293939Z   makes the return type safe.
2025-05-24T14:54:58.6293994Z */
2025-05-24T14:54:58.6294119Z #define discard_const(ptr) ((void *)((uintptr_t)(ptr)))
2025-05-24T14:54:58.6294123Z 
2025-05-24T14:54:58.6294208Z /** Type-safe version of discard_const */
2025-05-24T14:54:58.6294351Z #define discard_const_p(type, ptr) ((type *)discard_const(ptr))
2025-05-24T14:54:58.6294356Z 
2025-05-24T14:54:58.6294424Z #ifndef __STRING
2025-05-24T14:54:58.6294495Z #define __STRING(x)    #x
2025-05-24T14:54:58.6294551Z #endif
2025-05-24T14:54:58.6294554Z 
2025-05-24T14:54:58.6294627Z #ifndef __STRINGSTRING
2025-05-24T14:54:58.6294706Z #define __STRINGSTRING(x) __STRING(x)
2025-05-24T14:54:58.6294763Z #endif
2025-05-24T14:54:58.6294766Z 
2025-05-24T14:54:58.6294829Z #ifndef __LINESTR__
2025-05-24T14:54:58.6294925Z #define __LINESTR__ __STRINGSTRING(__LINE__)
2025-05-24T14:54:58.6294982Z #endif
2025-05-24T14:54:58.6294985Z 
2025-05-24T14:54:58.6295049Z #ifndef __location__
2025-05-24T14:54:58.6295193Z #define __location__ __FILE__ ":" __LINESTR__
2025-05-24T14:54:58.6295251Z #endif
2025-05-24T14:54:58.6295255Z 
2025-05-24T14:54:58.6295308Z /**
2025-05-24T14:54:58.6295556Z  * Zero a structure.
2025-05-24T14:54:58.6295629Z  */
2025-05-24T14:54:58.6295794Z #define ZERO_STRUCT(x) memset_s((char *)&(x), sizeof(x), 0, sizeof(x))
2025-05-24T14:54:58.6295963Z 
2025-05-24T14:54:58.6296070Z /**
2025-05-24T14:54:58.6296222Z  * Zero a structure given a pointer to the structure.
2025-05-24T14:54:58.6296281Z  */
2025-05-24T14:54:58.6296364Z #define ZERO_STRUCTP(x) do { \
2025-05-24T14:54:58.6296433Z 	if ((x) != NULL) { \
2025-05-24T14:54:58.6296548Z 		memset_s((char *)(x), sizeof(*(x)), 0, sizeof(*(x))); \
2025-05-24T14:54:58.6296603Z 	} \
2025-05-24T14:54:58.6296662Z } while(0)
2025-05-24T14:54:58.6296666Z 
2025-05-24T14:54:58.6296726Z /**
2025-05-24T14:54:58.6296882Z  * Zero a structure given a pointer to the structure - no zero check
2025-05-24T14:54:58.6296937Z  */
2025-05-24T14:54:58.6297115Z #define ZERO_STRUCTPN(x) memset_s((char *)(x), sizeof(*(x)), 0, sizeof(*(x)))
2025-05-24T14:54:58.6297121Z 
2025-05-24T14:54:58.6297176Z /**
2025-05-24T14:54:58.6297335Z  * Zero an array - note that sizeof(array) must work - ie. it must not be a
2025-05-24T14:54:58.6297397Z  * pointer
2025-05-24T14:54:58.6297457Z  */
2025-05-24T14:54:58.6297603Z #define ZERO_ARRAY(x) memset_s((char *)(x), sizeof(x), 0, sizeof(x))
2025-05-24T14:54:58.6297607Z 
2025-05-24T14:54:58.6297664Z /**
2025-05-24T14:54:58.6297745Z  * Zero a given len of an array
2025-05-24T14:54:58.6297802Z  */
2025-05-24T14:54:58.6297931Z #define ZERO_ARRAY_LEN(x, l) memset_s((char *)(x), (l), 0, (l))
2025-05-24T14:54:58.6297936Z 
2025-05-24T14:54:58.6297996Z /**
2025-05-24T14:54:58.6298165Z  * Explicitly zero data from memory. This is guaranteed to be not optimized
2025-05-24T14:54:58.6298225Z  * away.
2025-05-24T14:54:58.6298280Z  */
2025-05-24T14:54:58.6298422Z #define BURN_DATA(x) memset_s((char *)&(x), sizeof(x), 0, sizeof(x))
2025-05-24T14:54:58.6298426Z 
2025-05-24T14:54:58.6298484Z /**
2025-05-24T14:54:58.6298645Z  * Explicitly zero data from memory. This is guaranteed to be not optimized
2025-05-24T14:54:58.6298710Z  * away.
2025-05-24T14:54:58.6298765Z  */
2025-05-24T14:54:58.6298896Z #define BURN_DATA_SIZE(x, s) memset_s((char *)&(x), (s), 0, (s))
2025-05-24T14:54:58.6298900Z 
2025-05-24T14:54:58.6298960Z /**
2025-05-24T14:54:58.6299129Z  * Explicitly zero data from memory. This is guaranteed to be not optimized
2025-05-24T14:54:58.6299263Z  * away.
2025-05-24T14:54:58.6299317Z  */
2025-05-24T14:54:58.6299434Z #define BURN_PTR_SIZE(x, s) memset_s((x), (s), 0, (s))
2025-05-24T14:54:58.6299439Z 
2025-05-24T14:54:58.6299493Z /**
2025-05-24T14:54:58.6299655Z  * Explicitly zero data in string. This is guaranteed to be not optimized
2025-05-24T14:54:58.6299724Z  * away.
2025-05-24T14:54:58.6299780Z  */
2025-05-24T14:54:58.6299852Z #define BURN_STR(x)	do { \
2025-05-24T14:54:58.6299920Z 				if ((x) != NULL) { \
2025-05-24T14:54:58.6299995Z 					size_t s = strlen(x); \
2025-05-24T14:54:58.6300070Z 					memset_s((x), s, 0, s); \
2025-05-24T14:54:58.6300128Z 				} \
2025-05-24T14:54:58.6300192Z 			} while(0)
2025-05-24T14:54:58.6300196Z 
2025-05-24T14:54:58.6300251Z /**
2025-05-24T14:54:58.6300369Z  * Work out how many elements there are in a static array.
2025-05-24T14:54:58.6300423Z  */
2025-05-24T14:54:58.6300497Z #ifdef ARRAY_SIZE
2025-05-24T14:54:58.6300561Z #undef ARRAY_SIZE
2025-05-24T14:54:58.6300618Z #endif
2025-05-24T14:54:58.6300724Z #define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
2025-05-24T14:54:58.6300728Z 
2025-05-24T14:54:58.6300783Z /**
2025-05-24T14:54:58.6300891Z  * Remove an array element by moving the rest one down
2025-05-24T14:54:58.6300946Z  */
2025-05-24T14:54:58.6301028Z #define ARRAY_DEL_ELEMENT(a,i,n) \
2025-05-24T14:54:58.6301161Z if((i)<((n)-1)){memmove(&((a)[(i)]),&((a)[(i)+1]),(sizeof(*(a))*((n)-(i)-1)));}
2025-05-24T14:54:58.6301164Z 
2025-05-24T14:54:58.6301220Z /**
2025-05-24T14:54:58.6301333Z  * Insert an array element by moving the rest one up
2025-05-24T14:54:58.6301457Z  *
2025-05-24T14:54:58.6301513Z  */
2025-05-24T14:54:58.6301698Z #define ARRAY_INSERT_ELEMENT(__array,__old_last_idx,__new_elem,__new_idx) do { \
2025-05-24T14:54:58.6301787Z 	if ((__new_idx) < (__old_last_idx)) { \
2025-05-24T14:54:58.6301884Z 		const void *__src = &((__array)[(__new_idx)]); \
2025-05-24T14:54:58.6302042Z 		void *__dst = &((__array)[(__new_idx)+1]); \
2025-05-24T14:54:58.6302143Z 		size_t __num = (__old_last_idx)-(__new_idx); \
2025-05-24T14:54:58.6302230Z 		size_t __len = sizeof(*(__array)) * __num; \
2025-05-24T14:54:58.6302306Z 		memmove(__dst, __src, __len); \
2025-05-24T14:54:58.6302366Z 	} \
2025-05-24T14:54:58.6302445Z 	(__array)[(__new_idx)] = (__new_elem); \
2025-05-24T14:54:58.6302505Z } while(0)
2025-05-24T14:54:58.6302509Z 
2025-05-24T14:54:58.6302564Z /**
2025-05-24T14:54:58.6302642Z  * Pointer difference macro
2025-05-24T14:54:58.6302698Z  */
2025-05-24T14:54:58.6302863Z #define PTR_DIFF(p1,p2) ((ptrdiff_t)(((const char *)(p1)) - (const char *)(p2)))
2025-05-24T14:54:58.6302869Z 
2025-05-24T14:54:58.6302940Z #ifdef __COMPAR_FN_T
2025-05-24T14:54:58.6303021Z #define QSORT_CAST (__compar_fn_t)
2025-05-24T14:54:58.6303076Z #endif
2025-05-24T14:54:58.6303080Z 
2025-05-24T14:54:58.6303145Z #ifndef QSORT_CAST
2025-05-24T14:54:58.6303274Z #define QSORT_CAST (int (*)(const void *, const void *))
2025-05-24T14:54:58.6303332Z #endif
2025-05-24T14:54:58.6303335Z 
2025-05-24T14:54:58.6303397Z #ifndef PATH_MAX
2025-05-24T14:54:58.6303471Z #define PATH_MAX 1024
2025-05-24T14:54:58.6303527Z #endif
2025-05-24T14:54:58.6303530Z 
2025-05-24T14:54:58.6303603Z #ifndef MAX_DNS_NAME_LENGTH
2025-05-24T14:54:58.6303779Z #define MAX_DNS_NAME_LENGTH 256 /* Actually 255 but +1 for terminating null. */
2025-05-24T14:54:58.6303837Z #endif
2025-05-24T14:54:58.6303841Z 
2025-05-24T14:54:58.6303906Z #ifdef HAVE_CRYPT_H
2025-05-24T14:54:58.6303972Z #include <crypt.h>
2025-05-24T14:54:58.6304031Z #endif
2025-05-24T14:54:58.6304035Z 
2025-05-24T14:54:58.6304156Z /* these macros gain us a few percent of speed on gcc */
2025-05-24T14:54:58.6304225Z #if (__GNUC__ >= 3)
2025-05-24T14:54:58.6304381Z /* the strange !! is to ensure that __builtin_expect() takes either 0 or 1
2025-05-24T14:54:58.6304455Z    as its first argument */
2025-05-24T14:54:58.6304517Z #ifndef likely
2025-05-24T14:54:58.6304616Z #define likely(x)   __builtin_expect(!!(x), 1)
2025-05-24T14:54:58.6304676Z #endif
2025-05-24T14:54:58.6304738Z #ifndef unlikely
2025-05-24T14:54:58.6304880Z #define unlikely(x) __builtin_expect(!!(x), 0)
2025-05-24T14:54:58.6304944Z #endif
2025-05-24T14:54:58.6305000Z #else
2025-05-24T14:54:58.6305062Z #ifndef likely
2025-05-24T14:54:58.6305128Z #define likely(x) (x)
2025-05-24T14:54:58.6305189Z #endif
2025-05-24T14:54:58.6305249Z #ifndef unlikely
2025-05-24T14:54:58.6305317Z #define unlikely(x) (x)
2025-05-24T14:54:58.6305494Z #endif
2025-05-24T14:54:58.6305551Z #endif
2025-05-24T14:54:58.6305555Z 
2025-05-24T14:54:58.6305625Z #ifndef HAVE_FDATASYNC
2025-05-24T14:54:58.6305703Z #define fdatasync(fd) fsync(fd)
2025-05-24T14:54:58.6305788Z #elif !defined(HAVE_DECL_FDATASYNC)
2025-05-24T14:54:58.6305857Z int fdatasync(int );
2025-05-24T14:54:58.6305912Z #endif
2025-05-24T14:54:58.6305915Z 
2025-05-24T14:54:58.6306053Z /* these are used to mark symbols as local to a shared lib, or
2025-05-24T14:54:58.6306155Z  * publicly available via the shared lib API */
2025-05-24T14:54:58.6306218Z #ifndef _PUBLIC_
2025-05-24T14:54:58.6306296Z #ifdef HAVE_VISIBILITY_ATTR
2025-05-24T14:54:58.6306418Z #define _PUBLIC_ __attribute__((visibility("default")))
2025-05-24T14:54:58.6306475Z #else
2025-05-24T14:54:58.6306536Z #define _PUBLIC_
2025-05-24T14:54:58.6306596Z #endif
2025-05-24T14:54:58.6306651Z #endif
2025-05-24T14:54:58.6306654Z 
2025-05-24T14:54:58.6306717Z #ifndef _PRIVATE_
2025-05-24T14:54:58.6306797Z #ifdef HAVE_VISIBILITY_ATTR
2025-05-24T14:54:58.6306916Z #  define _PRIVATE_ __attribute__((visibility("hidden")))
2025-05-24T14:54:58.6306972Z #else
2025-05-24T14:54:58.6307038Z #  define _PRIVATE_
2025-05-24T14:54:58.6307173Z #endif
2025-05-24T14:54:58.6307229Z #endif
2025-05-24T14:54:58.6307233Z 
2025-05-24T14:54:58.6307297Z #ifndef HAVE_POLL
2025-05-24T14:54:58.6307371Z #define poll rep_poll
2025-05-24T14:54:58.6307455Z /* prototype is in "system/network.h" */
2025-05-24T14:54:58.6307513Z #endif
2025-05-24T14:54:58.6307517Z 
2025-05-24T14:54:58.6307689Z #ifndef HAVE_GETPEEREID
2025-05-24T14:54:58.6307777Z #define getpeereid rep_getpeereid
2025-05-24T14:54:58.6307889Z int rep_getpeereid(int s, uid_t *uid, gid_t *gid);
2025-05-24T14:54:58.6307947Z #endif
2025-05-24T14:54:58.6307951Z 
2025-05-24T14:54:58.6308020Z #ifndef HAVE_USLEEP
2025-05-24T14:54:58.6308095Z #define usleep rep_usleep
2025-05-24T14:54:58.6308162Z int usleep(useconds_t);
2025-05-24T14:54:58.6308218Z #endif
2025-05-24T14:54:58.6308226Z 
2025-05-24T14:54:58.6308299Z #ifndef HAVE_SETPROCTITLE
2025-05-24T14:54:58.6308385Z #define setproctitle rep_setproctitle
2025-05-24T14:54:58.6308543Z void rep_setproctitle(const char *fmt, ...) PRINTF_ATTRIBUTE(1, 2);
2025-05-24T14:54:58.6308607Z #endif
2025-05-24T14:54:58.6308610Z 
2025-05-24T14:54:58.6308688Z #ifndef HAVE_SETPROCTITLE_INIT
2025-05-24T14:54:58.6308789Z #define setproctitle_init rep_setproctitle_init
2025-05-24T14:54:58.6308937Z void rep_setproctitle_init(int argc, char *argv[], char *envp[]);
2025-05-24T14:54:58.6308994Z #endif
2025-05-24T14:54:58.6309000Z 
2025-05-24T14:54:58.6309067Z #ifndef HAVE_MEMSET_S
2025-05-24T14:54:58.6309144Z #define memset_s rep_memset_s
2025-05-24T14:54:58.6309292Z int rep_memset_s(void *dest, size_t destsz, int ch, size_t count);
2025-05-24T14:54:58.6309347Z #endif
2025-05-24T14:54:58.6309350Z 
2025-05-24T14:54:58.6309420Z #ifndef HAVE_GETPROGNAME
2025-05-24T14:54:58.6309504Z #define getprogname rep_getprogname
2025-05-24T14:54:58.6309586Z const char *rep_getprogname(void);
2025-05-24T14:54:58.6309644Z #endif
2025-05-24T14:54:58.6309647Z 
2025-05-24T14:54:58.6309728Z #ifndef HAVE_COPY_FILE_RANGE
2025-05-24T14:54:58.6309819Z #define copy_file_range rep_copy_file_range
2025-05-24T14:54:58.6309908Z ssize_t rep_copy_file_range(int fd_in,
2025-05-24T14:54:58.6309974Z 			    loff_t *off_in,
2025-05-24T14:54:58.6310044Z 			    int fd_out,
2025-05-24T14:54:58.6310108Z 			    loff_t *off_out,
2025-05-24T14:54:58.6310169Z 			    size_t len,
2025-05-24T14:54:58.6310244Z 			    unsigned int flags);
2025-05-24T14:54:58.6310324Z #endif /* HAVE_COPY_FILE_RANGE */
2025-05-24T14:54:58.6310327Z 
2025-05-24T14:54:58.6310393Z #ifndef FALL_THROUGH
2025-05-24T14:54:58.6310537Z # ifdef HAVE_FALLTHROUGH_ATTRIBUTE
2025-05-24T14:54:58.6310652Z #  define FALL_THROUGH __attribute__ ((fallthrough))
2025-05-24T14:54:58.6310736Z # else /* HAVE_FALLTHROUGH_ATTRIBUTE */
2025-05-24T14:54:58.6310811Z #  define FALL_THROUGH ((void)0)
2025-05-24T14:54:58.6310897Z # endif /* HAVE_FALLTHROUGH_ATTRIBUTE */
2025-05-24T14:54:58.6310966Z #endif /* FALL_THROUGH */
2025-05-24T14:54:58.6310970Z 
2025-05-24T14:54:58.6311045Z struct __rep_cwrap_enabled_state {
2025-05-24T14:54:58.6311114Z 	const char *fnname;
2025-05-24T14:54:58.6311175Z 	bool cached;
2025-05-24T14:54:58.6311234Z 	bool retval;
2025-05-24T14:54:58.6311288Z };
2025-05-24T14:54:58.6311292Z 
2025-05-24T14:54:58.6311486Z static inline bool __rep_cwrap_enabled_fn(struct __rep_cwrap_enabled_state *state)
2025-05-24T14:54:58.6311542Z {
2025-05-24T14:54:58.6311637Z 	bool (*__wrapper_enabled_fn)(void) = NULL;
2025-05-24T14:54:58.6311641Z 
2025-05-24T14:54:58.6311713Z 	if (state->cached) {
2025-05-24T14:54:58.6311782Z 		return state->retval;
2025-05-24T14:54:58.6311838Z 	}
2025-05-24T14:54:58.6311904Z 	state->retval = false;
2025-05-24T14:54:58.6311973Z 	state->cached = true;
2025-05-24T14:54:58.6311977Z 
2025-05-24T14:54:58.6312135Z 	__wrapper_enabled_fn = (bool (*)(void))dlsym(RTLD_DEFAULT, state->fnname);
2025-05-24T14:54:58.6312211Z 	if (__wrapper_enabled_fn == NULL) {
2025-05-24T14:54:58.6312282Z 		return state->retval;
2025-05-24T14:54:58.6312338Z 	}
2025-05-24T14:54:58.6312342Z 
2025-05-24T14:54:58.6312428Z 	state->retval = __wrapper_enabled_fn();
2025-05-24T14:54:58.6312543Z 	return state->retval;
2025-05-24T14:54:58.6312598Z }
2025-05-24T14:54:58.6312602Z 
2025-05-24T14:54:58.6312698Z static inline bool nss_wrapper_enabled(void)
2025-05-24T14:54:58.6312752Z {
2025-05-24T14:54:58.6312843Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.6312917Z 		.fnname = "nss_wrapper_enabled",
2025-05-24T14:54:58.6313098Z 	};
2025-05-24T14:54:58.6313190Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.6313248Z }
2025-05-24T14:54:58.6313357Z static inline bool nss_wrapper_hosts_enabled(void)
2025-05-24T14:54:58.6313413Z {
2025-05-24T14:54:58.6313503Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.6313586Z 		.fnname = "nss_wrapper_hosts_enabled",
2025-05-24T14:54:58.6313642Z 	};
2025-05-24T14:54:58.6313726Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.6313783Z }
2025-05-24T14:54:58.6313884Z static inline bool socket_wrapper_enabled(void)
2025-05-24T14:54:58.6313942Z {
2025-05-24T14:54:58.6314030Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.6314112Z 		.fnname = "socket_wrapper_enabled",
2025-05-24T14:54:58.6314167Z 	};
2025-05-24T14:54:58.6314251Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.6314307Z }
2025-05-24T14:54:58.6314402Z static inline bool uid_wrapper_enabled(void)
2025-05-24T14:54:58.6314463Z {
2025-05-24T14:54:58.6314554Z 	struct __rep_cwrap_enabled_state state = {
2025-05-24T14:54:58.6314628Z 		.fnname = "uid_wrapper_enabled",
2025-05-24T14:54:58.6314684Z 	};
2025-05-24T14:54:58.6314765Z 	return __rep_cwrap_enabled_fn(&state);
2025-05-24T14:54:58.6314820Z }
2025-05-24T14:54:58.6314823Z 
2025-05-24T14:54:58.6314935Z static inline bool _hexcharval(char c, uint8_t *val)
2025-05-24T14:54:58.6314990Z {
2025-05-24T14:54:58.6315099Z 	if ((c >= '0') && (c <= '9')) { *val = c - '0';      return true; }
2025-05-24T14:54:58.6315194Z 	if ((c >= 'a') && (c <= 'f')) {	*val = c - 'a' + 10; return true; }
2025-05-24T14:54:58.6315285Z 	if ((c >= 'A') && (c <= 'F')) { *val = c - 'A' + 10; return true; }
2025-05-24T14:54:58.6315461Z 	return false;
2025-05-24T14:54:58.6315518Z }
2025-05-24T14:54:58.6315522Z 
2025-05-24T14:54:58.6315649Z static inline bool hex_byte(const char *in, uint8_t *out)
2025-05-24T14:54:58.6315704Z {
2025-05-24T14:54:58.6315775Z 	uint8_t hi=0, lo=0;
2025-05-24T14:54:58.6315904Z 	bool ok = _hexcharval(in[0], &hi) && _hexcharval(in[1], &lo);
2025-05-24T14:54:58.6315968Z 	*out = (hi<<4)+lo;
2025-05-24T14:54:58.6316032Z 	return ok;
2025-05-24T14:54:58.6316163Z }
2025-05-24T14:54:58.6316167Z 
2025-05-24T14:54:58.6316273Z /* Needed for Solaris atomic_add_XX functions. */
2025-05-24T14:54:58.6316356Z #if defined(HAVE_SYS_ATOMIC_H)
2025-05-24T14:54:58.6316425Z #include <sys/atomic.h>
2025-05-24T14:54:58.6316486Z #endif
2025-05-24T14:54:58.6316490Z 
2025-05-24T14:54:58.6316544Z /*
2025-05-24T14:54:58.6316723Z  * This handles the case of missing pthread support and ensures code can use
2025-05-24T14:54:58.6316909Z  * __thread unconditionally, such that when built on a platform without pthread
2025-05-24T14:54:58.6317023Z  * support, the __thread qualifier is an empty define.
2025-05-24T14:54:58.6317083Z  */
2025-05-24T14:54:58.6317147Z #ifndef HAVE___THREAD
2025-05-24T14:54:58.6317213Z # ifdef HAVE_PTHREAD
2025-05-24T14:54:58.6317386Z # error Configure failed to detect pthread library with missing TLS support
2025-05-24T14:54:58.6317458Z # endif
2025-05-24T14:54:58.6317525Z #define HAVE___THREAD
2025-05-24T14:54:58.6317581Z #endif
2025-05-24T14:54:58.6317587Z 
2025-05-24T14:54:58.6317672Z #endif /* _LIBREPLACE_REPLACE_H */
2025-05-24T14:54:58.6317750Z === End of patched replace.h ===
2025-05-24T14:54:58.6327824Z ##[error]Process completed with exit code 1.
2025-05-24T14:54:58.6423742Z ##[group]Run actions/upload-artifact@v4
2025-05-24T14:54:58.6423817Z with:
2025-05-24T14:54:58.6423895Z   name: build_logs
2025-05-24T14:54:58.6424172Z   path: proot_patch_preview.log
proot_build.log
talloc-2.4.2/config.log
talloc-2.4.2/build/config.log

2025-05-24T14:54:58.6424252Z   if-no-files-found: warn
2025-05-24T14:54:58.6424420Z   compression-level: 6
2025-05-24T14:54:58.6424493Z   overwrite: false
2025-05-24T14:54:58.6424571Z   include-hidden-files: false
2025-05-24T14:54:58.6424631Z env:
2025-05-24T14:54:58.6424731Z   ANDROID_NDK_HOME: /home/runner/android-ndk
2025-05-24T14:54:58.6426023Z   PATH: /home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
2025-05-24T14:54:58.6426099Z ##[endgroup]
2025-05-24T14:54:58.8729015Z Multiple search paths detected. Calculating the least common ancestor of all paths
2025-05-24T14:54:58.8736045Z The least common ancestor is /home/runner/work/boost-armv8-build/boost-armv8-build. This will be the root directory of the artifact
2025-05-24T14:54:58.8748350Z ##[warning]No files were found with the provided path: proot_patch_preview.log
proot_build.log
talloc-2.4.2/config.log
talloc-2.4.2/build/config.log. No artifacts will be uploaded.
2025-05-24T14:54:58.8851437Z ##[group]Run actions/upload-artifact@v4
2025-05-24T14:54:58.8851513Z with:
2025-05-24T14:54:58.8851593Z   name: error_logs
2025-05-24T14:54:58.8851754Z   path: **/*.log
talloc-2.4.2/config.log
talloc-2.4.2/build/config.log

2025-05-24T14:54:58.8851842Z   if-no-files-found: warn
2025-05-24T14:54:58.8851925Z   compression-level: 6
2025-05-24T14:54:58.8851990Z   overwrite: false
2025-05-24T14:54:58.8852076Z   include-hidden-files: false
2025-05-24T14:54:58.8852133Z env:
2025-05-24T14:54:58.8852241Z   ANDROID_NDK_HOME: /home/runner/android-ndk
2025-05-24T14:54:58.8853265Z   PATH: /home/runner/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
2025-05-24T14:54:58.8853336Z ##[endgroup]
2025-05-24T14:55:05.2673076Z With the provided path, there will be 16 files uploaded
2025-05-24T14:55:05.2679111Z Artifact name is valid!
2025-05-24T14:55:05.2680150Z Root directory input is valid!
2025-05-24T14:55:05.3750109Z Beginning upload of artifact content to blob storage
2025-05-24T14:55:05.4973139Z Uploaded bytes 64836
2025-05-24T14:55:05.5175192Z Finished uploading artifact content to blob storage!
2025-05-24T14:55:05.5178893Z SHA256 digest of uploaded artifact zip is 99343250a6b0b77a495ea7ecc7373deb411b8e722b7b70a1c81a2053a78c75d4
2025-05-24T14:55:05.5180722Z Finalizing artifact upload
2025-05-24T14:55:05.5967660Z Artifact error_logs.zip successfully finalized. Artifact ID 3190686769
2025-05-24T14:55:05.5968628Z Artifact error_logs has been successfully uploaded! Final size is 64836 bytes. Artifact ID is 3190686769
2025-05-24T14:55:05.5975329Z Artifact download URL: https://github.com/AkinAb55/boost-armv8-build/actions/runs/15228189942/artifacts/3190686769
2025-05-24T14:55:05.6187086Z Post job cleanup.
2025-05-24T14:55:05.7138593Z [command]/usr/bin/git version
2025-05-24T14:55:05.7182682Z git version 2.49.0
2025-05-24T14:55:05.7246981Z Temporarily overriding HOME='/home/runner/work/_temp/7dc1383b-0519-426f-82d4-14643d4f73f7' before making global git config changes
2025-05-24T14:55:05.7251456Z Adding repository directory to the temporary git global config as a safe directory
2025-05-24T14:55:05.7265989Z [command]/usr/bin/git config --global --add safe.directory /home/runner/work/boost-armv8-build/boost-armv8-build
2025-05-24T14:55:05.7310225Z [command]/usr/bin/git config --local --name-only --get-regexp core\.sshCommand
2025-05-24T14:55:05.7352145Z [command]/usr/bin/git submodule foreach --recursive sh -c "git config --local --name-only --get-regexp 'core\.sshCommand' && git config --local --unset-all 'core.sshCommand' || :"
2025-05-24T14:55:05.7647189Z [command]/usr/bin/git config --local --name-only --get-regexp http\.https\:\/\/github\.com\/\.extraheader
2025-05-24T14:55:05.7670436Z http.https://github.com/.extraheader
2025-05-24T14:55:05.7683520Z [command]/usr/bin/git config --local --unset-all http.https://github.com/.extraheader
2025-05-24T14:55:05.7716336Z [command]/usr/bin/git submodule foreach --recursive sh -c "git config --local --name-only --get-regexp 'http\.https\:\/\/github\.com\/\.extraheader' && git config --local --unset-all 'http.https://github.com/.extraheader' || :"
2025-05-24T14:55:05.8056523Z Cleaning up orphan processes